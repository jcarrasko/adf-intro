import { CommonModule, DatePipe, Location } from '@angular/common';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { APP_INITIALIZER, ChangeDetectionStrategy, ChangeDetectorRef, Compiler, Component, ComponentFactoryResolver, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostListener, Inject, Injectable, InjectionToken, Input, IterableDiffers, NgModule, NgZone, Optional, Output, Pipe, Renderer, Renderer2, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation, forwardRef } from '@angular/core';
import { FormBuilder, FormControl, FormsModule, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validators } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { TranslateLoader, TranslateModule, TranslateService } from '@ngx-translate/core';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';
import * as alfrescoApi from 'alfresco-js-api';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/concat';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/merge';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/toArray';
import 'rxjs/add/operator/take';
import { DateAdapter, MAT_DATE_FORMATS, MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepicker, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule, MatIconRegistry, MatInputModule, MatListModule, MatMenuModule, MatMenuTrigger, MatNativeDateModule, MatOptionModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSlideToggleModule, MatSnackBar, MatSnackBarModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule } from '@angular/material';
import { FlexLayoutModule } from '@angular/flex-layout';
import moment from 'moment-es6';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { isMoment } from 'moment';
import { OverlayContainer } from '@angular/cdk/overlay';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { Router, RouterModule } from '@angular/router';
import { DomSanitizer, Title } from '@angular/platform-browser';
import { Observable as Observable$1 } from 'rxjs/Observable';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/do';
import 'rxjs/observable/forkJoin';
import 'rxjs/add/observable/from';
import 'rxjs/add/observable/zip';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/buffer';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/concatMap';
import 'rxjs/add/operator/combineAll';
import 'rxjs/add/observable/interval';
import 'rxjs/add/operator/takeWhile';
import { HttpModule } from '@angular/http';
import 'rxjs/add/operator/defaultIfEmpty';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import 'rxjs/add/observable/forkJoin';
import * as minimatch_ from 'minimatch';
import minimatch___default from 'minimatch';

class ObjectUtils {
    /**
     * Gets a value from an object by composed key
     * ObjectUtils.getValue({ item: { nodeType: 'cm:folder' }}, 'item.nodeType') ==> 'cm:folder'
     * @param {?} target
     * @param {?} key
     * @return {?}
     */
    static getValue(target, key) {
        if (!target) {
            return undefined;
        }
        let /** @type {?} */ keys = key.split('.');
        key = '';
        do {
            key += keys.shift();
            let /** @type {?} */ value = target[key];
            if (value !== undefined && (typeof value === 'object' || !keys.length)) {
                target = value;
                key = '';
            }
            else if (!keys.length) {
                target = undefined;
            }
            else {
                key += '.';
            }
        } while (keys.length);
        return target;
    }
    /**
     * @param {...?} objects
     * @return {?}
     */
    static merge(...objects) {
        let /** @type {?} */ result = {};
        objects.forEach(source => {
            Object.keys(source).forEach(prop => {
                if (prop in result && Array.isArray(result[prop])) {
                    result[prop] = result[prop].concat(source[prop]);
                }
                else if (prop in result && typeof result[prop] === 'object') {
                    result[prop] = ObjectUtils.merge(result[prop], source[prop]);
                }
                else {
                    result[prop] = source[prop];
                }
            });
        });
        return result;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppConfigService {
    /**
     * @param {?} http
     */
    constructor(http$$1) {
        this.http = http$$1;
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent'
        };
    }
    /**
     * @template T
     * @param {?} key
     * @param {?=} defaultValue
     * @return {?}
     */
    get(key, defaultValue) {
        let /** @type {?} */ result = ObjectUtils.getValue(this.config, key);
        if (typeof result === 'string') {
            const /** @type {?} */ map$$1 = new Map();
            map$$1.set('hostname', this.getLocationHostname());
            map$$1.set(':port', this.getLocationPort(':'));
            map$$1.set('port', this.getLocationPort());
            result = this.formatString(result, map$$1);
        }
        if (result === undefined) {
            return defaultValue;
        }
        return /** @type {?} */ (result);
    }
    /**
     * @return {?}
     */
    getLocationHostname() {
        return location.hostname;
    }
    /**
     * @param {?=} prefix
     * @return {?}
     */
    getLocationPort(prefix = '') {
        return location.port ? prefix + location.port : '';
    }
    /**
     * @return {?}
     */
    load() {
        return new Promise(resolve => {
            this.http.get('app.config.json').subscribe((data) => {
                this.config = Object.assign({}, this.config, data || {});
                resolve(this.config);
            }, () => {
                resolve(this.config);
            });
        });
    }
    /**
     * @param {?} str
     * @param {?} map
     * @return {?}
     */
    formatString(str, map$$1) {
        let /** @type {?} */ result = str;
        map$$1.forEach((value, key) => {
            const /** @type {?} */ expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        });
        return result;
    }
}
AppConfigService.APP_CONFIG_LANGUAGES_KEY = 'languages';
AppConfigService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AppConfigService.ctorParameters = () => [
    { type: HttpClient, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StorageService {
    constructor() {
        this.memoryStore = {};
        this.useLocalStorage = false;
        this.useLocalStorage = this.storageAvailable('localStorage');
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(key);
        }
        else {
            return this.memoryStore.hasOwnProperty(key) ? this.memoryStore[key] : null;
        }
    }
    /**
     * @param {?} key
     * @param {?} data
     * @return {?}
     */
    setItem(key, data) {
        if (this.useLocalStorage) {
            localStorage.setItem(key, data);
        }
        else {
            this.memoryStore[key] = data.toString();
        }
    }
    /**
     * @return {?}
     */
    clear() {
        if (this.useLocalStorage) {
            localStorage.clear();
        }
        else {
            this.memoryStore = {};
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        if (this.useLocalStorage) {
            localStorage.removeItem(key);
        }
        else {
            delete this.memoryStore[key];
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    hasItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(key) ? true : false;
        }
        else {
            return this.memoryStore.hasOwnProperty(key);
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    storageAvailable(type) {
        try {
            let /** @type {?} */ storage = window[type];
            const /** @type {?} */ key = '__storage_test__';
            storage.setItem(key, key);
            storage.removeItem(key, key);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
StorageService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
StorageService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AlfrescoApiService {
    /**
     * @param {?} appConfig
     * @param {?} storage
     */
    constructor(appConfig, storage) {
        this.appConfig = appConfig;
        this.storage = storage;
        this.reset();
    }
    /**
     * @return {?}
     */
    getInstance() {
        return this.alfrescoApi;
    }
    /**
     * @return {?}
     */
    get contentApi() {
        return this.getInstance().content;
    }
    /**
     * @return {?}
     */
    get nodesApi() {
        return this.getInstance().nodes;
    }
    /**
     * @return {?}
     */
    get renditionsApi() {
        return this.getInstance().core.renditionsApi;
    }
    /**
     * @return {?}
     */
    get sharedLinksApi() {
        return this.getInstance().core.sharedlinksApi;
    }
    /**
     * @return {?}
     */
    get sitesApi() {
        return this.getInstance().core.sitesApi;
    }
    /**
     * @return {?}
     */
    get favoritesApi() {
        return this.getInstance().core.favoritesApi;
    }
    /**
     * @return {?}
     */
    get peopleApi() {
        return this.getInstance().core.peopleApi;
    }
    /**
     * @return {?}
     */
    get searchApi() {
        return this.getInstance().search.searchApi;
    }
    /**
     * @return {?}
     */
    get versionsApi() {
        return this.getInstance().core.versionsApi;
    }
    /**
     * @return {?}
     */
    reset() {
        this.alfrescoApi = /** @type {?} */ (new alfrescoApi({
            provider: this.storage.getItem('AUTH_TYPE'),
            ticketEcm: this.storage.getItem('ticket-ECM'),
            ticketBpm: this.storage.getItem('ticket-BPM'),
            hostEcm: this.appConfig.get('ecmHost'),
            hostBpm: this.appConfig.get('bpmHost'),
            contextRoot: 'alfresco',
            disableCsrf: this.storage.getItem('DISABLE_CSRF') === 'true'
        }));
    }
}
AlfrescoApiService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AlfrescoApiService.ctorParameters = () => [
    { type: AppConfigService, },
    { type: StorageService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserPreferencesService {
    /**
     * @param {?} translate
     * @param {?} appConfig
     * @param {?} storage
     * @param {?} apiService
     */
    constructor(translate, appConfig, storage, apiService) {
        this.translate = translate;
        this.appConfig = appConfig;
        this.storage = storage;
        this.apiService = apiService;
        this.defaults = {
            paginationSize: 25,
            locale: 'en'
        };
        const currentLocale = this.locale || this.getDefaultLocale();
        this.localeSubject = new BehaviorSubject$1(currentLocale);
        this.locale$ = this.localeSubject.asObservable();
        this.defaults.paginationSize = appConfig.get('pagination.size', 25);
    }
    /**
     * @param {?} property
     * @param {?=} defaultValue
     * @return {?}
     */
    get(property, defaultValue) {
        const /** @type {?} */ key = this.getPropertyKey(property);
        const /** @type {?} */ value = this.storage.getItem(key);
        if (value === undefined) {
            return defaultValue;
        }
        return value;
    }
    /**
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    set(property, value) {
        if (!property) {
            return;
        }
        this.storage.setItem(this.getPropertyKey(property), value);
    }
    /**
     * @return {?}
     */
    getStoragePrefix() {
        return this.storage.getItem('USER_PROFILE') || 'GUEST';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setStoragePrefix(value) {
        this.storage.setItem('USER_PROFILE', value || 'GUEST');
    }
    /**
     * @param {?} property
     * @return {?}
     */
    getPropertyKey(property) {
        return `${this.getStoragePrefix()}__${property}`;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set authType(value) {
        this.storage.setItem('AUTH_TYPE', value);
        this.apiService.reset();
    }
    /**
     * @return {?}
     */
    get authType() {
        return this.storage.getItem('AUTH_TYPE') || 'ALL';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableCSRF(value) {
        this.set('DISABLE_CSRF', value);
        this.apiService.reset();
    }
    /**
     * @return {?}
     */
    get disableCSRF() {
        return this.get('DISABLE_CSRF') === 'true';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set paginationSize(value) {
        this.set('PAGINATION_SIZE', value);
    }
    /**
     * @return {?}
     */
    get paginationSize() {
        return Number(this.get('PAGINATION_SIZE')) || this.defaults.paginationSize;
    }
    /**
     * @return {?}
     */
    get locale() {
        const /** @type {?} */ locale = this.get('LOCALE');
        return locale;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this.localeSubject.next(value);
        this.set('LOCALE', value);
    }
    /**
     * @return {?}
     */
    getDefaultLocale() {
        return this.appConfig.get('locale') || this.translate.getBrowserLang() || 'en';
    }
}
UserPreferencesService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
UserPreferencesService.ctorParameters = () => [
    { type: TranslateService, },
    { type: AppConfigService, },
    { type: StorageService, },
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TRANSLATION_PROVIDER = new InjectionToken('Injection token for translation providers.');
class TranslationService {
    /**
     * @param {?} translate
     * @param {?} userPreference
     * @param {?} providers
     */
    constructor(translate, userPreference, providers) {
        this.translate = translate;
        this.userPreference = userPreference;
        this.customLoader = this.translate.currentLoader;
        this.defaultLang = 'en';
        translate.setDefaultLang(this.defaultLang);
        if (providers && providers.length > 0) {
            for (let provider of providers) {
                this.addTranslationFolder(provider.name, provider.source);
            }
        }
        this.userPreference.locale$.subscribe((locale) => {
            this.userLang = locale;
            this.use(this.userLang);
        });
    }
    /**
     * @param {?=} name
     * @param {?=} path
     * @return {?}
     */
    addTranslationFolder(name = '', path = '') {
        if (!this.customLoader.providerRegistered(name)) {
            this.customLoader.registerProvider(name, path);
            if (this.userLang !== this.defaultLang) {
                this.translate.getTranslation(this.defaultLang).subscribe(() => {
                    this.translate.getTranslation(this.userLang).subscribe(() => {
                        this.translate.use(this.userLang);
                    });
                });
            }
            else {
                this.translate.getTranslation(this.userLang).subscribe(() => {
                    this.translate.use(this.userLang);
                });
            }
        }
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    use(lang) {
        this.customLoader.init(lang);
        return this.translate.use(lang);
    }
    /**
     * @param {?} key
     * @param {?=} interpolateParams
     * @return {?}
     */
    get(key, interpolateParams) {
        return this.translate.get(key, interpolateParams);
    }
}
TranslationService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
TranslationService.ctorParameters = () => [
    { type: TranslateService, },
    { type: UserPreferencesService, },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATION_PROVIDER,] },] },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule,
        MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule,
        MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule,
        MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule,
        MatMenuModule, MatProgressBarModule, MatSidenavModule, MatSnackBarModule, MatToolbarModule,
        MatTooltipModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] },
];
/**
 * @nocollapse
 */
MaterialModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} configService
 * @return {?}
 */
function startupServiceFactory(configService) {
    return () => configService.load();
}
class AppConfigModule {
}
AppConfigModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule
                ],
                providers: [
                    AppConfigService,
                    {
                        provide: APP_INITIALIZER,
                        useFactory: startupServiceFactory,
                        deps: [
                            AppConfigService
                        ],
                        multi: true
                    }
                ]
            },] },
];
/**
 * @nocollapse
 */
AppConfigModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewContentProxyDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
CardViewContentProxyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-card-view-content-proxy]'
            },] },
];
/**
 * @nocollapse
 */
CardViewContentProxyDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function transformKeyToObject(key, value) {
    const /** @type {?} */ objectLevels = key.split('.').reverse();
    return objectLevels.reduce((previousValue, currentValue) => {
        return { [currentValue]: previousValue };
    }, value);
}
class CardViewUpdateService {
    constructor() {
        this.itemUpdatedSource = new Subject$1();
        this.itemClickedSource = new Subject$1();
        this.itemUpdated$ = (this.itemUpdatedSource.asObservable());
        this.itemClicked$ = (this.itemClickedSource.asObservable());
    }
    /**
     * @param {?} property
     * @param {?} newValue
     * @return {?}
     */
    update(property, newValue) {
        this.itemUpdatedSource.next({
            target: property,
            changed: transformKeyToObject(property.key, newValue)
        });
    }
    /**
     * @param {?} property
     * @return {?}
     */
    clicked(property) {
        this.itemClickedSource.next({
            target: property
        });
    }
}
CardViewUpdateService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
CardViewUpdateService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dateNames = [];
for (let /** @type {?} */ date = 1; date <= 31; date++) {
    dateNames.push(String(date));
}
class MomentDateAdapter extends DateAdapter {
    constructor() {
        super(...arguments);
        this.localeData = moment.localeData();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYear(date) {
        return date.year();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMonth(date) {
        return date.month();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDate(date) {
        return date.date();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayOfWeek(date) {
        return date.day();
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getMonthNames(style$$1) {
        switch (style$$1) {
            case 'long':
                return this.localeData.months();
            case 'short':
                return this.localeData.monthsShort();
            case 'narrow':
                return this.localeData.monthsShort().map(month => month[0]);
            default:
                return;
        }
    }
    /**
     * @return {?}
     */
    getDateNames() {
        return dateNames;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getDayOfWeekNames(style$$1) {
        switch (style$$1) {
            case 'long':
                return this.localeData.weekdays();
            case 'short':
                return this.localeData.weekdaysShort();
            case 'narrow':
                return this.localeData.weekdaysShort();
            default:
                return;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYearName(date) {
        return String(date.year());
    }
    /**
     * @return {?}
     */
    getFirstDayOfWeek() {
        return this.localeData.firstDayOfWeek();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getNumDaysInMonth(date) {
        return date.daysInMonth();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        return date.clone();
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    createDate(year, month, date) {
        return moment([year, month, date]);
    }
    /**
     * @return {?}
     */
    today() {
        return moment();
    }
    /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    parse(value, parseFormat) {
        let /** @type {?} */ m = moment(value, parseFormat, true);
        if (!m.isValid()) {
            m = moment(value, this.overrideDisplyaFormat);
        }
        if (m.isValid()) {
            // if user omits year, it defaults to 2001, so check for that issue.
            if (m.year() === 2001 && value.indexOf('2001') === -1) {
                // if 2001 not actually in the value string, change to current year
                const /** @type {?} */ currentYear = new Date().getFullYear();
                m.set('year', currentYear);
                // if date is in the future, set previous year
                if (m.isAfter(moment())) {
                    m.set('year', currentYear - 1);
                }
            }
            return m;
        }
        else {
            return null;
        }
    }
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    format(date, displayFormat) {
        displayFormat = this.overrideDisplyaFormat ? this.overrideDisplyaFormat : displayFormat;
        if (date && date.format) {
            return date.format(displayFormat);
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    addCalendarYears(date, years) {
        return date.clone().add(years, 'y');
    }
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    addCalendarMonths(date, months) {
        return date.clone().add(months, 'M');
    }
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    addCalendarDays(date, days) {
        return date.clone().add(days, 'd');
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getISODateString(date) {
        return date.toISOString();
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        this.localeData = moment.localeData(locale);
    }
    /**
     * @param {?} first
     * @param {?} second
     * @return {?}
     */
    compareDate(first, second) {
        return first.diff(second, 'seconds', true);
    }
    /**
     * @param {?} first
     * @param {?} second
     * @return {?}
     */
    sameDate(first, second) {
        if (first == null) {
            // same if both null
            return second == null;
        }
        else if (isMoment(first)) {
            return first.isSame(second);
        }
        else {
            const /** @type {?} */ isSame = super.sameDate(first, second);
            return isSame;
        }
    }
    /**
     * @param {?} date
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    clampDate(date, min, max) {
        if (min && date.isBefore(min)) {
            return min;
        }
        else if (max && date.isAfter(max)) {
            return max;
        }
        else {
            return date;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isDateInstance(date) {
        let /** @type {?} */ isValidDateInstance = false;
        if (date) {
            isValidDateInstance = date._isAMomentObject;
        }
        return isValidDateInstance;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isValid(date) {
        return date.isValid();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toIso8601(date) {
        return this.clone(date).format();
    }
    /**
     * @param {?} iso8601String
     * @return {?}
     */
    fromIso8601(iso8601String) {
        let /** @type {?} */ d = moment(iso8601String, moment.ISO_8601).locale(this.locale);
        return this.isValid(d) ? d : null;
    }
    /**
     * @return {?}
     */
    invalid() {
        return moment.invalid();
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MOMENT_DATE_FORMATS = {
    parse: {
        dateInput: 'DD/MM/YYYY'
    },
    display: {
        dateInput: 'DD/MM/YYYY',
        monthYearLabel: 'MMMM Y',
        dateA11yLabel: 'LL',
        monthYearA11yLabel: 'MMMM Y'
    }
};
const dateNames$1 = [];
for (let /** @type {?} */ date = 1; date <= 31; date++) {
    dateNames$1.push(String(date));
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewDateItemComponent {
    /**
     * @param {?} cardViewUpdateService
     * @param {?} dateAdapter
     * @param {?} preferences
     */
    constructor(cardViewUpdateService, dateAdapter, preferences) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.SHOW_FORMAT = 'MMM DD YY';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        let /** @type {?} */ momentDateAdapter = (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.SHOW_FORMAT;
        if (this.property.value) {
            this.valueDate = moment(this.property.value, this.SHOW_FORMAT);
        }
    }
    /**
     * @return {?}
     */
    isEditable() {
        return this.editable && this.property.editable;
    }
    /**
     * @return {?}
     */
    showDatePicker() {
        this.datepicker.open();
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue) {
            let /** @type {?} */ momentDate = moment(newDateValue.value, this.SHOW_FORMAT, true);
            if (momentDate.isValid()) {
                this.valueDate = momentDate;
                this.cardViewUpdateService.update(this.property, momentDate.toDate());
            }
        }
    }
}
CardViewDateItemComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: MOMENT_DATE_FORMATS }
                ],
                selector: 'adf-card-view-dateitem',
                template: `
      <div class="adf-property-label">{{ property.label | translate }}</div>
      <div class="adf-property-value">
          <span *ngIf="!isEditable()">
              <span [attr.data-automation-id]="'card-dateitem-' + property.key">
                  <span *ngIf="!property.isEmpty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
              </span>
          </span>
          <span *ngIf="isEditable()" class="adf-dateitem-editable">
              <input class="adf-invisible-date-input" [matDatepicker]="picker" [value]="valueDate"
                     (dateChange)="onDateChanged($event)">
              <span
                  class="adf-datepicker-toggle"
                  [attr.data-automation-id]="'datepicker-label-toggle-' + property.key"
                  (click)="showDatePicker($event)">
                  <span *ngIf="!property.isEmpty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
              </span>
              <mat-datepicker-toggle
                  [attr.data-automation-id]="'datepickertoggle-' + property.key"
                  [for]="picker">
              </mat-datepicker-toggle>
              <mat-datepicker #picker
                             [attr.data-automation-id]="'datepicker-' + property.key"
                             [startAt]="valueDate"
                             [touchUi]="true">
              </mat-datepicker>
          </span>
          <ng-template #elseEmptyValueBlock>
              {{ property.default | translate }}
          </ng-template>
      </div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
CardViewDateItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService, },
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];
CardViewDateItemComponent.propDecorators = {
    'property': [{ type: Input },],
    'editable': [{ type: Input },],
    'datepicker': [{ type: ViewChild, args: [MatDatepicker,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewMapItemComponent {
    /**
     * @param {?} cardViewUpdateService
     */
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
    }
    /**
     * @return {?}
     */
    isClickable() {
        return this.property.clickable;
    }
    /**
     * @return {?}
     */
    clicked() {
        this.cardViewUpdateService.clicked(this.property);
    }
}
CardViewMapItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-mapitem',
                template: `
      <div class="adf-property-label">{{ property.label | translate }}</div>
      <div class="adf-property-value">
          <div>
              <span *ngIf="!isClickable(); else elseBlock" [attr.data-automation-id]="'card-mapitem-value-' + property.key">
                  <span *ngIf="!property.isEmpty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
              </span>
              <ng-template #elseBlock>
                  <span class="adf-mapitem-clickable-value" (click)="clicked()" [attr.data-automation-id]="'card-mapitem-value-' + property.key">
                      <span *ngIf="!property.isEmpty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
                  </span>
              </ng-template>
          </div>
          <ng-template #elseEmptyValueBlock>
              {{ property.default | translate }}
          </ng-template>
      </div>
    `,
                styles: [`
      .adf-mapitem-clickable-value {
        cursor: pointer; }
    `]
            },] },
];
/**
 * @nocollapse
 */
CardViewMapItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService, },
];
CardViewMapItemComponent.propDecorators = {
    'property': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewTextItemComponent {
    /**
     * @param {?} cardViewUpdateService
     */
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.inEdit = false;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.editedValue = this.property.value;
    }
    /**
     * @return {?}
     */
    isEditble() {
        return this.editable && this.property.editable;
    }
    /**
     * @return {?}
     */
    isClickable() {
        return this.property.clickable;
    }
    /**
     * @param {?} editStatus
     * @return {?}
     */
    setEditMode(editStatus) {
        this.inEdit = editStatus;
        setTimeout(() => {
            this.editorInput.nativeElement.click();
        }, 0);
    }
    /**
     * @return {?}
     */
    reset() {
        this.editedValue = this.property.value;
        this.setEditMode(false);
    }
    /**
     * @return {?}
     */
    update() {
        this.cardViewUpdateService.update(this.property, this.editedValue);
        this.property.value = this.editedValue;
        this.setEditMode(false);
    }
    /**
     * @return {?}
     */
    clicked() {
        this.cardViewUpdateService.clicked(this.property);
    }
}
CardViewTextItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-textitem',
                template: `
      <div class="adf-property-label">{{ property.label | translate }}</div>
      <div class="adf-property-value">
          <span *ngIf="!isEditble()">
              <span *ngIf="!isClickable(); else elseBlock" [attr.data-automation-id]="'card-textitem-value-' + property.key">
                  <span *ngIf="!property.isEmpty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
              </span>
              <ng-template #elseBlock>
                  <span class="adf-textitem-clickable-value" (click)="clicked()" [attr.data-automation-id]="'card-textitem-value-' + property.key">
                      <span *ngIf="!property.isEmpty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
                  </span>
              </ng-template>
          </span>
          <span *ngIf="isEditble()">
              <div *ngIf="!inEdit" (click)="setEditMode(true)" class="adf-textitem-readonly" [attr.data-automation-id]="'card-textitem-edit-toggle-' + property.key" fxLayout="row" fxLayoutAlign="space-between center">
                  <span [attr.data-automation-id]="'card-textitem-value-' + property.key">
                      <span *ngIf="!property.isEmpty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
                  </span>
                  <mat-icon fxFlex="0 0 auto" [attr.data-automation-id]="'card-textitem-edit-icon-' + property.key" class="adf-textitem-icon">create</mat-icon>
              </div>
              <div *ngIf="inEdit" class="adf-textitem-editable">
                  <mat-form-field floatPlaceholder="never" class="adf-input-container">
                      <input *ngIf="!property.multiline" #editorInput
                          matInput
                          class="adf-input"
                          [placeholder]="property.default | translate"
                          [(ngModel)]="editedValue"
                          [attr.data-automation-id]="'card-textitem-editinput-' + property.key">
                      <textarea *ngIf="property.multiline" #editorInput
                          matInput
                          matTextareaAutosize
                          matAutosizeMaxRows="1"
                          matAutosizeMaxRows="5"
                          class="adf-textarea"
                          [placeholder]="property.default | translate"
                          [(ngModel)]="editedValue"
                          [attr.data-automation-id]="'card-textitem-edittextarea-' + property.key"></textarea>
                  </mat-form-field>
                  <mat-icon
                      class="adf-textitem-icon adf-update-icon"
                      (click)="update()"
                      [attr.data-automation-id]="'card-textitem-update-' + property.key">done</mat-icon>
                  <mat-icon
                      class="adf-textitem-icon adf-reset-icon"
                      (click)="reset()"
                      [attr.data-automation-id]="'card-textitem-reset-' + property.key">clear</mat-icon>
              </div>
          </span>
          <ng-template #elseEmptyValueBlock>
              {{ property.default | translate }}
          </ng-template>
      </div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
CardViewTextItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService, },
];
CardViewTextItemComponent.propDecorators = {
    'property': [{ type: Input },],
    'editable': [{ type: Input },],
    'editorInput': [{ type: ViewChild, args: ['editorInput',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicComponentResolver {
    /**
     * @param {?} type
     * @return {?}
     */
    static fromType(type) {
        return (model) => {
            return type;
        };
    }
}
/**
 * @abstract
 */
class DynamicComponentMapper {
    constructor() {
        this.defaultValue = undefined;
        this.types = {};
    }
    /**
     * @param {?} type
     * @param {?=} defaultValue
     * @return {?}
     */
    getComponentTypeResolver(type, defaultValue = this.defaultValue) {
        if (type) {
            return this.types[type] || DynamicComponentResolver.fromType(defaultValue);
        }
        return DynamicComponentResolver.fromType(defaultValue);
    }
    /**
     * @param {?} type
     * @param {?} resolver
     * @param {?=} override
     * @return {?}
     */
    setComponentTypeResolver(type, resolver, override = false) {
        if (!type) {
            throw new Error(`type is null or not defined`);
        }
        if (!resolver) {
            throw new Error(`resolver is null or not defined`);
        }
        let /** @type {?} */ existing = this.types[type];
        if (existing && !override) {
            throw new Error(`already mapped, use override option if you intend replacing existing mapping.`);
        }
        this.types[type] = resolver;
    }
    /**
     * @param {?} model
     * @param {?=} defaultValue
     * @return {?}
     */
    resolveComponentType(model, defaultValue = this.defaultValue) {
        if (model) {
            let /** @type {?} */ resolver = this.getComponentTypeResolver(model.type, defaultValue);
            return resolver(model);
        }
        return defaultValue;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardItemTypeService extends DynamicComponentMapper {
    constructor() {
        super(...arguments);
        this.defaultValue = CardViewTextItemComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'date': DynamicComponentResolver.fromType(CardViewDateItemComponent),
            'map': DynamicComponentResolver.fromType(CardViewMapItemComponent)
        };
    }
}
CardItemTypeService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
CardItemTypeService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemDispatcherComponent {
    /**
     * @param {?} cardItemTypeService
     * @param {?} resolver
     */
    constructor(cardItemTypeService, resolver) {
        this.cardItemTypeService = cardItemTypeService;
        this.resolver = resolver;
        this.loaded = false;
        this.componentReference = null;
        const dynamicLifecycleMethods = [
            'ngOnInit',
            'ngDoCheck',
            'ngAfterContentInit',
            'ngAfterContentChecked',
            'ngAfterViewInit',
            'ngAfterViewChecked',
            'ngOnDestroy'
        ];
        dynamicLifecycleMethods.forEach((dynamicLifecycleMethod) => {
            this[dynamicLifecycleMethod] = this.proxy.bind(this, dynamicLifecycleMethod);
        });
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    ngOnChanges(...args) {
        if (!this.loaded) {
            this.loadComponent();
            this.loaded = true;
        }
        this.proxy('ngOnChanges', ...args);
    }
    /**
     * @return {?}
     */
    loadComponent() {
        const /** @type {?} */ factoryClass = this.cardItemTypeService.resolveComponentType(this.property);
        const /** @type {?} */ factory = this.resolver.resolveComponentFactory(factoryClass);
        this.componentReference = this.content.viewContainerRef.createComponent(factory);
        this.componentReference.instance.editable = this.editable;
        this.componentReference.instance.property = this.property;
    }
    /**
     * @param {?} methodName
     * @param {...?} args
     * @return {?}
     */
    proxy(methodName, ...args) {
        if (this.componentReference.instance[methodName]) {
            this.componentReference.instance[methodName].apply(this.componentReference.instance, args);
        }
    }
}
CardViewItemDispatcherComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-item-dispatcher',
                template: '<ng-template adf-card-view-content-proxy></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
CardViewItemDispatcherComponent.ctorParameters = () => [
    { type: CardItemTypeService, },
    { type: ComponentFactoryResolver, },
];
CardViewItemDispatcherComponent.propDecorators = {
    'property': [{ type: Input },],
    'editable': [{ type: Input },],
    'content': [{ type: ViewChild, args: [CardViewContentProxyDirective,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewComponent {
}
CardViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view',
                template: `
      <div class="adf-property-list">
          <div *ngFor="let property of properties">
              <div [attr.data-automation-id]="'header-'+property.key" class="adf-property">
                  <adf-card-view-item-dispatcher [property]="property" [editable]="editable"></adf-card-view-item-dispatcher>
              </div>
          </div>
      </div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
CardViewComponent.ctorParameters = () => [];
CardViewComponent.propDecorators = {
    'properties': [{ type: Input },],
    'editable': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewModule {
}
CardViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatInputModule,
                    MatIconModule,
                    MatButtonModule,
                    FormsModule,
                    FlexLayoutModule,
                    TranslateModule
                ],
                declarations: [
                    CardViewComponent,
                    CardViewItemDispatcherComponent,
                    CardViewContentProxyDirective,
                    CardViewTextItemComponent,
                    CardViewMapItemComponent,
                    CardViewDateItemComponent
                ],
                entryComponents: [
                    CardViewTextItemComponent,
                    CardViewMapItemComponent,
                    CardViewDateItemComponent
                ],
                exports: [
                    CardViewComponent,
                    CardViewTextItemComponent,
                    CardViewMapItemComponent,
                    CardViewDateItemComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
CardViewModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AccordionComponent {
    constructor() {
        this.groups = [];
    }
    /**
     * @param {?} group
     * @return {?}
     */
    addGroup(group) {
        this.groups.push(group);
    }
    /**
     * @param {?} openGroup
     * @return {?}
     */
    closeOthers(openGroup) {
        this.groups.forEach((group) => {
            if (group !== openGroup) {
                group.isOpen = false;
            }
        });
    }
    /**
     * @param {?} group
     * @return {?}
     */
    removeGroup(group) {
        const /** @type {?} */ index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(index, 1);
        }
    }
}
AccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-accordion',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    'class': 'panel-group'
                },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AccordionComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AccordionGroupComponent {
    /**
     * @param {?} accordion
     */
    constructor(accordion) {
        this.accordion = accordion;
        this._isOpen = false;
        this._isSelected = false;
        this.hasAccordionIcon = true;
        this.headingClick = new EventEmitter();
        this.accordion.addGroup(this);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
        if (value) {
            this.accordion.closeOthers(this);
        }
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isSelected(value) {
        this._isSelected = value;
    }
    /**
     * @return {?}
     */
    get isSelected() {
        return this._isSelected;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.accordion.removeGroup(this);
    }
    /**
     * @return {?}
     */
    hasHeadingIcon() {
        return this.headingIcon ? true : false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleOpen(event) {
        event.preventDefault();
        this.isOpen = !this.isOpen;
        this.headingClick.emit(this.heading);
    }
    /**
     * @return {?}
     */
    getAccordionIcon() {
        return this.isOpen ? 'expand_less' : 'expand_more';
    }
}
AccordionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-accordion-group',
                template: `
      <div class="adf-panel adf-panel-default" [ngClass]="{'adf-panel-open': isOpen}">
          <div class="adf-panel-heading" [ngClass]="{'adf-panel-heading-selected': isSelected}" (click)="toggleOpen($event)">
              <div id="heading-icon" *ngIf="hasHeadingIcon()" class="adf-panel-heading-icon">
                  <mat-icon class="material-icons"
                     [matTooltip]="headingIconTooltip"
                     [matTooltipDisabled]="!headingIconTooltip">
                      {{headingIcon}}
                  </mat-icon>
              </div>
              <div id="heading-text" class="adf-panel-heading-text">{{heading}}</div>
              <div id="accordion-button" *ngIf="hasAccordionIcon" class="adf-panel-heading-toggle">
                  <i class="material-icons">{{getAccordionIcon()}}</i>
              </div>
          </div>
          <div class="adf-panel-collapse" [hidden]="!isOpen">
              <div class="adf-panel-body" #contentWrapper>
                  <ng-content></ng-content>
              </div>
          </div>
      </div>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AccordionGroupComponent.ctorParameters = () => [
    { type: AccordionComponent, },
];
AccordionGroupComponent.propDecorators = {
    'contentWrapper': [{ type: ViewChild, args: ['contentWrapper',] },],
    'heading': [{ type: Input },],
    'headingIcon': [{ type: Input },],
    'headingIconTooltip': [{ type: Input },],
    'hasAccordionIcon': [{ type: Input },],
    'headingClick': [{ type: Output },],
    'isOpen': [{ type: Input },],
    'isSelected': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CollapsableModule {
}
CollapsableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MaterialModule,
                    CommonModule
                ],
                declarations: [
                    AccordionComponent,
                    AccordionGroupComponent
                ],
                exports: [
                    AccordionComponent,
                    AccordionGroupComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
CollapsableModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuService {
    constructor() {
        this.show = new Subject$1();
    }
}
ContextMenuService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ContextMenuService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuHolderComponent {
    /**
     * @param {?} viewport
     * @param {?} overlayContainer
     * @param {?} contextMenuService
     * @param {?} renderer
     */
    constructor(viewport, overlayContainer, contextMenuService, renderer) {
        this.viewport = viewport;
        this.overlayContainer = overlayContainer;
        this.contextMenuService = contextMenuService;
        this.renderer = renderer;
        this.links = [];
        this.mouseLocation = { left: 0, top: 0 };
        this.menuElement = null;
        this.showIcons = false;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onShowContextMenu(event) {
        if (event) {
            event.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        if (this.mdMenuElement) {
            this.setPositionAfterCDKrecalculation();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.contextSubscription = this.contextMenuService.show.subscribe(e => this.showMenu(e.event, e.obj));
        this.openSubscription = this.menuTrigger.onMenuOpen.subscribe(() => {
            const /** @type {?} */ container = this.overlayContainer.getContainerElement();
            if (container) {
                this.contextMenuListenerFn = this.renderer.listen(container, 'contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            this.menuElement = this.getContextMenuElement();
        });
        this.closeSubscription = this.menuTrigger.onMenuClose.subscribe(() => {
            this.menuElement = null;
            if (this.contextMenuListenerFn) {
                this.contextMenuListenerFn();
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.contextMenuListenerFn) {
            this.contextMenuListenerFn();
        }
        this.contextSubscription.unsubscribe();
        this.openSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
        this.menuElement = null;
    }
    /**
     * @param {?} event
     * @param {?} menuItem
     * @return {?}
     */
    onMenuItemClick(event, menuItem) {
        if (menuItem && menuItem.model && menuItem.model.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
        }
        menuItem.subject.next(menuItem);
    }
    /**
     * @param {?} e
     * @param {?} links
     * @return {?}
     */
    showMenu(e, links) {
        this.links = links;
        if (e) {
            this.mouseLocation = {
                left: e.clientX,
                top: e.clientY
            };
        }
        this.menuTrigger.openMenu();
        if (this.mdMenuElement) {
            this.setPositionAfterCDKrecalculation();
        }
    }
    /**
     * @return {?}
     */
    setPositionAfterCDKrecalculation() {
        setTimeout(() => {
            this.setPosition();
        }, 0);
    }
    /**
     * @return {?}
     */
    get mdMenuElement() {
        return this.menuElement;
    }
    /**
     * @return {?}
     */
    locationCss() {
        return {
            left: this.mouseLocation.left + 'px',
            top: this.mouseLocation.top + 'px'
        };
    }
    /**
     * @return {?}
     */
    setPosition() {
        if (this.mdMenuElement.clientWidth + this.mouseLocation.left > this.viewport.getViewportRect().width) {
            this.menuTrigger.menu.xPosition = 'before';
            this.mdMenuElement.parentElement.style.left = this.mouseLocation.left - this.mdMenuElement.clientWidth + 'px';
        }
        else {
            this.menuTrigger.menu.xPosition = 'after';
            this.mdMenuElement.parentElement.style.left = this.locationCss().left;
        }
        if (this.mdMenuElement.clientHeight + this.mouseLocation.top > this.viewport.getViewportRect().height) {
            this.menuTrigger.menu.yPosition = 'above';
            this.mdMenuElement.parentElement.style.top = this.mouseLocation.top - this.mdMenuElement.clientHeight + 'px';
        }
        else {
            this.menuTrigger.menu.yPosition = 'below';
            this.mdMenuElement.parentElement.style.top = this.locationCss().top;
        }
    }
    /**
     * @return {?}
     */
    getContextMenuElement() {
        return this.overlayContainer.getContainerElement().querySelector('.context-menu');
    }
}
ContextMenuHolderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-context-menu-holder, context-menu-holder',
                template: `
        <button mat-button [matMenuTriggerFor]="contextMenu"></button>
        <mat-menu #contextMenu="matMenu" class="context-menu">
            <button
                *ngFor="let link of links"
                mat-menu-item
                (click)="onMenuItemClick($event, link)"
                [attr.disabled]="link.model?.disabled || undefined">
                <mat-icon *ngIf="showIcons && link.model?.icon">
                    {{ link.model?.icon }}
                </mat-icon>
                    {{link.title || link.model?.title}}
            </button>
        </mat-menu>
    `
            },] },
];
/**
 * @nocollapse
 */
ContextMenuHolderComponent.ctorParameters = () => [
    { type: ViewportRuler, },
    { type: OverlayContainer, },
    { type: ContextMenuService, },
    { type: Renderer2, },
];
ContextMenuHolderComponent.propDecorators = {
    'showIcons': [{ type: Input },],
    'menuTrigger': [{ type: ViewChild, args: [MatMenuTrigger,] },],
    'onShowContextMenu': [{ type: HostListener, args: ['contextmenu', ['$event'],] },],
    'onResize': [{ type: HostListener, args: ['window:resize', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuDirective {
    /**
     * @param {?} _contextMenuService
     */
    constructor(_contextMenuService) {
        this._contextMenuService = _contextMenuService;
        this.enabled = false;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onShowContextMenu(event) {
        if (this.enabled) {
            if (event) {
                event.preventDefault();
            }
            if (this.links && this.links.length > 0) {
                if (this._contextMenuService) {
                    this._contextMenuService.show.next({ event: event, obj: this.links });
                }
            }
        }
    }
}
ContextMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-context-menu], [context-menu]'
            },] },
];
/**
 * @nocollapse
 */
ContextMenuDirective.ctorParameters = () => [
    { type: ContextMenuService, },
];
ContextMenuDirective.propDecorators = {
    'links': [{ type: Input, args: ['context-menu',] },],
    'enabled': [{ type: Input, args: ['context-menu-enabled',] },],
    'onShowContextMenu': [{ type: HostListener, args: ['contextmenu', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuModule {
}
ContextMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    ContextMenuHolderComponent,
                    ContextMenuDirective
                ],
                exports: [
                    ContextMenuHolderComponent,
                    ContextMenuDirective
                ],
                providers: [
                    ContextMenuService
                ]
            },] },
];
/**
 * @nocollapse
 */
ContextMenuModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DataColumnComponent {
    constructor() {
        this.type = 'text';
        this.sortable = true;
        this.title = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
}
DataColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-column',
                template: ''
            },] },
];
/**
 * @nocollapse
 */
DataColumnComponent.ctorParameters = () => [];
DataColumnComponent.propDecorators = {
    'key': [{ type: Input },],
    'type': [{ type: Input },],
    'format': [{ type: Input },],
    'sortable': [{ type: Input },],
    'title': [{ type: Input },],
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
    'formatTooltip': [{ type: Input },],
    'srTitle': [{ type: Input, args: ['sr-title',] },],
    'cssClass': [{ type: Input, args: ['class',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DataColumnListComponent {
}
DataColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-columns',
                template: ''
            },] },
];
/**
 * @nocollapse
 */
DataColumnListComponent.ctorParameters = () => [];
DataColumnListComponent.propDecorators = {
    'columns': [{ type: ContentChildren, args: [DataColumnComponent,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataColumnModule {
}
DataColumnModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    DataColumnComponent,
                    DataColumnListComponent
                ],
                exports: [
                    DataColumnComponent,
                    DataColumnListComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
DataColumnModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileSizePipe {
    /**
     * @param {?} bytes
     * @param {?=} decimals
     * @return {?}
     */
    transform(bytes, decimals = 2) {
        if (bytes == null || bytes === undefined) {
            return '';
        }
        if (bytes === 0) {
            return '0 Bytes';
        }
        const /** @type {?} */ k = 1024, /** @type {?} */ dm = decimals || 2, /** @type {?} */ sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], /** @type {?} */ i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
}
FileSizePipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfFileSize'
            },] },
];
/**
 * @nocollapse
 */
FileSizePipe.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CookieService {
    /**
     * Retrieve cookie by key.
     *
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        const /** @type {?} */ regexp = new RegExp('(?:' + key + '|;\s*' + key + ')=(.*?)(?:;|$)', 'g');
        const /** @type {?} */ result = regexp.exec(document.cookie);
        return (result === null) ? null : result[1];
    }
    /**
     * Set a cookie.
     * @param {?} key
     * @param {?} data
     * @param {?} expiration
     * @param {?} path
     *
     * @return {?}
     */
    setItem(key, data, expiration, path) {
        document.cookie = `${key}=${data}` +
            (expiration ? ';expires=' + expiration.toUTCString() : '') +
            (path ? `;path=${path}` : ';path=/');
    }
}
CookieService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
CookieService.ctorParameters = () => [];

class LogLevelsEnum extends Number {
}
LogLevelsEnum.TRACE = 5;
LogLevelsEnum.DEBUG = 4;
LogLevelsEnum.INFO = 3;
LogLevelsEnum.WARN = 2;
LogLevelsEnum.ERROR = 1;
LogLevelsEnum.SILENT = 0;
let logLevels = [
    { level: LogLevelsEnum.TRACE, name: 'TRACE' },
    { level: LogLevelsEnum.DEBUG, name: 'DEBUG' },
    { level: LogLevelsEnum.INFO, name: 'INFO' },
    { level: LogLevelsEnum.WARN, name: 'WARN' },
    { level: LogLevelsEnum.ERROR, name: 'ERROR' },
    { level: LogLevelsEnum.SILENT, name: 'SILENT' }
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogService {
    /**
     * @param {?} appConfig
     */
    constructor(appConfig) {
        this.currentLogLevel = LogLevelsEnum.TRACE;
        if (appConfig) {
            let configLevel = appConfig.get('logLevel');
            if (configLevel) {
                this.currentLogLevel = this.getCurrentLogLevel(configLevel);
            }
        }
    }
    /**
     * @return {?}
     */
    get error() {
        if (this.currentLogLevel >= LogLevelsEnum.ERROR) {
            return console.error.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get debug() {
        if (this.currentLogLevel >= LogLevelsEnum.DEBUG) {
            return console.debug.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get info() {
        if (this.currentLogLevel >= LogLevelsEnum.INFO) {
            return console.info.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get log() {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            return console.log.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get trace() {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            return console.trace.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get warn() {
        if (this.currentLogLevel >= LogLevelsEnum.WARN) {
            return console.warn.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get assert() {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            return console.assert.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get group() {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            return console.group.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @return {?}
     */
    get groupEnd() {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            return console.groupEnd.bind(console);
        }
        return (message, ...optionalParams) => {
        };
    }
    /**
     * @param {?} level
     * @return {?}
     */
    getCurrentLogLevel(level) {
        let /** @type {?} */ referencedLevel = logLevels.find((currentLevel) => {
            return currentLevel.name.toLocaleLowerCase() === level.toLocaleLowerCase();
        });
        return referencedLevel ? referencedLevel.level : 5;
    }
}
LogService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
LogService.ctorParameters = () => [
    { type: AppConfigService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const REMEMBER_ME_COOKIE_KEY = 'ALFRESCO_REMEMBER_ME';
const REMEMBER_ME_UNTIL = 1000 * 60 * 60 * 24 * 30;
class AuthenticationService {
    /**
     * @param {?} preferences
     * @param {?} alfrescoApi
     * @param {?} storage
     * @param {?} cookie
     * @param {?} logService
     */
    constructor(preferences, alfrescoApi$$1, storage, cookie, logService) {
        this.preferences = preferences;
        this.alfrescoApi = alfrescoApi$$1;
        this.storage = storage;
        this.cookie = cookie;
        this.logService = logService;
        this.redirectUrl = '';
        this.onLogin = new Subject$1();
        this.onLogout = new Subject$1();
    }
    /**
     * The method return true if the user is logged in
     * @return {?}
     */
    isLoggedIn() {
        return !!this.alfrescoApi.getInstance().isLoggedIn();
    }
    /**
     * Method to delegate to POST login
     * @param {?} username
     * @param {?} password
     * @param {?=} rememberMe
     * @return {?}
     */
    login(username, password, rememberMe = false) {
        this.removeTicket();
        return Observable$1.fromPromise(this.callApiLogin(username, password))
            .map((response) => {
            this.saveRememberMeCookie(rememberMe);
            this.saveTickets();
            this.onLogin.next(response);
            return {
                type: this.preferences.authType,
                ticket: response
            };
        })
            .catch(err => this.handleError(err));
    }
    /**
     * The method save the "remember me" cookie as a long life cookie or a session cookie
     * depending on the given paramter
     * @param {?} rememberMe
     * @return {?}
     */
    saveRememberMeCookie(rememberMe) {
        let /** @type {?} */ expiration = null;
        if (rememberMe) {
            expiration = new Date();
            const /** @type {?} */ time = expiration.getTime();
            const /** @type {?} */ expireTime = time + REMEMBER_ME_UNTIL;
            expiration.setTime(expireTime);
        }
        this.cookie.setItem(REMEMBER_ME_COOKIE_KEY, '1', expiration, null);
    }
    /**
     * The method retrieve whether the "remember me" cookie was set or not
     *
     * @return {?}
     */
    isRememberMeSet() {
        return (this.cookie.getItem(REMEMBER_ME_COOKIE_KEY) === null) ? false : true;
    }
    /**
     * Initialize the alfresco Api with user and password end call the login method
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    callApiLogin(username, password) {
        return this.alfrescoApi.getInstance().login(username, password);
    }
    /**
     * The method remove the ticket from the Storage
     *
     * @return {?}
     */
    logout() {
        return Observable$1.fromPromise(this.callApiLogout())
            .do(response => {
            this.removeTicket();
            this.onLogout.next(response);
            return response;
        })
            .catch(err => this.handleError(err));
    }
    /**
     *
     * @return {?}
     */
    callApiLogout() {
        if (this.alfrescoApi.getInstance()) {
            return this.alfrescoApi.getInstance().logout();
        }
    }
    /**
     * Remove the login ticket from Storage
     * @return {?}
     */
    removeTicket() {
        this.storage.removeItem('ticket-ECM');
        this.storage.removeItem('ticket-BPM');
        this.alfrescoApi.getInstance().setTicket(undefined, undefined);
    }
    /**
     * The method return the ECM ticket stored in the Storage
     * @return {?} ticket
     */
    getTicketEcm() {
        return this.storage.getItem('ticket-ECM');
    }
    /**
     * The method return the BPM ticket stored in the Storage
     * @return {?} ticket
     */
    getTicketBpm() {
        return this.storage.getItem('ticket-BPM');
    }
    /**
     * @return {?}
     */
    getTicketEcmBase64() {
        let /** @type {?} */ ticket = this.storage.getItem('ticket-ECM');
        if (ticket) {
            return 'Basic ' + btoa(ticket);
        }
        return null;
    }
    /**
     * The method save the ECM and BPM ticket in the Storage
     * @return {?}
     */
    saveTickets() {
        this.saveTicketEcm();
        this.saveTicketBpm();
    }
    /**
     * The method save the ECM ticket in the Storage
     * @return {?}
     */
    saveTicketEcm() {
        if (this.alfrescoApi.getInstance() && this.alfrescoApi.getInstance().getTicketEcm()) {
            this.storage.setItem('ticket-ECM', this.alfrescoApi.getInstance().getTicketEcm());
        }
    }
    /**
     * The method save the BPM ticket in the Storage
     * @return {?}
     */
    saveTicketBpm() {
        if (this.alfrescoApi.getInstance() && this.alfrescoApi.getInstance().getTicketBpm()) {
            this.storage.setItem('ticket-BPM', this.alfrescoApi.getInstance().getTicketBpm());
        }
    }
    /**
     * The method return true if user is logged in on ecm provider
     *
     * @return {?}
     */
    isEcmLoggedIn() {
        return this.isRememberMeSet() && this.alfrescoApi.getInstance().ecmAuth && !!this.alfrescoApi.getInstance().ecmAuth.isLoggedIn();
    }
    /**
     * The method return true if user is logged in on bpm provider
     *
     * @return {?}
     */
    isBpmLoggedIn() {
        return this.isRememberMeSet() && this.alfrescoApi.getInstance().bpmAuth && !!this.alfrescoApi.getInstance().bpmAuth.isLoggedIn();
    }
    /**
     * Get the ECM username
     *
     *
     * \@memberof AuthenticationService
     * @return {?}
     */
    getEcmUsername() {
        return this.alfrescoApi.getInstance().ecmAuth.username;
    }
    /**
     * Get the BPM username
     *
     *
     * \@memberof AuthenticationService
     * @return {?}
     */
    getBpmUsername() {
        return this.alfrescoApi.getInstance().bpmAuth.username;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    setRedirectUrl(url) {
        this.redirectUrl = url;
    }
    /**
     * @return {?}
     */
    getRedirectUrl() {
        return this.redirectUrl;
    }
    /**
     * The method write the error in the console browser
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error('Error when logging in', error);
        return Observable$1.throw(error || 'Server error');
    }
}
AuthenticationService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AuthenticationService.ctorParameters = () => [
    { type: UserPreferencesService, },
    { type: AlfrescoApiService, },
    { type: StorageService, },
    { type: CookieService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentService {
    /**
     * @param {?} authService
     * @param {?} apiService
     * @param {?} logService
     * @param {?} sanitizer
     */
    constructor(authService, apiService, logService, sanitizer) {
        this.authService = authService;
        this.apiService = apiService;
        this.logService = logService;
        this.sanitizer = sanitizer;
        this.folderCreated = new Subject$1();
        this.folderCreate = new Subject$1();
        this.folderEdit = new Subject$1();
        this.saveData = (function () {
            let a = document.createElement('a');
            document.body.appendChild(a);
            a.style.display = 'none';
            return function (data, format, fileName) {
                let blob = null;
                if (format === 'blob' || format === 'data') {
                    blob = new Blob([data], { type: 'octet/stream' });
                }
                if (format === 'object' || format === 'json') {
                    let json = JSON.stringify(data);
                    blob = new Blob([json], { type: 'octet/stream' });
                }
                if (blob) {
                    if (typeof window.navigator !== 'undefined' && window.navigator.msSaveOrOpenBlob) {
                        navigator.msSaveOrOpenBlob(blob, fileName);
                    }
                    else {
                        let url = window.URL.createObjectURL(blob);
                        a.href = url;
                        a.download = fileName;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                }
            };
        }());
    }
    /**
     * Invokes content download for a Blob with a file name.
     *
     *
     * \@memberOf ContentService
     * @param {?} blob
     * @param {?} fileName
     * @return {?}
     */
    downloadBlob(blob, fileName) {
        this.saveData(blob, 'blob', fileName);
    }
    /**
     * Invokes content download for a data array with a file name.
     *
     *
     * \@memberOf ContentService
     * @param {?} data
     * @param {?} fileName
     * @return {?}
     */
    downloadData(data, fileName) {
        this.saveData(data, 'data', fileName);
    }
    /**
     * Invokes content download for a JSON object with a file name.
     *
     *
     * \@memberOf ContentService
     * @param {?} json
     * @param {?} fileName
     * @return {?}
     */
    downloadJSON(json, fileName) {
        this.saveData(json, 'json', fileName);
    }
    /**
     * Creates a trusted object URL from the Blob.
     * WARNING: calling this method with untrusted user data exposes your application to XSS security risks!
     *
     * \@memberOf ContentService
     * @param {?} blob
     * @return {?}
     */
    createTrustedUrl(blob) {
        let /** @type {?} */ url = window.URL.createObjectURL(blob);
        return /** @type {?} */ (this.sanitizer.bypassSecurityTrustUrl(url));
    }
    /**
     * @return {?}
     */
    get contentApi() {
        return this.apiService.getInstance().content;
    }
    /**
     * Get thumbnail URL for the given document node.
     *
     * @param {?} nodeId
     * @param {?=} attachment
     * @param {?=} ticket
     * @return {?}
     */
    getDocumentThumbnailUrl(nodeId, attachment, ticket) {
        if (nodeId && nodeId.entry) {
            nodeId = nodeId.entry.id;
        }
        return this.contentApi.getDocumentThumbnailUrl(nodeId, attachment, ticket);
    }
    /**
     * Get content URL for the given node.
     *
     * @param {?} nodeId {string|MinimalNodeEntity} Node to get URL for.
     * @param {?=} attachment
     * @param {?=} ticket
     * @return {?}
     */
    getContentUrl(nodeId, attachment, ticket) {
        if (nodeId && nodeId.entry) {
            nodeId = nodeId.entry.id;
        }
        return this.contentApi.getContentUrl(nodeId, attachment, ticket);
    }
    /**
     * Get content for the given node.
     * @param {?} nodeId {string}.
     *
     * @return {?}
     */
    getNodeContent(nodeId) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.nodesApi.getFileContent(nodeId).then((dataContent) => {
            return dataContent;
        })).catch(this.handleError);
    }
    /**
     * Create a folder
     * @param {?} relativePath
     * @param {?} name - the folder name
     * @param {?=} parentId
     * @return {?}
     */
    createFolder(relativePath, name, parentId) {
        return Observable$1.fromPromise(this.apiService.getInstance().nodes.createFolder(name, relativePath, parentId))
            .do(data => {
            this.folderCreated.next(/** @type {?} */ ({
                relativePath: relativePath,
                name: name,
                parentId: parentId,
                node: data
            }));
        })
            .catch(err => this.handleError(err));
    }
    /**
     * Check if the user has permissions on that node
     * @param {?} node
     * @param {?} permission
     * @return {?}
     */
    hasPermission(node, permission) {
        let /** @type {?} */ hasPermission = false;
        if (this.hasAllowableOperations(node)) {
            if (permission && permission.startsWith('!')) {
                hasPermission = node.allowableOperations.find(currentPermission => currentPermission === permission.replace('!', '')) ? false : true;
            }
            else {
                hasPermission = node.allowableOperations.find(currentPermission => currentPermission === permission) ? true : false;
            }
        }
        else {
            if (permission && permission.startsWith('!')) {
                hasPermission = true;
            }
        }
        return hasPermission;
    }
    /**
     * Check if the node has the properties allowableOperations
     * @param {?} node
     * @return {?}
     */
    hasAllowableOperations(node) {
        return node && node.allowableOperations ? true : false;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
ContentService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ContentService.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: AlfrescoApiService, },
    { type: LogService, },
    { type: DomSanitizer, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ThumbnailService {
    /**
     * @param {?} contentService
     * @param {?} matIconRegistry
     * @param {?} sanitizer
     */
    constructor(contentService, matIconRegistry, sanitizer) {
        this.contentService = contentService;
        this.DEFAULT_ICON = './assets/images/ft_ic_miscellaneous.svg';
        this.mimeTypeIcons = {
            'image/png': './assets/images/ft_ic_raster_image.svg',
            'image/jpeg': './assets/images/ft_ic_raster_image.svg',
            'image/gif': './assets/images/ft_ic_raster_image.svg',
            'application/pdf': './assets/images/ft_ic_pdf.svg',
            'application/vnd.ms-excel': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.template': './assets/images/ft_ic_ms_excel.svg',
            'application/msword': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.template': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-powerpoint': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.slideshow': './assets/images/ft_ic_ms_powerpoint.svg',
            'video/mp4': './assets/images/ft_ic_video.svg',
            'text/plain': './assets/images/ft_ic_document.svg',
            'application/x-javascript': './assets/images/ft_ic_document.svg',
            'application/json': './assets/images/ft_ic_document.svg',
            'image/svg+xml': './assets/images/ft_ic_vector_image.svg',
            'text/html': './assets/images/ft_ic_website.svg',
            'application/x-compressed': './assets/images/ft_ic_archive.svg',
            'application/x-zip-compressed': './assets/images/ft_ic_archive.svg',
            'application/zip': './assets/images/ft_ic_archive.svg',
            'application/vnd.apple.keynote': './assets/images/ft_ic_presentation.svg',
            'application/vnd.apple.pages': './assets/images/ft_ic_document.svg',
            'application/vnd.apple.numbers': './assets/images/ft_ic_spreadsheet.svg',
            'folder': './assets/images/ft_ic_folder.svg',
            'disable/folder': './assets/images/ft_ic_folder_disable.svg',
            'selected': './assets/images/ft_ic_selected.svg'
        };
        matIconRegistry.addSvgIcon('image/png', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_raster_image.svg'));
        matIconRegistry.addSvgIcon('image/jpeg', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_raster_image.svg'));
        matIconRegistry.addSvgIcon('image/gif', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_raster_image.svg'));
        matIconRegistry.addSvgIcon('application/pdf', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_pdf.svg'));
        matIconRegistry.addSvgIcon('application/vnd.ms-excel', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_excel.svg'));
        matIconRegistry.addSvgIcon('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_excel.svg'));
        matIconRegistry.addSvgIcon('application/vnd.openxmlformats-officedocument.spreadsheetml.template', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_excel.svg'));
        matIconRegistry.addSvgIcon('application/msword', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_word.svg'));
        matIconRegistry.addSvgIcon('application/vnd.openxmlformats-officedocument.wordprocessingml.document', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_word.svg'));
        matIconRegistry.addSvgIcon('application/vnd.openxmlformats-officedocument.wordprocessingml.template', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_word.svg'));
        matIconRegistry.addSvgIcon('application/vnd.ms-powerpoint', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_powerpoint.svg'));
        matIconRegistry.addSvgIcon('application/vnd.openxmlformats-officedocument.presentationml.presentation', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_powerpoint.svg'));
        matIconRegistry.addSvgIcon('application/vnd.openxmlformats-officedocument.presentationml.template', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_powerpoint.svg'));
        matIconRegistry.addSvgIcon('application/vnd.openxmlformats-officedocument.presentationml.slideshow', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_ms_powerpoint.svg'));
        matIconRegistry.addSvgIcon('video/mp4', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_video.svg'));
        matIconRegistry.addSvgIcon('text/plain', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_document.svg'));
        matIconRegistry.addSvgIcon('application/x-javascript', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_document.svg'));
        matIconRegistry.addSvgIcon('application/json', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_document.svg'));
        matIconRegistry.addSvgIcon('image/svg+xml', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_vector_image.svg'));
        matIconRegistry.addSvgIcon('text/html', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_website.svg'));
        matIconRegistry.addSvgIcon('application/x-compressed', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_archive.svg'));
        matIconRegistry.addSvgIcon('application/x-zip-compressed', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_archive.svg'));
        matIconRegistry.addSvgIcon('application/zip', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_archive.svg'));
        matIconRegistry.addSvgIcon('application/vnd.apple.keynote', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_presentation.svg'));
        matIconRegistry.addSvgIcon('application/vnd.apple.pages', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_document.svg'));
        matIconRegistry.addSvgIcon('application/vnd.apple.numbers', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_spreadsheet.svg'));
        matIconRegistry.addSvgIcon('folder', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_folder.svg'));
        matIconRegistry.addSvgIcon('disable/folder', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_folder_disable.svg'));
        matIconRegistry.addSvgIcon('selected', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_selected.svg'));
        matIconRegistry.addSvgIcon('default', sanitizer.bypassSecurityTrustResourceUrl('./assets/images/ft_ic_miscellaneous.svg'));
    }
    /**
     * Get thumbnail URL for the given document node.
     * @param {?} document Node to get URL for.
     * @return {?}
     */
    getDocumentThumbnailUrl(document) {
        let /** @type {?} */ thumbnail = this.contentService.getDocumentThumbnailUrl(document);
        return thumbnail || this.DEFAULT_ICON;
    }
    /**
     * Get mimeType SVG
     * @param {?} mimeType
     * @return {?}
     */
    getMimeTypeIcon(mimeType) {
        let /** @type {?} */ icon = this.mimeTypeIcons[mimeType];
        return (icon || this.DEFAULT_ICON);
    }
    /**
     * Get default SVG
     * @return {?}
     */
    getDefaultMimeTypeIcon() {
        return this.DEFAULT_ICON;
    }
}
ThumbnailService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ThumbnailService.ctorParameters = () => [
    { type: ContentService, },
    { type: MatIconRegistry, },
    { type: DomSanitizer, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MimeTypeIconPipe {
    /**
     * @param {?} thumbnailService
     */
    constructor(thumbnailService) {
        this.thumbnailService = thumbnailService;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    transform(text) {
        return this.thumbnailService.getMimeTypeIcon(text);
    }
}
MimeTypeIconPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfMimeTypeIcon'
            },] },
];
/**
 * @nocollapse
 */
MimeTypeIconPipe.ctorParameters = () => [
    { type: ThumbnailService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeNameTooltipPipe {
    /**
     * @param {?} node
     * @return {?}
     */
    transform(node) {
        if (node) {
            return this.getNodeTooltip(node);
        }
        return null;
    }
    /**
     * @param {?} lines
     * @param {?} line
     * @return {?}
     */
    containsLine(lines, line) {
        return lines.some((item) => {
            return item.toLowerCase() === line.toLowerCase();
        });
    }
    /**
     * @param {?} lines
     * @return {?}
     */
    removeDuplicateLines(lines) {
        const /** @type {?} */ reducer = (acc, line) => {
            if (!this.containsLine(acc, line)) {
                acc.push(line);
            }
            return acc;
        };
        return lines.reduce(reducer, []);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNodeTooltip(node) {
        if (!node || !node.entry) {
            return null;
        }
        const { entry: { properties, name } } = node;
        const /** @type {?} */ lines = [name];
        if (properties) {
            const { 'cm:title': title, 'cm:description': description } = properties;
            if (title && description) {
                lines[0] = title;
                lines[1] = description;
            }
            if (title) {
                lines[1] = title;
            }
            if (description) {
                lines[1] = description;
            }
        }
        return this.removeDuplicateLines(lines).join(`\n`);
    }
}
NodeNameTooltipPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfNodeNameTooltip'
            },] },
];
/**
 * @nocollapse
 */
NodeNameTooltipPipe.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HighlightTransformService {
    /**
     * @param {?} text
     * @param {?} search
     * @param {?=} wrapperClass
     * @return {?}
     */
    highlight(text, search, wrapperClass = 'highlight') {
        let /** @type {?} */ isMatching = false, /** @type {?} */ result = text;
        if (search && text) {
            let /** @type {?} */ pattern = search.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            pattern = pattern.split(' ').filter((t) => {
                return t.length > 0;
            }).join('|');
            const /** @type {?} */ regex = new RegExp(pattern, 'gi');
            result = text.replace(regex, (match) => {
                isMatching = true;
                return `<span class="${wrapperClass}">${match}</span>`;
            });
            return { text: result, changed: isMatching };
        }
        else {
            return { text: result, changed: isMatching };
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HighlightPipe {
    /**
     * @param {?} highlightTransformService
     */
    constructor(highlightTransformService) {
        this.highlightTransformService = highlightTransformService;
    }
    /**
     * @param {?} text
     * @param {?} search
     * @return {?}
     */
    transform(text, search) {
        const /** @type {?} */ result = this.highlightTransformService.highlight(text, search);
        return result.text;
    }
}
HighlightPipe.decorators = [
    { type: Pipe, args: [{
                name: 'highlight'
            },] },
];
/**
 * @nocollapse
 */
HighlightPipe.ctorParameters = () => [
    { type: HighlightTransformService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TimeAgoPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        if (value !== null && value !== undefined) {
            const /** @type {?} */ then = moment(value);
            const /** @type {?} */ diff = moment().diff(then, 'days');
            return diff > 7 ? then.format('DD/MM/YYYY HH:mm') : then.fromNow();
        }
        return '';
    }
}
TimeAgoPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfTimeAgo'
            },] },
];
/**
 * @nocollapse
 */
TimeAgoPipe.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InitialUsernamePipe {
    /**
     * @param {?} sanitized
     */
    constructor(sanitized) {
        this.sanitized = sanitized;
    }
    /**
     * @param {?} user
     * @param {?=} className
     * @param {?=} delimiter
     * @return {?}
     */
    transform(user, className = '', delimiter = '') {
        let /** @type {?} */ result = '';
        if (user) {
            let /** @type {?} */ initialResult = this.getInitialUserName(user.firstName, user.lastName, delimiter);
            result = this.sanitized.bypassSecurityTrustHtml(`<div id="user-initials-image" class="${className}">${initialResult}</div>`);
        }
        return result;
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?} delimiter
     * @return {?}
     */
    getInitialUserName(firstName, lastName, delimiter) {
        firstName = (firstName ? firstName[0] : '');
        lastName = (lastName ? lastName[0] : '');
        return firstName + delimiter + lastName;
    }
}
InitialUsernamePipe.decorators = [
    { type: Pipe, args: [{
                name: 'usernameInitials'
            },] },
];
/**
 * @nocollapse
 */
InitialUsernamePipe.ctorParameters = () => [
    { type: DomSanitizer, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PipeModule {
}
PipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe
                ],
                providers: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe
                ],
                exports: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe
                ]
            },] },
];
/**
 * @nocollapse
 */
PipeModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HighlightDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} highlightTransformService
     */
    constructor(el, renderer, highlightTransformService) {
        this.el = el;
        this.renderer = renderer;
        this.highlightTransformService = highlightTransformService;
        this.selector = '';
        this.search = '';
        this.classToApply = 'adf-highlight';
    }
    /**
     * @param {?=} search
     * @param {?=} selector
     * @param {?=} classToApply
     * @return {?}
     */
    highlight(search = this.search, selector = this.selector, classToApply = this.classToApply) {
        if (search && selector) {
            const /** @type {?} */ elements = this.el.nativeElement.querySelectorAll(selector);
            elements.forEach((element) => {
                const /** @type {?} */ result = this.highlightTransformService.highlight(element.innerHTML, search, classToApply);
                if (result.changed) {
                    this.renderer.setElementProperty(element, 'innerHTML', result.text);
                }
            });
        }
    }
}
HighlightDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-highlight]'
            },] },
];
/**
 * @nocollapse
 */
HighlightDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
    { type: HighlightTransformService, },
];
HighlightDirective.propDecorators = {
    'selector': [{ type: Input, args: ['adf-highlight-selector',] },],
    'search': [{ type: Input, args: ['adf-highlight',] },],
    'classToApply': [{ type: Input, args: ['adf-highlight-class',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogoutDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} router
     * @param {?} auth
     */
    constructor(elementRef, renderer, router$$1, auth) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.router = router$$1;
        this.auth = auth;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.elementRef.nativeElement) {
            this.renderer.listen(this.elementRef.nativeElement, 'click', (evt) => {
                evt.preventDefault();
                this.logout();
            });
        }
    }
    /**
     * @return {?}
     */
    logout() {
        this.auth.logout().subscribe(() => this.redirectToLogin(), () => this.redirectToLogin());
    }
    /**
     * @return {?}
     */
    redirectToLogin() {
        this.router.navigate(['/login']);
    }
}
LogoutDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-logout]'
            },] },
];
/**
 * @nocollapse
 */
LogoutDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: Router, },
    { type: AuthenticationService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NotificationService {
    /**
     * @param {?} snackbar
     */
    constructor(snackbar) {
        this.snackbar = snackbar;
    }
    /**
     * @param {?} message
     * @param {?=} millisecondsDuration
     * @return {?}
     */
    openSnackMessage(message, millisecondsDuration) {
        return this.snackbar.open(message, null, {
            duration: millisecondsDuration || NotificationService.DEFAULT_DURATION_MESSAGE
        });
    }
    /**
     * @param {?} message
     * @param {?} action
     * @param {?=} millisecondsDuration
     * @return {?}
     */
    openSnackMessageAction(message, action, millisecondsDuration) {
        return this.snackbar.open(message, action, {
            duration: millisecondsDuration || NotificationService.DEFAULT_DURATION_MESSAGE
        });
    }
}
NotificationService.DEFAULT_DURATION_MESSAGE = 5000;
NotificationService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NotificationService.ctorParameters = () => [
    { type: MatSnackBar, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeDeleteDirective {
    /**
     * @param {?} notification
     * @param {?} alfrescoApiService
     * @param {?} translation
     * @param {?} elementRef
     */
    constructor(notification, alfrescoApiService, translation, elementRef) {
        this.notification = notification;
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        this.elementRef = elementRef;
        this.permanent = false;
        this.delete = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.process(this.selection);
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (!this.selection || (this.selection && this.selection.length === 0)) {
            this.setDisableAttribute(true);
        }
        else {
            if (!this.elementRef.nativeElement.hasAttribute('adf-node-permission')) {
                this.setDisableAttribute(false);
            }
        }
    }
    /**
     * @param {?} disable
     * @return {?}
     */
    setDisableAttribute(disable) {
        this.elementRef.nativeElement.disabled = disable;
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    process(selection) {
        if (!selection.length) {
            return;
        }
        const /** @type {?} */ batch = this.getDeleteNodesBatch(selection);
        Observable$1.forkJoin(...batch)
            .subscribe((data) => {
            const /** @type {?} */ processedItems = this.processStatus(data);
            this.notify(processedItems);
            if (processedItems.someSucceeded) {
                this.delete.emit();
            }
        });
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    getDeleteNodesBatch(selection) {
        return selection.map((node) => this.deleteNode(node));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    deleteNode(node) {
        const /** @type {?} */ id = ((node.entry)).nodeId || node.entry.id;
        const /** @type {?} */ promise = this.alfrescoApiService.getInstance().nodes.deleteNode(id, { permanent: this.permanent });
        return Observable$1.fromPromise(promise)
            .map(() => ({
            entry: node.entry,
            status: 1
        }))
            .catch((error) => {
            return Observable$1.of({
                entry: node.entry,
                status: 0
            });
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    processStatus(data) {
        const /** @type {?} */ deleteStatus = {
            success: [],
            failed: [],
            /**
             * @return {?}
             */
            get someFailed() {
                return !!(this.failed.length);
            },
            /**
             * @return {?}
             */
            get someSucceeded() {
                return !!(this.success.length);
            },
            /**
             * @return {?}
             */
            get oneFailed() {
                return this.failed.length === 1;
            },
            /**
             * @return {?}
             */
            get oneSucceeded() {
                return this.success.length === 1;
            },
            /**
             * @return {?}
             */
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            /**
             * @return {?}
             */
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            }
        };
        return data.reduce((acc, next) => {
            if (next.status === 1) {
                acc.success.push(next);
            }
            else {
                acc.failed.push(next);
            }
            return acc;
        }, deleteStatus);
    }
    /**
     * @param {?} status
     * @return {?}
     */
    notify(status) {
        this.getMessage(status).subscribe((message) => this.notification.openSnackMessage(message));
    }
    /**
     * @param {?} status
     * @return {?}
     */
    getMessage(status) {
        if (status.allFailed && !status.oneFailed) {
            return this.translation.get('CORE.DELETE_NODE.ERROR_PLURAL', { number: status.failed.length });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.get('CORE.DELETE_NODE.PLURAL', { number: status.success.length });
        }
        if (status.someFailed && status.someSucceeded && !status.oneSucceeded) {
            return this.translation.get('CORE.DELETE_NODE.PARTIAL_PLURAL', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.someFailed && status.oneSucceeded) {
            return this.translation.get('CORE.DELETE_NODE.PARTIAL_SINGULAR', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.oneFailed && !status.someSucceeded) {
            return this.translation.get('CORE.DELETE_NODE.ERROR_SINGULAR', { name: status.failed[0].entry.name });
        }
        if (status.oneSucceeded && !status.someFailed) {
            return this.translation.get('CORE.DELETE_NODE.SINGULAR', { name: status.success[0].entry.name });
        }
    }
}
NodeDeleteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-delete]'
            },] },
];
/**
 * @nocollapse
 */
NodeDeleteDirective.ctorParameters = () => [
    { type: NotificationService, },
    { type: AlfrescoApiService, },
    { type: TranslationService, },
    { type: ElementRef, },
];
NodeDeleteDirective.propDecorators = {
    'selection': [{ type: Input, args: ['adf-delete',] },],
    'permanent': [{ type: Input },],
    'delete': [{ type: Output },],
    'onClick': [{ type: HostListener, args: ['click',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeFavoriteDirective {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.favorites = [];
        this.selection = [];
        this.toggle = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.toggleFavorite();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!changes.selection.currentValue.length) {
            this.favorites = [];
            return;
        }
        this.markFavoritesNodes(changes.selection.currentValue);
    }
    /**
     * @return {?}
     */
    toggleFavorite() {
        if (!this.favorites.length) {
            return;
        }
        const /** @type {?} */ every = this.favorites.every((selected) => selected.entry.isFavorite);
        if (every) {
            const /** @type {?} */ batch = this.favorites.map((selected) => {
                // shared files have nodeId
                const /** @type {?} */ id = selected.entry.nodeId || selected.entry.id;
                return Observable$1.fromPromise(this.alfrescoApiService.getInstance().core.favoritesApi.removeFavoriteSite('-me-', id));
            });
            Observable$1.forkJoin(batch).subscribe(() => {
                this.favorites.map(selected => selected.entry.isFavorite = false);
                this.toggle.emit();
            });
        }
        if (!every) {
            const /** @type {?} */ notFavorite = this.favorites.filter((node) => !node.entry.isFavorite);
            const /** @type {?} */ body = notFavorite.map((node) => this.createFavoriteBody(node));
            Observable$1.fromPromise(this.alfrescoApiService.getInstance().core.favoritesApi.addFavorite('-me-', /** @type {?} */ (body)))
                .subscribe(() => {
                notFavorite.map(selected => selected.entry.isFavorite = true);
                this.toggle.emit();
            });
        }
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    markFavoritesNodes(selection) {
        if (selection.length <= this.favorites.length) {
            const /** @type {?} */ newFavorites = this.reduce(this.favorites, selection);
            this.favorites = newFavorites;
        }
        const /** @type {?} */ result = this.diff(selection, this.favorites);
        const /** @type {?} */ batch = this.getProcessBatch(result);
        Observable$1.forkJoin(batch).subscribe((data) => this.favorites.push(...data));
    }
    /**
     * @return {?}
     */
    hasFavorites() {
        if (this.favorites && !this.favorites.length) {
            return false;
        }
        return this.favorites.every((selected) => selected.entry.isFavorite);
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    getProcessBatch(selection) {
        return selection.map((selected) => this.getFavorite(selected));
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    getFavorite(selected) {
        const { name, isFile, isFolder } = selected.entry;
        // shared files have nodeId
        const /** @type {?} */ id = ((selected)).entry.nodeId || selected.entry.id;
        const /** @type {?} */ promise = this.alfrescoApiService.getInstance()
            .core.favoritesApi.getFavorite('-me-', id);
        return Observable$1.from(promise)
            .map(() => ({
            entry: {
                id,
                isFolder,
                isFile,
                name,
                isFavorite: true
            }
        }))
            .catch(() => {
            return Observable$1.of({
                entry: {
                    id,
                    isFolder,
                    isFile,
                    name,
                    isFavorite: false
                }
            });
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    createFavoriteBody(node) {
        const /** @type {?} */ type = this.getNodeType(node);
        // shared files have nodeId
        const /** @type {?} */ id = node.entry.nodeId || node.entry.id;
        return {
            target: {
                [type]: {
                    guid: id
                }
            }
        };
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNodeType(node) {
        // shared could only be files
        if (!node.entry.isFile && !node.entry.isFolder) {
            return 'file';
        }
        return node.entry.isFile ? 'file' : 'folder';
    }
    /**
     * @param {?} list
     * @param {?} patch
     * @return {?}
     */
    diff(list, patch) {
        const /** @type {?} */ ids = patch.map(item => item.entry.id);
        return list.filter(item => ids.includes(item.entry.id) ? null : item);
    }
    /**
     * @param {?} patch
     * @param {?} comparator
     * @return {?}
     */
    reduce(patch, comparator) {
        const /** @type {?} */ ids = comparator.map(item => item.entry.id);
        return patch.filter(item => ids.includes(item.entry.id) ? item : null);
    }
}
NodeFavoriteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-favorite]',
                exportAs: 'adfFavorite'
            },] },
];
/**
 * @nocollapse
 */
NodeFavoriteDirective.ctorParameters = () => [
    { type: AlfrescoApiService, },
];
NodeFavoriteDirective.propDecorators = {
    'selection': [{ type: Input, args: ['adf-node-favorite',] },],
    'toggle': [{ type: Output },],
    'onClick': [{ type: HostListener, args: ['click',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EXTENDIBLE_COMPONENT = new InjectionToken('extendible.component');

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodePermissionDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} contentService
     * @param {?} changeDetector
     * @param {?=} parentComponent
     */
    constructor(elementRef, renderer, contentService, changeDetector, parentComponent) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.contentService = contentService;
        this.changeDetector = changeDetector;
        this.parentComponent = parentComponent;
        this.permission = null;
        this.nodes = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.nodes && !changes.nodes.firstChange) {
            this.updateElement();
        }
    }
    /**
     * Updates disabled state for the decorated elememtn
     *
     * \@memberof NodePermissionDirective
     * @return {?}
     */
    updateElement() {
        let /** @type {?} */ enable = this.hasPermission(this.nodes, this.permission);
        if (enable) {
            this.enable();
        }
        else {
            this.disable();
        }
        return enable;
    }
    /**
     * @return {?}
     */
    enable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = false;
            this.changeDetector.detectChanges();
        }
        else {
            this.enableElement();
        }
    }
    /**
     * @return {?}
     */
    disable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = true;
            this.changeDetector.detectChanges();
        }
        else {
            this.disableElement();
        }
    }
    /**
     * Enables decorated element
     *
     * \@memberof NodePermissionDirective
     * @return {?}
     */
    enableElement() {
        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
    }
    /**
     * Disables decorated element
     *
     * \@memberof NodePermissionDirective
     * @return {?}
     */
    disableElement() {
        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true');
    }
    /**
     * Checks whether all nodes have a particular permission
     *
     * \@memberof NodePermissionDirective
     * @param {?} nodes
     * @param {?} permission
     * @return {?}
     */
    hasPermission(nodes, permission) {
        if (nodes && nodes.length > 0) {
            return nodes.every(node => this.contentService.hasPermission(node.entry, permission));
        }
        return false;
    }
}
NodePermissionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-permission]'
            },] },
];
/**
 * @nocollapse
 */
NodePermissionDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ContentService, },
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Host }, { type: Optional }, { type: Inject, args: [EXTENDIBLE_COMPONENT,] },] },
];
NodePermissionDirective.propDecorators = {
    'permission': [{ type: Input, args: ['adf-node-permission',] },],
    'nodes': [{ type: Input, args: ['adf-nodes',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeRestoreDirective {
    /**
     * @param {?} alfrescoApiService
     * @param {?} translation
     * @param {?} router
     * @param {?} notification
     */
    constructor(alfrescoApiService, translation, router$$1, notification) {
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        this.router = router$$1;
        this.notification = notification;
        this.location = '';
        this.restore = new EventEmitter();
        this.restoreProcessStatus = this.processStatus();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.recover(this.selection);
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    recover(selection) {
        if (!selection.length) {
            return;
        }
        const /** @type {?} */ nodesWithPath = this.getNodesWithPath(selection);
        if (selection.length && !nodesWithPath.length) {
            this.restoreProcessStatus.fail.push(...selection);
            this.restoreNotification();
            this.refresh();
            return;
        }
        this.restoreNodesBatch(nodesWithPath)
            .do((restoredNodes) => {
            const /** @type {?} */ status = this.processStatus(restoredNodes);
            this.restoreProcessStatus.fail.push(...status.fail);
            this.restoreProcessStatus.success.push(...status.success);
        })
            .mergeMap(() => this.getDeletedNodes())
            .subscribe((deletedNodesList) => {
            const { entries: nodelist } = deletedNodesList.list;
            const { fail: restoreErrorNodes } = this.restoreProcessStatus;
            const /** @type {?} */ selectedNodes = this.diff(restoreErrorNodes, selection, false);
            const /** @type {?} */ remainingNodes = this.diff(selectedNodes, nodelist);
            if (!remainingNodes.length) {
                this.restoreNotification();
                this.refresh();
            }
            else {
                this.recover(remainingNodes);
            }
        });
    }
    /**
     * @param {?} batch
     * @return {?}
     */
    restoreNodesBatch(batch) {
        return Observable$1.forkJoin(batch.map((node) => this.restoreNode(node)));
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    getNodesWithPath(selection) {
        return selection.filter((node) => node.entry.path);
    }
    /**
     * @return {?}
     */
    getDeletedNodes() {
        const /** @type {?} */ promise = this.alfrescoApiService.getInstance()
            .core.nodesApi.getDeletedNodes({ include: ['path'] });
        return Observable$1.from(promise);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    restoreNode(node) {
        const { entry } = node;
        const /** @type {?} */ promise = this.alfrescoApiService.getInstance().nodes.restoreNode(entry.id);
        return Observable$1.from(promise)
            .map(() => ({
            status: 1,
            entry
        }))
            .catch((error) => {
            const { statusCode } = (JSON.parse(error.message)).error;
            return Observable$1.of({
                status: 0,
                statusCode,
                entry
            });
        });
    }
    /**
     * @param {?} path
     * @return {?}
     */
    navigateLocation(path) {
        const /** @type {?} */ parent = path.elements[path.elements.length - 1];
        this.router.navigate([this.location, parent.id]);
    }
    /**
     * @param {?} selection
     * @param {?} list
     * @param {?=} fromList
     * @return {?}
     */
    diff(selection, list, fromList = true) {
        const /** @type {?} */ ids = selection.map(item => item.entry.id);
        return list.filter(item => {
            if (fromList) {
                return ids.includes(item.entry.id) ? item : null;
            }
            else {
                return !ids.includes(item.entry.id) ? item : null;
            }
        });
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    processStatus(data = []) {
        const /** @type {?} */ status = {
            fail: [],
            success: [],
            /**
             * @return {?}
             */
            get someFailed() {
                return !!(this.fail.length);
            },
            /**
             * @return {?}
             */
            get someSucceeded() {
                return !!(this.success.length);
            },
            /**
             * @return {?}
             */
            get oneFailed() {
                return this.fail.length === 1;
            },
            /**
             * @return {?}
             */
            get oneSucceeded() {
                return this.success.length === 1;
            },
            /**
             * @return {?}
             */
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            /**
             * @return {?}
             */
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            },
            /**
             * @return {?}
             */
            reset() {
                this.fail = [];
                this.success = [];
            }
        };
        return data.reduce((acc, node) => {
            if (node.status) {
                acc.success.push(node);
            }
            else {
                acc.fail.push(node);
            }
            return acc;
        }, status);
    }
    /**
     * @return {?}
     */
    getRestoreMessage() {
        const { restoreProcessStatus: status } = this;
        if (status.someFailed && !status.oneFailed) {
            return this.translation.get('CORE.RESTORE_NODE.PARTIAL_PLURAL', {
                number: status.fail.length
            });
        }
        if (status.oneFailed && status.fail[0].statusCode) {
            if (status.fail[0].statusCode === 409) {
                return this.translation.get('CORE.RESTORE_NODE.NODE_EXISTS', {
                    name: status.fail[0].entry.name
                });
            }
            else {
                return this.translation.get('CORE.RESTORE_NODE.GENERIC', {
                    name: status.fail[0].entry.name
                });
            }
        }
        if (status.oneFailed && !status.fail[0].statusCode) {
            return this.translation.get('CORE.RESTORE_NODE.LOCATION_MISSING', {
                name: status.fail[0].entry.name
            });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.get('CORE.RESTORE_NODE.PLURAL');
        }
        if (status.allSucceeded && status.oneSucceeded) {
            return this.translation.get('CORE.RESTORE_NODE.SINGULAR', {
                name: status.success[0].entry.name
            });
        }
    }
    /**
     * @return {?}
     */
    restoreNotification() {
        const /** @type {?} */ status = Object.assign({}, this.restoreProcessStatus);
        Observable$1.zip(this.getRestoreMessage(), this.translation.get('CORE.RESTORE_NODE.VIEW')).subscribe((messages) => {
            const [message, actionLabel] = messages;
            const /** @type {?} */ action = (status.oneSucceeded && !status.someFailed) ? actionLabel : '';
            this.notification.openSnackMessageAction(message, action)
                .onAction()
                .subscribe(() => this.navigateLocation(status.success[0].entry.path));
        });
    }
    /**
     * @return {?}
     */
    refresh() {
        this.restoreProcessStatus.reset();
        this.selection = [];
        this.restore.emit();
    }
}
NodeRestoreDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-restore]'
            },] },
];
/**
 * @nocollapse
 */
NodeRestoreDirective.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: TranslationService, },
    { type: Router, },
    { type: NotificationService, },
];
NodeRestoreDirective.propDecorators = {
    'selection': [{ type: Input, args: ['adf-restore',] },],
    'location': [{ type: Input },],
    'restore': [{ type: Output },],
    'onClick': [{ type: HostListener, args: ['click',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUtils {
    /**
     * @param {?} folder
     * @return {?}
     */
    static flattern(folder) {
        let /** @type {?} */ reader = folder.createReader();
        let /** @type {?} */ files = [];
        return new Promise(resolve => {
            let /** @type {?} */ iterations = [];
            (function traverse() {
                reader.readEntries((entries) => {
                    if (!entries.length) {
                        Promise.all(iterations).then(result => resolve(files));
                    }
                    else {
                        iterations.push(Promise.all(entries.map(entry => {
                            if (entry.isFile) {
                                return new Promise(resolveFile => {
                                    entry.file(function (f) {
                                        files.push({
                                            entry: entry,
                                            file: f,
                                            relativeFolder: entry.fullPath.replace(/\/[^\/]*$/, '')
                                        });
                                        resolveFile();
                                    });
                                });
                            }
                            else {
                                return FileUtils.flattern(entry).then(result => {
                                    files.push(...result);
                                });
                            }
                        })));
                        // Try calling traverse() again for the same dir, according to spec
                        traverse();
                    }
                });
            })();
        });
    }
    /**
     * @param {?} fileList
     * @return {?}
     */
    static toFileArray(fileList) {
        let /** @type {?} */ result = [];
        if (fileList && fileList.length > 0) {
            for (let /** @type {?} */ i = 0; i < fileList.length; i++) {
                result.push(fileList[i]);
            }
        }
        return result;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(el, renderer, ngZone) {
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.enabled = true;
        this.mode = ['drop']; // click|drop
        this.isDragging = false;
        this.cssClassName = 'adf-upload__dragging';
        this.element = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isClickMode() && this.renderer) {
            this.upload = /** @type {?} */ (this.renderer.createElement(this.el.nativeElement.parentNode, 'input'));
            this.upload.type = 'file';
            this.upload.style.display = 'none';
            this.upload.addEventListener('change', e => this.onSelectFiles(e));
            if (this.multiple) {
                this.upload.setAttribute('multiple', '');
            }
            if (this.accept) {
                this.upload.setAttribute('accept', this.accept);
            }
            if (this.directory) {
                this.upload.setAttribute('webkitdirectory', '');
            }
        }
        if (this.isDropMode()) {
            this.ngZone.runOutsideAngular(() => {
                this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
                this.element.addEventListener('dragover', this.onDragOver.bind(this));
                this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
                this.element.addEventListener('drop', this.onDrop.bind(this));
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDrop);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.isClickMode() && this.upload) {
            event.preventDefault();
            this.upload.click();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        if (this.isDropMode()) {
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        event.preventDefault();
        if (this.isDropMode()) {
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        if (this.isDropMode()) {
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDrop(event) {
        if (this.isDropMode()) {
            event.stopPropagation();
            event.preventDefault();
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
            const /** @type {?} */ dataTranfer = this.getDataTransfer(event);
            if (dataTranfer) {
                this.getFilesDropped(dataTranfer).then(files => {
                    this.onUploadFiles(files);
                });
            }
        }
        return false;
    }
    /**
     * @param {?} files
     * @return {?}
     */
    onUploadFiles(files) {
        if (this.enabled && files.length > 0) {
            let /** @type {?} */ e = new CustomEvent('upload-files', {
                detail: {
                    sender: this,
                    data: this.data,
                    files: files
                },
                bubbles: true
            });
            this.el.nativeElement.dispatchEvent(e);
        }
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    hasMode(mode) {
        return this.enabled && mode && this.mode && this.mode.indexOf(mode) > -1;
    }
    /**
     * @return {?}
     */
    isDropMode() {
        return this.hasMode('drop');
    }
    /**
     * @return {?}
     */
    isClickMode() {
        return this.hasMode('click');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getDataTransfer(event) {
        if (event && event.dataTransfer) {
            return event.dataTransfer;
        }
        if (event && event.originalEvent && event.originalEvent.dataTransfer) {
            return event.originalEvent.dataTransfer;
        }
        return null;
    }
    /**
     * Extract files from the DataTransfer object used to hold the data that is being dragged during a drag and drop operation.
     * @param {?} dataTransfer DataTransfer object
     * @return {?}
     */
    getFilesDropped(dataTransfer) {
        return new Promise(resolve => {
            const /** @type {?} */ iterations = [];
            if (dataTransfer) {
                const /** @type {?} */ items = dataTransfer.items;
                if (items) {
                    for (let /** @type {?} */ i = 0; i < items.length; i++) {
                        if (typeof items[i].webkitGetAsEntry !== 'undefined') {
                            let /** @type {?} */ item = items[i].webkitGetAsEntry();
                            if (item) {
                                if (item.isFile) {
                                    iterations.push(Promise.resolve(/** @type {?} */ ({
                                        entry: item,
                                        file: items[i].getAsFile(),
                                        relativeFolder: '/'
                                    })));
                                }
                                else if (item.isDirectory) {
                                    iterations.push(new Promise(resolveFolder => {
                                        FileUtils.flattern(item).then(files => resolveFolder(files));
                                    }));
                                }
                            }
                        }
                        else {
                            iterations.push(Promise.resolve(/** @type {?} */ ({
                                entry: null,
                                file: items[i].getAsFile(),
                                relativeFolder: '/'
                            })));
                        }
                    }
                }
                else {
                    // safari or FF
                    let /** @type {?} */ files = FileUtils
                        .toFileArray(dataTransfer.files)
                        .map(file => /** @type {?} */ ({
                        entry: null,
                        file: file,
                        relativeFolder: '/'
                    }));
                    iterations.push(Promise.resolve(files));
                }
            }
            Promise.all(iterations).then(result => {
                resolve(result.reduce((a, b) => a.concat(b), []));
            });
        });
    }
    /**
     * Invoked when user selects files or folders by means of File Dialog
     * @param {?} e DOM event
     * @return {?}
     */
    onSelectFiles(e) {
        if (this.isClickMode()) {
            const /** @type {?} */ input = ((e.currentTarget));
            const /** @type {?} */ files = FileUtils.toFileArray(input.files);
            this.onUploadFiles(files.map(file => /** @type {?} */ ({
                entry: null,
                file: file,
                relativeFolder: '/'
            })));
            e.target.value = '';
        }
    }
}
UploadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-upload]'
            },] },
];
/**
 * @nocollapse
 */
UploadDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
    { type: NgZone, },
];
UploadDirective.propDecorators = {
    'enabled': [{ type: Input, args: ['adf-upload',] },],
    'data': [{ type: Input, args: ['adf-upload-data',] },],
    'mode': [{ type: Input },],
    'multiple': [{ type: Input },],
    'accept': [{ type: Input },],
    'directory': [{ type: Input },],
    'onClick': [{ type: HostListener, args: ['click', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DirectiveModule {
}
DirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    NodePermissionDirective,
                    NodeRestoreDirective,
                    UploadDirective
                ],
                exports: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    NodePermissionDirective,
                    NodeRestoreDirective,
                    UploadDirective
                ]
            },] },
];
/**
 * @nocollapse
 */
DirectiveModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataTableCellComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.value && this.column && this.column.key && this.row && this.data) {
            this.value = this.data.getValue(this.row, this.column);
            if (!this.tooltip) {
                this.tooltip = this.value;
            }
        }
    }
}
DataTableCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span [title]="tooltip" class="adf-datatable-cell-value">{{value}}</span>
        </ng-container>`,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-cell' }
            },] },
];
/**
 * @nocollapse
 */
DataTableCellComponent.ctorParameters = () => [];
DataTableCellComponent.propDecorators = {
    'data': [{ type: Input },],
    'column': [{ type: Input },],
    'row': [{ type: Input },],
    'value': [{ type: Input },],
    'tooltip': [{ type: Input },],
};

/**
 * Base cancellable event implementation
 */
class BaseEvent {
    constructor() {
        this.defaultPrevented = false;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Base container for any event which takes place in the DOM
 */
class BaseUIEvent extends BaseEvent {
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let FileUploadStatus = {};
FileUploadStatus.Pending = 0;
FileUploadStatus.Complete = 1;
FileUploadStatus.Starting = 2;
FileUploadStatus.Progress = 3;
FileUploadStatus.Cancelled = 4;
FileUploadStatus.Aborted = 5;
FileUploadStatus.Error = 6;
FileUploadStatus.Deleted = 7;
FileUploadStatus[FileUploadStatus.Pending] = "Pending";
FileUploadStatus[FileUploadStatus.Complete] = "Complete";
FileUploadStatus[FileUploadStatus.Starting] = "Starting";
FileUploadStatus[FileUploadStatus.Progress] = "Progress";
FileUploadStatus[FileUploadStatus.Cancelled] = "Cancelled";
FileUploadStatus[FileUploadStatus.Aborted] = "Aborted";
FileUploadStatus[FileUploadStatus.Error] = "Error";
FileUploadStatus[FileUploadStatus.Deleted] = "Deleted";
class FileModel {
    /**
     * @param {?} file
     * @param {?=} options
     */
    constructor(file, options) {
        this.status = FileUploadStatus.Pending;
        this.file = file;
        this.id = this.generateId();
        this.name = file.name;
        this.size = file.size;
        this.data = null;
        this.progress = {
            loaded: 0,
            total: 0,
            percent: 0
        };
        this.options = Object.assign({}, {
            newVersion: false
        }, options);
    }
    /**
     * @return {?}
     */
    generateId() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            let /** @type {?} */ r = Math.random() * 16 | 0, /** @type {?} */ v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * @return {?}
     */
    get extension() {
        return this.name.slice((Math.max(0, this.name.lastIndexOf('.')) || Infinity) + 1);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUploadEvent {
    /**
     * @param {?} file
     * @param {?=} status
     * @param {?=} error
     */
    constructor(file, status = FileUploadStatus.Pending, error = null) {
        this.file = file;
        this.status = status;
        this.error = error;
    }
}
class FileUploadCompleteEvent extends FileUploadEvent {
    /**
     * @param {?} file
     * @param {?=} totalComplete
     * @param {?=} data
     * @param {?=} totalAborted
     */
    constructor(file, totalComplete = 0, data, totalAborted = 0) {
        super(file, FileUploadStatus.Complete);
        this.totalComplete = totalComplete;
        this.data = data;
        this.totalAborted = totalAborted;
    }
}
class FileUploadDeleteEvent extends FileUploadEvent {
    /**
     * @param {?} file
     * @param {?=} totalComplete
     */
    constructor(file, totalComplete = 0) {
        super(file, FileUploadStatus.Deleted);
        this.totalComplete = totalComplete;
    }
}
class FileUploadErrorEvent extends FileUploadEvent {
    /**
     * @param {?} file
     * @param {?} error
     * @param {?=} totalError
     */
    constructor(file, error, totalError = 0) {
        super(file, FileUploadStatus.Error);
        this.error = error;
        this.totalError = totalError;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataRowEvent extends BaseUIEvent {
    /**
     * @param {?} value
     * @param {?} domEvent
     * @param {?=} sender
     */
    constructor(value, domEvent, sender) {
        super();
        this.value = value;
        this.event = domEvent;
        this.sender = sender;
    }
}

class DataSorting {
    /**
     * @param {?=} key
     * @param {?=} direction
     */
    constructor(key, direction) {
        this.key = key;
        this.direction = direction;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectDataRow {
    /**
     * @param {?} obj
     * @param {?=} isSelected
     */
    constructor(obj, isSelected = false) {
        this.obj = obj;
        this.isSelected = isSelected;
        if (!obj) {
            throw new Error('Object source not found');
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getValue(key) {
        return ObjectUtils.getValue(this.obj, key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectDataColumn {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        this.key = obj.key;
        this.type = obj.type || 'text';
        this.format = obj.format;
        this.sortable = obj.sortable;
        this.title = obj.title;
        this.srTitle = obj.srTitle;
        this.cssClass = obj.cssClass;
        this.template = obj.template;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectDataTableAdapter {
    /**
     * @param {?} data
     * @return {?}
     */
    static generateSchema(data) {
        let /** @type {?} */ schema = [];
        if (data && data.length) {
            let /** @type {?} */ rowToExaminate = data[0];
            if (typeof rowToExaminate === 'object') {
                for (let /** @type {?} */ key in rowToExaminate) {
                    if (rowToExaminate.hasOwnProperty(key)) {
                        schema.push({
                            type: 'text',
                            key: key,
                            title: key,
                            sortable: false
                        });
                    }
                }
            }
        }
        return schema;
    }
    /**
     * @param {?=} data
     * @param {?=} schema
     */
    constructor(data = [], schema = []) {
        this._rows = [];
        this._columns = [];
        if (data && data.length > 0) {
            this._rows = data.map(item => {
                return new ObjectDataRow(item);
            });
        }
        if (schema && schema.length > 0) {
            this._columns = schema.map(item => {
                return new ObjectDataColumn(item);
            });
            // Sort by first sortable or just first column
            let sortable = this._columns.filter(c => c.sortable);
            if (sortable.length > 0) {
                this.sort(sortable[0].key, 'asc');
            }
        }
    }
    /**
     * @return {?}
     */
    getRows() {
        return this._rows;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    setRows(rows) {
        this._rows = rows || [];
        this.sort();
    }
    /**
     * @return {?}
     */
    getColumns() {
        return this._columns;
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    setColumns(columns) {
        this._columns = columns || [];
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getValue(row, col) {
        if (!row) {
            throw new Error('Row not found');
        }
        if (!col) {
            throw new Error('Column not found');
        }
        let /** @type {?} */ value = row.getValue(col.key);
        if (col.type === 'date') {
            try {
                return this.formatDate(col, value);
            }
            catch (err) {
                console.error(`Error parsing date ${value} to format ${col.format}`);
            }
        }
        if (col.type === 'icon') {
            const /** @type {?} */ icon = row.getValue(col.key);
            return icon;
        }
        return value;
    }
    /**
     * @param {?} col
     * @param {?} value
     * @return {?}
     */
    formatDate(col, value) {
        if (col.type === 'date') {
            const /** @type {?} */ format = col.format || 'medium';
            if (format === 'timeAgo') {
                const /** @type {?} */ timeAgoPipe = new TimeAgoPipe();
                return timeAgoPipe.transform(value);
            }
            else {
                const /** @type {?} */ datePipe = new DatePipe('en-US');
                return datePipe.transform(value, format);
            }
        }
        return value;
    }
    /**
     * @return {?}
     */
    getSorting() {
        return this._sorting;
    }
    /**
     * @param {?} sorting
     * @return {?}
     */
    setSorting(sorting) {
        this._sorting = sorting;
        if (sorting && sorting.key) {
            this._rows.sort((a, b) => {
                let /** @type {?} */ left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                let /** @type {?} */ right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right)
                    : right.localeCompare(left);
            });
        }
    }
    /**
     * @param {?=} key
     * @param {?=} direction
     * @return {?}
     */
    sort(key, direction) {
        let /** @type {?} */ sorting = this._sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataCellEventModel {
    /**
     * @param {?} row
     * @param {?} col
     * @param {?} actions
     */
    constructor(row, col, actions) {
        this.row = row;
        this.col = col;
        this.actions = actions || [];
    }
}
class DataCellEvent extends BaseEvent {
    /**
     * @param {?} row
     * @param {?} col
     * @param {?} actions
     */
    constructor(row, col, actions) {
        super();
        this.value = new DataCellEventModel(row, col, actions);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataRowActionEvent extends BaseEvent {
    /**
     * @return {?}
     */
    get args() {
        return this.value;
    }
    /**
     * @param {?} row
     * @param {?} action
     */
    constructor(row, action) {
        super();
        this.value = new DataRowActionModel(row, action);
    }
}
class DataRowActionModel {
    /**
     * @param {?} row
     * @param {?} action
     */
    constructor(row, action) {
        this.row = row;
        this.action = action;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataTableComponent {
    /**
     * @param {?} elementRef
     * @param {?} differs
     */
    constructor(elementRef, differs) {
        this.elementRef = elementRef;
        this.rows = [];
        this.selectionMode = 'single'; // none|single|multiple
        this.multiselect = false;
        this.actions = false;
        this.actionsPosition = 'right'; // left|right
        this.contextMenu = false;
        this.allowDropFiles = false;
        this.rowStyleClass = '';
        this.showHeader = true;
        this.rowClick = new EventEmitter();
        this.rowDblClick = new EventEmitter();
        this.showRowContextMenu = new EventEmitter();
        this.showRowActionsMenu = new EventEmitter();
        this.executeRowAction = new EventEmitter();
        this.loading = false;
        this.noPermission = false;
        this.isSelectAllChecked = false;
        this.selection = new Array();
        this.schema = [];
        this.rowMenuCache = {};
        if (differs) {
            this.differ = differs.find([]).create(null);
        }
        this.click$ = new Observable$1(observer => this.clickObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setTableSchema();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.initAndSubscribeClickStream();
        if (this.isPropertyChanged(changes['data'])) {
            if (this.isTableEmpty()) {
                this.initTable();
            }
            else {
                this.data = changes['data'].currentValue;
            }
            return;
        }
        if (this.isPropertyChanged(changes['rows'])) {
            if (this.isTableEmpty()) {
                this.initTable();
            }
            else {
                this.setTableRows(changes['rows'].currentValue);
            }
            return;
        }
        if (changes.selectionMode && !changes.selectionMode.isFirstChange()) {
            this.resetSelection();
            this.emitRowSelectionEvent('row-unselect', null);
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        let /** @type {?} */ changes = this.differ.diff(this.rows);
        if (changes) {
            this.setTableRows(this.rows);
        }
    }
    /**
     * @param {?} property
     * @return {?}
     */
    isPropertyChanged(property) {
        return property && property.currentValue ? true : false;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    convertToRowsData(rows) {
        return rows.map(row => new ObjectDataRow(row));
    }
    /**
     * @return {?}
     */
    initAndSubscribeClickStream() {
        this.unsubscribeClickStream();
        let /** @type {?} */ singleClickStream = this.click$
            .buffer(this.click$.debounceTime(250))
            .map(list => list)
            .filter(x => x.length === 1);
        this.singleClickStreamSub = singleClickStream.subscribe((obj) => {
            let /** @type {?} */ event = obj[0];
            this.rowClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-click', {
                    detail: event,
                    bubbles: true
                }));
            }
        });
        let /** @type {?} */ multiClickStream = this.click$
            .buffer(this.click$.debounceTime(250))
            .map(list => list)
            .filter(x => x.length >= 2);
        this.multiClickStreamSub = multiClickStream.subscribe((obj) => {
            let /** @type {?} */ event = obj[0];
            this.rowDblClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
                    detail: event,
                    bubbles: true
                }));
            }
        });
    }
    /**
     * @return {?}
     */
    unsubscribeClickStream() {
        if (this.singleClickStreamSub) {
            this.singleClickStreamSub.unsubscribe();
        }
        if (this.multiClickStreamSub) {
            this.multiClickStreamSub.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    initTable() {
        this.data = new ObjectDataTableAdapter(this.rows, this.schema);
        this.rowMenuCache = {};
    }
    /**
     * @return {?}
     */
    isTableEmpty() {
        return this.data === undefined || this.data === null;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    setTableRows(rows) {
        if (this.data) {
            this.data.setRows(this.convertToRowsData(rows));
        }
    }
    /**
     * @return {?}
     */
    setTableSchema() {
        if (this.columnList && this.columnList.columns) {
            this.schema = this.columnList.columns.map(c => /** @type {?} */ (c));
        }
        if (this.data && this.schema && this.schema.length > 0) {
            this.data.setColumns(this.schema);
        }
    }
    /**
     * @param {?} row
     * @param {?} e
     * @return {?}
     */
    onRowClick(row, e) {
        if (e) {
            e.preventDefault();
        }
        if (row) {
            if (this.data) {
                if (this.isSingleSelectionMode()) {
                    this.resetSelection();
                    this.selectRow(row, true);
                    this.emitRowSelectionEvent('row-select', row);
                }
                if (this.isMultiSelectionMode()) {
                    const /** @type {?} */ modifier = e && (e.metaKey || e.ctrlKey);
                    const /** @type {?} */ newValue = modifier ? !row.isSelected : true;
                    const /** @type {?} */ domEventName = newValue ? 'row-select' : 'row-unselect';
                    if (!modifier) {
                        this.resetSelection();
                    }
                    this.selectRow(row, newValue);
                    this.emitRowSelectionEvent(domEventName, row);
                }
            }
            const /** @type {?} */ dataRowEvent = new DataRowEvent(row, e, this);
            this.clickObserver.next(dataRowEvent);
        }
    }
    /**
     * @return {?}
     */
    resetSelection() {
        if (this.data) {
            const /** @type {?} */ rows = this.data.getRows();
            if (rows && rows.length > 0) {
                rows.forEach(r => r.isSelected = false);
            }
            this.selection.splice(0);
        }
        this.isSelectAllChecked = false;
    }
    /**
     * @param {?} row
     * @param {?=} e
     * @return {?}
     */
    onRowDblClick(row, e) {
        if (e) {
            e.preventDefault();
        }
        let /** @type {?} */ dataRowEvent = new DataRowEvent(row, e, this);
        this.clickObserver.next(dataRowEvent);
    }
    /**
     * @param {?} row
     * @param {?} e
     * @return {?}
     */
    onRowKeyUp(row, e) {
        const /** @type {?} */ event = new CustomEvent('row-keyup', {
            detail: {
                row: row,
                keyboardEvent: e,
                sender: this
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(event);
        if (event.defaultPrevented) {
            e.preventDefault();
        }
        else {
            if (e.key === 'Enter') {
                this.onKeyboardNavigate(row, e);
            }
        }
    }
    /**
     * @param {?} row
     * @param {?} e
     * @return {?}
     */
    onKeyboardNavigate(row, e) {
        if (e) {
            e.preventDefault();
        }
        const /** @type {?} */ event = new DataRowEvent(row, e, this);
        this.rowDblClick.emit(event);
        this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
            detail: event,
            bubbles: true
        }));
    }
    /**
     * @param {?} column
     * @return {?}
     */
    onColumnHeaderClick(column) {
        if (column && column.sortable) {
            let /** @type {?} */ current = this.data.getSorting();
            let /** @type {?} */ newDirection = 'asc';
            if (current && column.key === current.key) {
                newDirection = current.direction === 'asc' ? 'desc' : 'asc';
            }
            this.data.setSorting(new DataSorting(column.key, newDirection));
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onSelectAllClick(e) {
        this.isSelectAllChecked = e.checked;
        if (this.multiselect) {
            let /** @type {?} */ rows = this.data.getRows();
            if (rows && rows.length > 0) {
                for (let /** @type {?} */ i = 0; i < rows.length; i++) {
                    this.selectRow(rows[i], e.checked);
                }
            }
            const /** @type {?} */ domEventName = e.checked ? 'row-select' : 'row-unselect';
            const /** @type {?} */ row = this.selection.length > 0 ? this.selection[0] : null;
            this.emitRowSelectionEvent(domEventName, row);
        }
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    onCheckboxChange(row, event) {
        const /** @type {?} */ newValue = event.checked;
        this.selectRow(row, newValue);
        const /** @type {?} */ domEventName = newValue ? 'row-select' : 'row-unselect';
        this.emitRowSelectionEvent(domEventName, row);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onImageLoadingError(event) {
        if (event && this.fallbackThumbnail) {
            let /** @type {?} */ element = (event.target);
            element.src = this.fallbackThumbnail;
        }
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    isIconValue(row, col) {
        if (row && col) {
            let /** @type {?} */ value = row.getValue(col.key);
            return value && value.startsWith('material-icons://');
        }
        return false;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    asIconValue(row, col) {
        if (this.isIconValue(row, col)) {
            let /** @type {?} */ value = row.getValue(col.key) || '';
            return value.replace('material-icons://', '');
        }
        return null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    iconAltTextKey(value) {
        return value ? 'ICONS.' + value.substring(value.lastIndexOf('/') + 1).replace(/\.[a-z]+/, '') : '';
    }
    /**
     * @param {?} col
     * @param {?} direction
     * @return {?}
     */
    isColumnSorted(col, direction) {
        if (col && direction) {
            let /** @type {?} */ sorting = this.data.getSorting();
            return sorting && sorting.key === col.key && sorting.direction === direction;
        }
        return false;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getContextMenuActions(row, col) {
        let /** @type {?} */ event = new DataCellEvent(row, col, []);
        this.showRowContextMenu.emit(event);
        return event.value.actions;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getRowActions(row, col) {
        const /** @type {?} */ id = row.getValue('id');
        if (!this.rowMenuCache[id]) {
            let /** @type {?} */ event = new DataCellEvent(row, col, []);
            this.showRowActionsMenu.emit(event);
            this.rowMenuCache[id] = event.value.actions;
        }
        return this.rowMenuCache[id];
    }
    /**
     * @param {?} row
     * @param {?} action
     * @return {?}
     */
    onExecuteRowAction(row, action) {
        if (action.disabled || action.disabled) {
            event.stopPropagation();
        }
        else {
            this.executeRowAction.emit(new DataRowActionEvent(row, action));
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    rowAllowsDrop(row) {
        return row.isDropTarget === true;
    }
    /**
     * @return {?}
     */
    hasSelectionMode() {
        return this.isSingleSelectionMode() || this.isMultiSelectionMode();
    }
    /**
     * @return {?}
     */
    isSingleSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'single';
    }
    /**
     * @return {?}
     */
    isMultiSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'multiple';
    }
    /**
     * @param {?} row
     * @return {?}
     */
    getRowStyle(row) {
        row.cssClass = row.cssClass ? row.cssClass : '';
        this.rowStyleClass = this.rowStyleClass ? this.rowStyleClass : '';
        return `${row.cssClass} ${this.rowStyleClass}`;
    }
    /**
     * @param {?} row
     * @param {?} value
     * @return {?}
     */
    selectRow(row, value) {
        if (row) {
            row.isSelected = value;
            const /** @type {?} */ idx = this.selection.indexOf(row);
            if (value) {
                if (idx < 0) {
                    this.selection.push(row);
                }
            }
            else {
                if (idx > -1) {
                    this.selection.splice(idx, 1);
                }
            }
        }
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getCellTooltip(row, col) {
        if (row && col && col.formatTooltip) {
            const /** @type {?} */ result = col.formatTooltip(row, col);
            if (result) {
                return result;
            }
        }
        return null;
    }
    /**
     * @param {?} name
     * @param {?} row
     * @return {?}
     */
    emitRowSelectionEvent(name, row) {
        const /** @type {?} */ domEvent = new CustomEvent(name, {
            detail: {
                row: row,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
}
DataTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable',
                styles: [`

    `],
                template: `
      <table
          *ngIf="data"
          class="full-width adf-data-table">

          <thead *ngIf="showHeader">
          <tr>
              <!-- Actions (left) -->
              <th *ngIf="actions && actionsPosition === 'left'" class="actions-column">
                  <span class="sr-only">Actions</span>
              </th>
              <!-- Columns -->
              <th *ngIf="multiselect">
                  <mat-checkbox [checked]="isSelectAllChecked" (change)="onSelectAllClick($event)"></mat-checkbox>
              </th>
              <th class="adf-data-table-cell--{{col.type || 'text'}} {{col.cssClass}}"
                  *ngFor="let col of data.getColumns()"
                  [class.sortable]="col.sortable"
                  [attr.data-automation-id]="'auto_id_' + col.key"
                  [class.adf-data-table__header--sorted-asc]="isColumnSorted(col, 'asc')"
                  [class.adf-data-table__header--sorted-desc]="isColumnSorted(col, 'desc')"
                  (click)="onColumnHeaderClick(col)"
                  (keyup.enter)="onColumnHeaderClick(col)"
                  role="button"
                  tabindex="0"
                  title="{{ col.title | translate }}">
                  <span *ngIf="col.srTitle" class="sr-only">{{ col.srTitle | translate }}</span>
                  <span *ngIf="col.title">{{ col.title | translate}}</span>
              </th>
              <!-- Actions (right) -->
              <th *ngIf="actions && actionsPosition === 'right'" class="actions-column">
                  <span class="sr-only">Actions</span>
              </th>
          </tr>
          </thead>

          <tbody>
          <ng-container *ngIf="!loading && !noPermission">
              <tr *ngFor="let row of data.getRows(); let idx = index"
                  role="button"
                  [class.is-selected]="row.isSelected"
                  [adf-upload]="allowDropFiles && rowAllowsDrop(row)" [adf-upload-data]="row"
                  [ngStyle]="rowStyle"
                  [ngClass]="getRowStyle(row)"
                  (keyup)="onRowKeyUp(row, $event)">

                  <!-- Actions (left) -->
                  <td *ngIf="actions && actionsPosition === 'left'">
                      <button mat-icon-button [matMenuTriggerFor]="menu"
                          [attr.data-automation-id]="'action_menu_' + idx">
                          <mat-icon>more_vert</mat-icon>
                      </button>
                      <mat-menu #menu="matMenu">
                          <button mat-menu-item *ngFor="let action of getRowActions(row)"
                              [attr.data-automation-id]="action.title"
                              [disabled]="action.disabled"
                              (click)="onExecuteRowAction(row, action)">
                              <mat-icon *ngIf="action.icon">{{ action.icon }}</mat-icon>
                              <span>{{ action.title | translate }}</span>
                          </button>
                      </mat-menu>
                  </td>

                  <td *ngIf="multiselect">
                      <mat-checkbox
                          [checked]="row.isSelected"
                          (change)="onCheckboxChange(row, $event)">
                      </mat-checkbox>
                  </td>
                  <td *ngFor="let col of data.getColumns()"
                      class="adf-data-table-cell adf-data-table-cell--{{col.type || 'text'}} {{col.cssClass}}"
                      tabindex="0"
                      (click)="onRowClick(row, $event)"
                      [context-menu]="getContextMenuActions(row, col)"
                      [context-menu-enabled]="contextMenu">
                      <div *ngIf="!col.template" class="cell-container">
                          <ng-container [ngSwitch]="col.type">
                              <div *ngSwitchCase="'image'" class="cell-value">
                                  <mat-icon *ngIf="isIconValue(row, col)">{{ asIconValue(row, col) }}</mat-icon>
                                  <mat-icon *ngIf="!isIconValue(row, col) && row.isSelected" svgIcon="selected" >
                                  </mat-icon>

                                  <img *ngIf="!isIconValue(row, col) && !row.isSelected"
                                       alt="{{ iconAltTextKey(data.getValue(row, col)) | translate }}"
                                       src="{{ data.getValue(row, col) }}"
                                       (error)="onImageLoadingError($event)">
                              </div>
                              <div *ngSwitchCase="'icon'"  class="cell-value">
                                  <span class="sr-only">{{ iconAltTextKey(data.getValue(row, col)) | translate }}</span>
                                  <mat-icon>{{ data.getValue(row, col) }}</mat-icon>
                              </div>
                              <div *ngSwitchCase="'date'"  class="cell-value"
                                  [attr.data-automation-id]="'date_' + data.getValue(row, col)">
                                  <adf-date-cell
                                      [data]="data"
                                      [column]="col"
                                      [row]="row"
                                      [tooltip]="getCellTooltip(row, col)">
                                  </adf-date-cell>
                              </div>
                              <div *ngSwitchCase="'location'" class="cell-value"
                                  [attr.data-automation-id]="'location' + data.getValue(row, col)">
                                  <adf-location-cell
                                      [data]="data"
                                      [column]="col"
                                      [row]="row"
                                      [tooltip]="getCellTooltip(row, col)">
                                  </adf-location-cell>
                              </div>
                              <div *ngSwitchCase="'fileSize'" class="cell-value"
                                  [attr.data-automation-id]="'fileSize_' + data.getValue(row, col)">
                                  <adf-filesize-cell
                                      [data]="data"
                                      [column]="col"
                                      [row]="row"
                                      [tooltip]="getCellTooltip(row, col)">
                                  </adf-filesize-cell>
                              </div>
                              <div *ngSwitchCase="'text'" class="cell-value"
                                  [attr.data-automation-id]="'text_' + data.getValue(row, col)">
                                  <adf-datatable-cell
                                      [data]="data"
                                      [column]="col"
                                      [row]="row"
                                      [tooltip]="getCellTooltip(row, col)">
                                  </adf-datatable-cell>
                              </div>
                          <span *ngSwitchDefault class="cell-value">
                          <!-- empty cell for unknown column type -->
                          </span>
                          </ng-container>
                      </div>
                      <div *ngIf="col.template" class="cell-container">
                          <ng-container
                              [ngTemplateOutlet]="col.template"
                              [ngTemplateOutletContext]="{ $implicit: { data: data, row: row, col: col }, value: data.getValue(row, col) }">
                          </ng-container>
                      </div>
                  </td>

                  <!-- Actions (right) -->
                  <td *ngIf="actions && actionsPosition === 'right'" class="alfresco-datatable__actions-cell">
                      <button mat-icon-button [matMenuTriggerFor]="menu"
                          [attr.data-automation-id]="'action_menu_' + idx">
                          <mat-icon>more_vert</mat-icon>
                      </button>
                      <mat-menu #menu="matMenu">
                          <button mat-menu-item *ngFor="let action of getRowActions(row)"
                              [attr.data-automation-id]="action.title"
                              [disabled]="action.disabled"
                              (click)="onExecuteRowAction(row, action)">
                              <mat-icon *ngIf="action.icon">{{ action.icon }}</mat-icon>
                              <span>{{ action.title | translate }}</span>
                          </button>
                      </mat-menu>
                  </td>

              </tr>
              <tr *ngIf="data.getRows().length === 0">
                  <td class="adf-no-content-container"
                      [attr.colspan]="1 + data.getColumns().length">
                      <ng-template *ngIf="noContentTemplate"
                                   ngFor [ngForOf]="[data]"
                                   [ngForTemplate]="noContentTemplate">
                      </ng-template>
                      <ng-content select="adf-empty-list"></ng-content>
                  </td>
              </tr>
          </ng-container>
          <tr *ngIf="!loading && noPermission" class="adf-no-permission__row">
              <td class="adf-no-permission__cell">
                  <ng-template *ngIf="noPermissionTemplate"
                               ngFor [ngForOf]="[data]"
                               [ngForTemplate]="noPermissionTemplate">
                  </ng-template>
              </td>
          </tr>
          <tr *ngIf="loading">
              <td class="adf-loading-content-container"
                  [attr.colspan]="1 + data.getColumns().length">
                  <ng-template *ngIf="loadingTemplate"
                               ngFor [ngForOf]="[data]"
                               [ngForTemplate]="loadingTemplate">
                  </ng-template>
              </td>
          </tr>
          </tbody>
      </table>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DataTableComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: IterableDiffers, },
];
DataTableComponent.propDecorators = {
    'columnList': [{ type: ContentChild, args: [DataColumnListComponent,] },],
    'data': [{ type: Input },],
    'rows': [{ type: Input },],
    'selectionMode': [{ type: Input },],
    'multiselect': [{ type: Input },],
    'actions': [{ type: Input },],
    'actionsPosition': [{ type: Input },],
    'fallbackThumbnail': [{ type: Input },],
    'contextMenu': [{ type: Input },],
    'allowDropFiles': [{ type: Input },],
    'rowStyle': [{ type: Input },],
    'rowStyleClass': [{ type: Input },],
    'showHeader': [{ type: Input },],
    'rowClick': [{ type: Output },],
    'rowDblClick': [{ type: Output },],
    'showRowContextMenu': [{ type: Output },],
    'showRowActionsMenu': [{ type: Output },],
    'executeRowAction': [{ type: Output },],
    'loading': [{ type: Input },],
    'noPermission': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DateCellComponent extends DataTableCellComponent {
}
DateCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span [title]="tooltip">{{value}}</span>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-date-cell' }
            },] },
];
/**
 * @nocollapse
 */
DateCellComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmptyListComponent {
}
EmptyListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-list',
                styles: [`
      .adf-empty-list_template {
        text-align: center;
        margin-top: 20px;
        margin-bottom: 20px; }
    `],
                template: `
      <div class="adf-empty-list_template">
          <ng-content select="[adf-empty-list-header]"></ng-content>
          <ng-content select="[adf-empty-list-body]"></ng-content>
          <ng-content select="[adf-empty-list-footer]"></ng-content>
          <ng-content></ng-content>
      </div>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
EmptyListComponent.ctorParameters = () => [];
class EmptyListHeaderDirective {
}
EmptyListHeaderDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-header]' },] },
];
/**
 * @nocollapse
 */
EmptyListHeaderDirective.ctorParameters = () => [];
class EmptyListBodyDirective {
}
EmptyListBodyDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-body]' },] },
];
/**
 * @nocollapse
 */
EmptyListBodyDirective.ctorParameters = () => [];
class EmptyListFooterDirective {
}
EmptyListFooterDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-footer]' },] },
];
/**
 * @nocollapse
 */
EmptyListFooterDirective.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileSizeCellComponent extends DataTableCellComponent {
}
FileSizeCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-filesize-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span [title]="tooltip">{{ value | adfFileSize }}</span>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-filesize-cell' }
            },] },
];
/**
 * @nocollapse
 */
FileSizeCellComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LocationCellComponent extends DataTableCellComponent {
    constructor() {
        super(...arguments);
        this.displayText = '';
    }
    /**
     * @override
     * @return {?}
     */
    ngOnInit() {
        if (!this.value && this.column && this.column.key && this.row && this.data) {
            const /** @type {?} */ path = this.data.getValue(this.row, this.column);
            if (path && path.name && path.elements) {
                this.value = path;
                this.displayText = path.name.split('/').pop();
                if (!this.tooltip) {
                    this.tooltip = path.name;
                }
                const /** @type {?} */ parent = path.elements[path.elements.length - 1];
                this.link = [this.column.format, parent.id];
            }
        }
    }
}
LocationCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-location-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <a href="" [title]="tooltip" [routerLink]="link">
                {{ displayText }}
            </a>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-location-cell' }
            },] },
];
/**
 * @nocollapse
 */
LocationCellComponent.ctorParameters = () => [];
LocationCellComponent.propDecorators = {
    'link': [{ type: Input },],
    'displayText': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoadingContentTemplateDirective {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.loadingTemplate = this.template;
        }
    }
}
LoadingContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'loading-content-template'
            },] },
];
/**
 * @nocollapse
 */
LoadingContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent, },
];
LoadingContentTemplateDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoContentTemplateDirective {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noContentTemplate = this.template;
        }
    }
}
NoContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-content-template'
            },] },
];
/**
 * @nocollapse
 */
NoContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent, },
];
NoContentTemplateDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoPermissionTemplateDirective {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noPermissionTemplate = this.template;
        }
    }
}
NoPermissionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-permission-template'
            },] },
];
/**
 * @nocollapse
 */
NoPermissionTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent, },
];
NoPermissionTemplateDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataTableModule {
}
DataTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule,
                    ContextMenuModule,
                    PipeModule,
                    DirectiveModule
                ],
                declarations: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective
                ],
                exports: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective
                ]
            },] },
];
/**
 * @nocollapse
 */
DataTableModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfoDrawerLayoutComponent {
}
InfoDrawerLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-layout',
                template: `
      <div class="adf-info-drawer-layout-header">
          <div class="adf-info-drawer-layout-header-title">
              <ng-content select="[info-drawer-title]"></ng-content>
          </div>
          <div class="adf-info-drawer-layout-header-buttons">
              <ng-content select="[info-drawer-buttons]"></ng-content>
          </div>
      </div>
      <div class="adf-info-drawer-layout-content">
          <ng-content select="[info-drawer-content]"></ng-content>
      </div>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer-layout' }
            },] },
];
/**
 * @nocollapse
 */
InfoDrawerLayoutComponent.ctorParameters = () => [];
class InfoDrawerTitleDirective {
}
InfoDrawerTitleDirective.decorators = [
    { type: Directive, args: [{ selector: '[info-drawer-title]' },] },
];
/**
 * @nocollapse
 */
InfoDrawerTitleDirective.ctorParameters = () => [];
class InfoDrawerButtonsDirective {
}
InfoDrawerButtonsDirective.decorators = [
    { type: Directive, args: [{ selector: '[info-drawer-buttons]' },] },
];
/**
 * @nocollapse
 */
InfoDrawerButtonsDirective.ctorParameters = () => [];
class InfoDrawerContentDirective {
}
InfoDrawerContentDirective.decorators = [
    { type: Directive, args: [{ selector: '[info-drawer-content]' },] },
];
/**
 * @nocollapse
 */
InfoDrawerContentDirective.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfoDrawerTabComponent {
    constructor() {
        this.label = 'Main tab';
    }
}
InfoDrawerTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-tab',
                template: '<ng-template><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
InfoDrawerTabComponent.ctorParameters = () => [];
InfoDrawerTabComponent.propDecorators = {
    'label': [{ type: Input, args: ['label',] },],
    'content': [{ type: ViewChild, args: [TemplateRef,] },],
};
class InfoDrawerComponent {
    constructor() {
        this.title = null;
        this.currentTab = new EventEmitter();
    }
    /**
     * @return {?}
     */
    showTabLayout() {
        return this.contentBlocks.length > 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTabChange(event) {
        this.currentTab.emit(event.index);
    }
}
InfoDrawerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer',
                template: `
      <adf-info-drawer-layout>
          <div *ngIf="title" info-drawer-title>{{title}}</div>
          <ng-content *ngIf="!title" info-drawer-title select="[info-drawer-title]"></ng-content>

          <ng-content info-drawer-buttons select="[info-drawer-buttons]"></ng-content>

          <ng-container info-drawer-content *ngIf="showTabLayout(); then tabLayout else singleLayout"></ng-container>

          <ng-template #tabLayout>
              <mat-tab-group class="adf-info-drawer-tabs" (selectedTabChange)="onTabChange($event)">
                  <ng-container *ngFor="let contentBlock of contentBlocks">
                      <mat-tab [label]="contentBlock.label" class="adf-info-drawer-tab">
                          <ng-container *ngTemplateOutlet="contentBlock.content"></ng-container>
                      </mat-tab>
                  </ng-container>
              </mat-tab-group>
          </ng-template>

          <ng-template #singleLayout>
              <ng-content select="[info-drawer-content]"></ng-content>
          </ng-template>
      </adf-info-drawer-layout>
    `,
                styles: [`
      .adf-info-drawer {
        display: block; }
        .adf-info-drawer .adf-info-drawer-layout-content {
          padding: 0; }
          .adf-info-drawer .adf-info-drawer-layout-content > :not(.adf-info-drawer-tabs) {
            padding: 10px; }
            .adf-info-drawer .adf-info-drawer-layout-content > :not(.adf-info-drawer-tabs) > * {
              margin-bottom: 20px;
              display: block; }
          .adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content > * {
            margin-bottom: 20px;
            display: block; }
          .adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content > *:last-child {
            margin-bottom: 0; }
          .adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-label {
            -webkit-box-flex: 1;
                -ms-flex-positive: 1;
                    flex-grow: 1; }
          .adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-ink-bar {
            height: 4px; }
          .adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body {
            padding: 10px; }
          .adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content {
            overflow: initial; }
    `],
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer' }
            },] },
];
/**
 * @nocollapse
 */
InfoDrawerComponent.ctorParameters = () => [];
InfoDrawerComponent.propDecorators = {
    'title': [{ type: Input },],
    'currentTab': [{ type: Output },],
    'contentBlocks': [{ type: ContentChildren, args: [InfoDrawerTabComponent,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfoDrawerModule {
}
InfoDrawerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    InfoDrawerLayoutComponent,
                    InfoDrawerTabComponent,
                    InfoDrawerComponent
                ],
                exports: [
                    InfoDrawerLayoutComponent,
                    InfoDrawerTabComponent,
                    InfoDrawerComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
InfoDrawerModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LanguageMenuComponent {
    /**
     * @param {?} appConfig
     * @param {?} userPreference
     */
    constructor(appConfig, userPreference) {
        this.appConfig = appConfig;
        this.userPreference = userPreference;
        this.languages = [
            { key: 'en', label: 'English' }
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const /** @type {?} */ languagesCongifApp = this.appConfig.get(AppConfigService.APP_CONFIG_LANGUAGES_KEY);
        if (languagesCongifApp) {
            this.languages = languagesCongifApp;
        }
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    changeLanguage(lang) {
        this.userPreference.locale = lang;
    }
}
LanguageMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-language-menu',
                template: `
      <button mat-menu-item *ngFor="let language of languages" (click)="changeLanguage(language.key)">{{language.label}}
      </button>
    `
            },] },
];
/**
 * @nocollapse
 */
LanguageMenuComponent.ctorParameters = () => [
    { type: AppConfigService, },
    { type: UserPreferencesService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LanguageMenuModule {
}
LanguageMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    LanguageMenuComponent
                ],
                exports: [
                    LanguageMenuComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
LanguageMenuModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SettingsService {
    /**
     * @param {?} appConfig
     * @param {?} logService
     * @param {?} preferences
     */
    constructor(appConfig, logService, preferences) {
        this.appConfig = appConfig;
        this.logService = logService;
        this.preferences = preferences;
    }
    /**
     * @deprecated in 1.6.0
     * @return {?}
     */
    get ecmHost() {
        this.logService.log('SettingsService.ecmHost is deprecated. Use AppConfigService instead.');
        return this.appConfig.get('ecmHost');
    }
    /**
     * @deprecated in 1.7.0
     * @param {?} csrfDisabled
     * @return {?}
     */
    set csrfDisabled(csrfDisabled) {
        this.logService.log(`SettingsService.csrfDisabled is deprecated. Use UserPreferencesService.disableCSRF instead.`);
        this.preferences.disableCSRF = csrfDisabled;
    }
    /**
     * @deprecated in 1.6.0
     * @param {?} ecmHostUrl
     * @return {?}
     */
    set ecmHost(ecmHostUrl) {
        this.logService.log('SettingsService.ecmHost is deprecated. Use AppConfigService instead.');
    }
    /**
     * @deprecated in 1.6.0
     * @return {?}
     */
    get bpmHost() {
        this.logService.log('SettingsService.bpmHost is deprecated. Use AppConfigService instead.');
        return this.appConfig.get('bpmHost');
    }
    /**
     * @deprecated in 1.6.0
     * @param {?} bpmHostUrl
     * @return {?}
     */
    set bpmHost(bpmHostUrl) {
        this.logService.log('SettingsService.bpmHost is deprecated. Use AppConfigService instead.');
    }
    /**
     * @deprecated in 1.6.0
     * @return {?}
     */
    getBPMApiBaseUrl() {
        this.logService.log('SettingsService.getBPMApiBaseUrl is deprecated.');
        return this.bpmHost + '/activiti-app';
    }
    /**
     * @deprecated in 1.7.0
     * @return {?}
     */
    getProviders() {
        this.logService.log(`SettingsService.getProviders is deprecated. Use UserPreferencesService.authType instead.`);
        return this.preferences.authType;
    }
    /**
     * @deprecated in 1.7.0
     * @param {?} providers
     * @return {?}
     */
    setProviders(providers) {
        this.logService.log(`SettingsService.getProviders is deprecated. Use UserPreferencesService.authType instead.`);
        this.preferences.authType = providers;
    }
}
SettingsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SettingsService.ctorParameters = () => [
    { type: AppConfigService, },
    { type: LogService, },
    { type: UserPreferencesService, },
];

class LoginErrorEvent {
    /**
     * @param {?} err
     */
    constructor(err) {
        this.err = err;
    }
}

class LoginSubmitEvent {
    /**
     * @param {?} _values
     */
    constructor(_values) {
        this._defaultPrevented = false;
        this._values = _values;
    }
    /**
     * @return {?}
     */
    get values() {
        return this._values;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this._defaultPrevented = true;
    }
}

class LoginSuccessEvent {
    /**
     * @param {?} token
     * @param {?} username
     * @param {?} password
     */
    constructor(token, username, password) {
        this.token = token;
        this.username = username;
        this.password = password;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let LoginSteps = {};
LoginSteps.Landing = 0;
LoginSteps.Checking = 1;
LoginSteps.Welcome = 2;
LoginSteps[LoginSteps.Landing] = "Landing";
LoginSteps[LoginSteps.Checking] = "Checking";
LoginSteps[LoginSteps.Welcome] = "Welcome";
class LoginComponent {
    /**
     * Constructor
     * @param {?} _fb
     * @param {?} authService
     * @param {?} settingsService
     * @param {?} translateService
     * @param {?} logService
     * @param {?} elementRef
     * @param {?} router
     * @param {?} userPreferences
     */
    constructor(_fb, authService, settingsService, translateService, logService, elementRef, router$$1, userPreferences) {
        this._fb = _fb;
        this.authService = authService;
        this.settingsService = settingsService;
        this.translateService = translateService;
        this.logService = logService;
        this.elementRef = elementRef;
        this.router = router$$1;
        this.userPreferences = userPreferences;
        this.isPasswordShow = false;
        this.showRememberMe = true;
        this.showLoginActions = true;
        this.needHelpLink = '';
        this.registerLink = '';
        this.logoImageUrl = './assets/images/alfresco-logo.svg';
        this.backgroundImageUrl = './assets/images/background.svg';
        this.copyrightText = '\u00A9 2016 Alfresco Software, Inc. All Rights Reserved.';
        this.successRoute = null;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.executeSubmit = new EventEmitter();
        this.isError = false;
        this.actualLoginStep = LoginSteps.Landing;
        this.LoginSteps = LoginSteps;
        this.rememberMe = true;
        this.minLength = 2;
        this.initFormError();
        this.initFormFieldsMessages();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.hasCustomFiledsValidation()) {
            this.form = this._fb.group(this.fieldsValidation);
        }
        else {
            this.initFormFieldsDefault();
            this.initFormFieldsMessagesDefault();
        }
        this.form.valueChanges.subscribe(data => this.onValueChanged(data));
    }
    /**
     * Method called on submit form
     * @param {?} values
     * @return {?}
     */
    onSubmit(values) {
        if (!this.checkRequiredParams()) {
            return false;
        }
        this.settingsService.setProviders(this.providers);
        this.settingsService.csrfDisabled = this.disableCsrf;
        this.disableError();
        const /** @type {?} */ args = new LoginSubmitEvent(this.form);
        this.executeSubmit.emit(args);
        if (args.defaultPrevented) {
            return false;
        }
        else {
            this.performLogin(values);
        }
    }
    /**
     * The method check the error in the form and push the error in the formError object
     * @param {?} data
     * @return {?}
     */
    onValueChanged(data) {
        this.disableError();
        for (let /** @type {?} */ field in this.formError) {
            if (field) {
                this.formError[field] = '';
                let /** @type {?} */ hasError = (this.form.controls[field].errors && data[field] !== '') ||
                    (this.form.controls[field].dirty && !this.form.controls[field].valid);
                if (hasError) {
                    for (let /** @type {?} */ key in this.form.controls[field].errors) {
                        if (key) {
                            this.formError[field] += this._message[field][key] + '';
                        }
                    }
                }
            }
        }
    }
    /**
     * Performe the login service
     * @param {?} values
     * @return {?}
     */
    performLogin(values) {
        this.actualLoginStep = LoginSteps.Checking;
        this.authService.login(values.username, values.password, this.rememberMe)
            .subscribe((token) => {
            const /** @type {?} */ redirectUrl = this.authService.getRedirectUrl();
            this.actualLoginStep = LoginSteps.Welcome;
            this.userPreferences.setStoragePrefix(values.username);
            this.success.emit(new LoginSuccessEvent(token, values.username, values.password));
            if (redirectUrl) {
                this.authService.setRedirectUrl(null);
                this.router.navigate([redirectUrl]);
            }
            else if (this.successRoute) {
                this.router.navigate([this.successRoute]);
            }
        }, (err) => {
            this.actualLoginStep = LoginSteps.Landing;
            this.displayErrorMessage(err);
            this.enableError();
            this.error.emit(new LoginErrorEvent(err));
        }, () => this.logService.info('Login done'));
    }
    /**
     * Check and display the right error message in the UI
     * @param {?} err
     * @return {?}
     */
    displayErrorMessage(err) {
        if (err.error && err.error.crossDomain && err.error.message.indexOf('Access-Control-Allow-Origin') !== -1) {
            this.errorMsg = err.error.message;
        }
        else if (err.status === 403 && err.message.indexOf('Invalid CSRF-token') !== -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CSRF';
        }
        else if (err.status === 403 && err.message.indexOf('The system is currently in read-only mode') !== -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ECM-LICENSE';
        }
        else {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CREDENTIALS';
        }
    }
    /**
     * Check the require parameter
     * @return {?}
     */
    checkRequiredParams() {
        let /** @type {?} */ isAllParamPresent = true;
        if (this.providers === undefined || this.providers === null || this.providers === '') {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-PROVIDERS';
            this.enableError();
            let /** @type {?} */ messageProviders;
            messageProviders = this.translateService.get(this.errorMsg);
            this.error.emit(new LoginErrorEvent(messageProviders.value));
            isAllParamPresent = false;
        }
        return isAllParamPresent;
    }
    /**
     * Add a custom form error for a field
     * @param {?} field
     * @param {?} msg
     * @return {?}
     */
    addCustomFormError(field, msg) {
        this.formError[field] += msg;
    }
    /**
     * Add a custom validation rule error for a field
     * @param {?} field
     * @param {?} ruleId - i.e. required | minlength | maxlength
     * @param {?} msg
     * @param {?=} params
     * @return {?}
     */
    addCustomValidationError(field, ruleId, msg, params) {
        if (params) {
            this.translateService.get(msg, params).subscribe((res) => {
                this._message[field][ruleId] = res;
            });
        }
        else {
            this._message[field][ruleId] = msg;
        }
    }
    /**
     * Display and hide the password value.
     * @return {?}
     */
    toggleShowPassword() {
        this.isPasswordShow = !this.isPasswordShow;
        this.elementRef.nativeElement.querySelector('#password').type = this.isPasswordShow ? 'text' : 'password';
    }
    /**
     * The method return if a field is valid or not
     * @param {?} field
     * @return {?}
     */
    isErrorStyle(field) {
        return !field.valid && field.dirty && !field.pristine;
    }
    /**
     * Trim username
     * @param {?} event
     * @return {?}
     */
    trimUsername(event) {
        event.target.value = event.target.value.trim();
    }
    /**
     * Default formError values
     * @return {?}
     */
    initFormError() {
        this.formError = {
            'username': '',
            'password': ''
        };
    }
    /**
     * Init form fields messages
     * @return {?}
     */
    initFormFieldsMessages() {
        this._message = {
            'username': {},
            'password': {}
        };
    }
    /**
     * Default form fields messages
     * @return {?}
     */
    initFormFieldsMessagesDefault() {
        this._message = {
            'username': {
                'required': 'LOGIN.MESSAGES.USERNAME-REQUIRED'
            },
            'password': {
                'required': 'LOGIN.MESSAGES.PASSWORD-REQUIRED'
            }
        };
        this.translateService.get('LOGIN.MESSAGES.USERNAME-MIN', { minLength: this.minLength }).subscribe((res) => {
            this._message['username']['minlength'] = res;
        });
    }
    /**
     * @return {?}
     */
    initFormFieldsDefault() {
        this.form = this._fb.group({
            username: ['', Validators.required],
            password: ['', Validators.required]
        });
    }
    /**
     * Disable the error flag
     * @return {?}
     */
    disableError() {
        this.isError = false;
        this.initFormError();
    }
    /**
     * Enable the error flag
     * @return {?}
     */
    enableError() {
        this.isError = true;
    }
    /**
     * @return {?}
     */
    hasCustomFiledsValidation() {
        return this.fieldsValidation !== undefined;
    }
}
LoginComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login',
                template: `
      <div class="adf-login-content" [style.background-image]="'url(' + backgroundImageUrl + ')'">
           <div class="ie11FixerParent">
               <div class="ie11FixerChild">

                  <mat-card class="adf-login-card-wide">
                      <form [formGroup]="form" (submit)="onSubmit(form.value)">

                          <mat-card-header>
                              <mat-card-title>
                                  <div class="adf-alfresco-logo">
                                      <!--HEADER TEMPLATE-->
                                      <ng-template *ngIf="headerTemplate"
                                                  ngFor [ngForOf]="[data]"
                                                  [ngForTemplate]="headerTemplate">
                                      </ng-template>
                                      <img *ngIf="!headerTemplate" class="adf-img-logo" [src]="logoImageUrl"
                                          alt="{{'LOGIN.LOGO' | translate }}">
                                  </div>
                              </mat-card-title>
                          </mat-card-header>

                          <mat-card-content class="adf-login-controls">

                              <!--ERRORS AREA-->
                              <div class="adf-error-container">
                                  <div *ngIf="isError" id="login-error" data-automation-id="login-error"
                                      class="error  adf-error-message">
                                      <mat-icon class="error-icon">warning</mat-icon>
                                      <span class="login-error-message">{{errorMsg | translate }}</span>
                                  </div>
                              </div>

                              <!--USERNAME FIELD-->
                              <div class="adf-login__field" [ngClass]="{'is-invalid': isErrorStyle(form.controls.username)}">
                                  <mat-form-field class="adf-full-width" floatPlaceholder="never" color="primary">
                                      <input matInput placeholder="{{'LOGIN.LABEL.USERNAME' | translate }}"
                                          type="text"
                                          class="adf-full-width"
                                          [formControl]="form.controls['username']"
                                          autocapitalize="none"
                                          id="username"
                                          data-automation-id="username"
                                          (blur)="trimUsername($event)"
                                          tabindex="1">
                                  </mat-form-field>

                                  <span class="adf-login-validation" for="username" *ngIf="formError.username">
                                      <span id="username-error" class="adf-login-error" data-automation-id="username-error">{{formError.username | translate }}</span>
                                  </span>
                              </div>

                              <!--PASSWORD FIELD-->
                              <div class="adf-login__field">
                                  <mat-form-field class="adf-full-width" floatPlaceholder="never" color="primary">
                                      <input matInput placeholder="{{'LOGIN.LABEL.PASSWORD' | translate }}"
                                          type="password"
                                          [formControl]="form.controls['password']"
                                          id="password"
                                          data-automation-id="password"
                                          tabindex="2">
                                      <mat-icon *ngIf="isPasswordShow" matSuffix class="adf-login-password-icon"
                                              data-automation-id="hide_password" (click)="toggleShowPassword()">visibility
                                      </mat-icon>
                                      <mat-icon *ngIf="!isPasswordShow" matSuffix class="adf-login-password-icon"
                                              data-automation-id="show_password" (click)="toggleShowPassword()">visibility_off
                                      </mat-icon>
                                  </mat-form-field>
                                  <span class="adf-login-validation" for="password" *ngIf="formError.password">
                                      <span id="password-required" class="adf-login-error"
                                          data-automation-id="password-required">{{formError.password | translate }}</span>
                                  </span>
                              </div>

                              <!--CUSTOM CONTENT-->
                              <ng-content></ng-content>

                              <br>
                              <button type="submit" id="login-button" tabindex="3"
                                      class="adf-login-button"
                                      mat-raised-button color="primary"
                                      [class.isChecking]="actualLoginStep === LoginSteps.Checking"
                                      [class.isWelcome]="actualLoginStep === LoginSteps.Welcome"
                                      data-automation-id="login-button" [disabled]="!form.valid">
                            
                                  <span *ngIf="actualLoginStep === LoginSteps.Landing" class="adf-login-button-label">{{ 'LOGIN.BUTTON.LOGIN' | translate }}</span>

                                  <div *ngIf="actualLoginStep === LoginSteps.Checking" class="adf-interactive-login-label">
                                      <span class="adf-login-button-label">{{ 'LOGIN.BUTTON.CHECKING' | translate }}</span>
                                      <div class="adf-login-spinner-container">
                                          <mat-spinner id="checking-spinner" class="adf-login-checking-spinner" [diameter]="25"></mat-spinner>
                                      </div>
                                  </div>


                                  <div *ngIf="actualLoginStep === LoginSteps.Welcome" class="adf-interactive-login-label">
                                      <span class="adf-login-button-label">{{ 'LOGIN.BUTTON.WELCOME' | translate }}</span>
                                      <mat-icon class="welcome-icon">done</mat-icon>
                                  </div>

                              </button>
                              <div *ngIf="showRememberMe" class="adf-login__remember-me">
                                  <mat-checkbox id="adf-login-remember" color="primary" class="adf-login-rememberme" [checked]="rememberMe"
                                              (change)="rememberMe = !rememberMe">{{ 'LOGIN.LABEL.REMEMBER' | translate }}
                                  </mat-checkbox>
                              </div>
                          </mat-card-content>
                          <mat-card-actions *ngIf="footerTemplate || showLoginActions">

                              <div class="adf-login-action-container">
                                  <!--FOOTER TEMPLATE-->
                                  <ng-template *ngIf="footerTemplate"
                                              ngFor [ngForOf]="[data]"
                                              [ngForTemplate]="footerTemplate">
                                  </ng-template>
                                  <div class="adf-login-action" *ngIf="!footerTemplate && showLoginActions">
                                      <div id="adf-login-action-left" class="adf-login-action-left">
                                          <a href="{{needHelpLink}}">{{'LOGIN.ACTION.HELP' | translate }}</a>
                                      </div>
                                      <div id="adf-login-action-right" class="adf-login-action-right">
                                          <a href="{{registerLink}}">{{'LOGIN.ACTION.REGISTER' | translate }}</a>
                                      </div>
                                  </div>
                              </div>
                          </mat-card-actions>

                      </form>
                  </mat-card>

                  <div class="copyright" data-automation-id="login-copyright">
                      {{ copyrightText }}
                  </div>

              </div>
           </div>
      </div>
    `,
                styles: [`

    `],
                host: { '(blur)': 'onBlur($event)' },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
LoginComponent.ctorParameters = () => [
    { type: FormBuilder, },
    { type: AuthenticationService, },
    { type: SettingsService, },
    { type: TranslationService, },
    { type: LogService, },
    { type: ElementRef, },
    { type: Router, },
    { type: UserPreferencesService, },
];
LoginComponent.propDecorators = {
    'showRememberMe': [{ type: Input },],
    'showLoginActions': [{ type: Input },],
    'needHelpLink': [{ type: Input },],
    'registerLink': [{ type: Input },],
    'logoImageUrl': [{ type: Input },],
    'backgroundImageUrl': [{ type: Input },],
    'copyrightText': [{ type: Input },],
    'providers': [{ type: Input },],
    'fieldsValidation': [{ type: Input },],
    'disableCsrf': [{ type: Input },],
    'successRoute': [{ type: Input },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'executeSubmit': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginFooterDirective {
    /**
     * @param {?} alfrescoLoginComponent
     */
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.alfrescoLoginComponent.footerTemplate = this.template;
    }
}
LoginFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'login-footer'
            },] },
];
/**
 * @nocollapse
 */
LoginFooterDirective.ctorParameters = () => [
    { type: LoginComponent, },
];
LoginFooterDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginHeaderDirective {
    /**
     * @param {?} alfrescoLoginComponent
     */
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.alfrescoLoginComponent.headerTemplate = this.template;
    }
}
LoginHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'login-header'
            },] },
];
/**
 * @nocollapse
 */
LoginHeaderDirective.ctorParameters = () => [
    { type: LoginComponent, },
];
LoginHeaderDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginModule {
}
LoginModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    LoginComponent,
                    LoginFooterDirective,
                    LoginHeaderDirective
                ],
                exports: [
                    [
                        LoginComponent,
                        LoginFooterDirective,
                        LoginHeaderDirective
                    ]
                ]
            },] },
];
/**
 * @nocollapse
 */
LoginModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfinitePaginationComponent {
    constructor() {
        this.pageSize = InfinitePaginationComponent.DEFAULT_PAGE_SIZE;
        this.isLoading = false;
        this.loadMore = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.pagination) {
            this.pagination = InfinitePaginationComponent.DEFAULT_PAGINATION;
        }
    }
    /**
     * @return {?}
     */
    onLoadMore() {
        this.pagination.skipCount += this.pageSize;
        this.loadMore.next(this.pagination);
    }
}
InfinitePaginationComponent.DEFAULT_PAGE_SIZE = 25;
InfinitePaginationComponent.DEFAULT_PAGINATION = {
    skipCount: 0,
    hasMoreItems: false
};
InfinitePaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-infinite-pagination',
                host: { 'class': 'infinite-adf-pagination' },
                template: `
      <div *ngIf="pagination?.hasMoreItems" class="adf-infinite-pagination">
          <button mat-button
              *ngIf="!isLoading"
              class="adf-infinite-pagination-load-more"
              (click)="onLoadMore($event)"
              data-automation-id="adf-infinite-pagination-button">
                  <ng-content></ng-content>
          </button>

          <mat-progress-bar *ngIf="isLoading"
              mode="indeterminate"
              class="adf-infinite-pagination-spinner"
              data-automation-id="adf-infinite-pagination-spinner"></mat-progress-bar>
      </div>
    `,
                styles: [`
      .adf-infinite-pagination {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-pack: distribute;
            justify-content: space-around;
        min-height: 56px; }
        .adf-infinite-pagination-load-more {
          margin-bottom: 10px;
          margin-top: 10px; }
    `],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
InfinitePaginationComponent.ctorParameters = () => [];
InfinitePaginationComponent.propDecorators = {
    'pagination': [{ type: Input },],
    'pageSize': [{ type: Input },],
    'isLoading': [{ type: Input, args: ['loading',] },],
    'loadMore': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PaginationComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.supportedPageSizes = [5, 25, 50, 100];
        this.change = new EventEmitter();
        this.changePageNumber = new EventEmitter();
        this.changePageSize = new EventEmitter();
        this.nextPage = new EventEmitter();
        this.prevPage = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.target) {
            this.supportedPageSizes = this.target.supportedPageSizes;
            this.paginationSubscription = this.target.pagination.subscribe(page => {
                this.pagination = page;
                this.cdr.detectChanges();
            });
        }
        if (!this.pagination) {
            this.pagination = PaginationComponent.DEFAULT_PAGINATION;
        }
    }
    /**
     * @return {?}
     */
    get lastPage() {
        const { maxItems, totalItems } = this.pagination;
        return (totalItems && maxItems)
            ? Math.ceil(totalItems / maxItems)
            : 1;
    }
    /**
     * @return {?}
     */
    get current() {
        const { maxItems, skipCount } = this.pagination;
        return (skipCount && maxItems)
            ? Math.floor(skipCount / maxItems) + 1
            : 1;
    }
    /**
     * @return {?}
     */
    get isLastPage() {
        return this.current === this.lastPage;
    }
    /**
     * @return {?}
     */
    get isFirstPage() {
        return this.current === 1;
    }
    /**
     * @return {?}
     */
    get next() {
        return this.isLastPage ? this.current : this.current + 1;
    }
    /**
     * @return {?}
     */
    get previous() {
        return this.isFirstPage ? 1 : this.current - 1;
    }
    /**
     * @return {?}
     */
    get hasItems() {
        return this.pagination && this.pagination.count > 0;
    }
    /**
     * @return {?}
     */
    get range() {
        const { skipCount, maxItems, totalItems } = this.pagination;
        const { isLastPage } = this;
        const /** @type {?} */ start = totalItems ? skipCount + 1 : 0;
        const /** @type {?} */ end = isLastPage ? totalItems : skipCount + maxItems;
        return [start, end];
    }
    /**
     * @return {?}
     */
    get pages() {
        return Array(this.lastPage)
            .fill('n')
            .map((item, index) => (index + 1));
    }
    /**
     * @return {?}
     */
    goNext() {
        if (this.hasItems) {
            const /** @type {?} */ maxItems = this.pagination.maxItems;
            const /** @type {?} */ skipCount = (this.next - 1) * maxItems;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.NEXT_PAGE, {
                skipCount,
                maxItems
            });
        }
    }
    /**
     * @return {?}
     */
    goPrevious() {
        if (this.hasItems) {
            const /** @type {?} */ maxItems = this.pagination.maxItems;
            const /** @type {?} */ skipCount = (this.previous - 1) * maxItems;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.PREV_PAGE, {
                skipCount,
                maxItems
            });
        }
    }
    /**
     * @param {?} pageNumber
     * @return {?}
     */
    onChangePageNumber(pageNumber) {
        if (this.hasItems) {
            const /** @type {?} */ maxItems = this.pagination.maxItems;
            const /** @type {?} */ skipCount = (pageNumber - 1) * maxItems;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.CHANGE_PAGE_NUMBER, {
                skipCount,
                maxItems
            });
        }
    }
    /**
     * @param {?} maxItems
     * @return {?}
     */
    onChangePageSize(maxItems) {
        this.handlePaginationEvent(PaginationComponent.ACTIONS.CHANGE_PAGE_SIZE, {
            skipCount: 0,
            maxItems
        });
    }
    /**
     * @param {?} action
     * @param {?} params
     * @return {?}
     */
    handlePaginationEvent(action, params) {
        const { NEXT_PAGE, PREV_PAGE, CHANGE_PAGE_NUMBER, CHANGE_PAGE_SIZE } = PaginationComponent.ACTIONS;
        const { change, changePageNumber, changePageSize, nextPage, prevPage, pagination } = this;
        const /** @type {?} */ data = Object.assign({}, pagination, params);
        if (action === NEXT_PAGE) {
            nextPage.emit(data);
        }
        if (action === PREV_PAGE) {
            prevPage.emit(data);
        }
        if (action === CHANGE_PAGE_NUMBER) {
            changePageNumber.emit(data);
        }
        if (action === CHANGE_PAGE_SIZE) {
            changePageSize.emit(data);
        }
        change.emit(params);
        if (this.target) {
            this.target.updatePagination(params);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.paginationSubscription) {
            this.paginationSubscription.unsubscribe();
        }
    }
}
PaginationComponent.DEFAULT_PAGINATION = {
    skipCount: 0,
    maxItems: 25,
    totalItems: 0
};
PaginationComponent.ACTIONS = {
    NEXT_PAGE: 'NEXT_PAGE',
    PREV_PAGE: 'PREV_PAGE',
    CHANGE_PAGE_SIZE: 'CHANGE_PAGE_SIZE',
    CHANGE_PAGE_NUMBER: 'CHANGE_PAGE_NUMBER'
};
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pagination',
                host: { 'class': 'adf-pagination' },
                template: `
      <ng-container *ngIf="hasItems">
          <div class="adf-pagination__block adf-pagination__range-block">
              <span class="adf-pagination__range">
                  {{
                      'CORE.PAGINATION.ITEMS_RANGE' | translate: {
                          range: range.join('-'),
                          total: pagination.totalItems
                      }
                  }}
              </span>
          </div>

          <div class="adf-pagination__block adf-pagination__perpage-block">
              <span>
                  {{ 'CORE.PAGINATION.ITEMS_PER_PAGE' | translate }}
              </span>

              <span class="adf-pagination__max-items">
                  {{ pagination.maxItems }}
              </span>

              <button mat-icon-button [matMenuTriggerFor]="pageSizeMenu">
                  <mat-icon>arrow_drop_down</mat-icon>
              </button>

              <mat-menu #pageSizeMenu="matMenu">
                  <button
                      mat-menu-item
                      *ngFor="let pageSize of supportedPageSizes"
                      (click)="onChangePageSize(pageSize)">
                      {{ pageSize }}
                  </button>
              </mat-menu>
          </div>

          <div class="adf-pagination__block adf-pagination__actualinfo-block">
              <span class="adf-pagination__current-page">
                  {{ 'CORE.PAGINATION.CURRENT_PAGE' | translate: { number: current } }}
              </span>

              <button
                  mat-icon-button
                  [matMenuTriggerFor]="pagesMenu"
                  *ngIf="pages.length > 1">
                  <mat-icon>arrow_drop_down</mat-icon>
              </button>

              <span class="adf-pagination__total-pages">
                  {{ 'CORE.PAGINATION.TOTAL_PAGES' | translate: { total: pages.length } }}
              </span>

              <mat-menu #pagesMenu="matMenu" class="adf-pagination__page-selector">
                  <button
                      mat-menu-item
                      *ngFor="let pageNumber of pages"
                      (click)="onChangePageNumber(pageNumber)">
                      {{ pageNumber }}
                  </button>
              </mat-menu>
          </div>

          <div class="adf-pagination__block adf-pagination__controls-block">
              <button
                  class="adf-pagination__previous-button"
                  mat-icon-button
                  [disabled]="isFirstPage"
                  (click)="goPrevious()">
                  <mat-icon>keyboard_arrow_left</mat-icon>
              </button>

              <button
                  class="adf-pagination__next-button"
                  mat-icon-button
                  [disabled]="isLastPage"
                  (click)="goNext()">
                  <mat-icon>keyboard_arrow_right</mat-icon>
              </button>
          </div>
      </ng-container>
    `,
                styles: [`

    `],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
PaginationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
PaginationComponent.propDecorators = {
    'target': [{ type: Input },],
    'supportedPageSizes': [{ type: Input },],
    'pagination': [{ type: Input },],
    'change': [{ type: Output },],
    'changePageNumber': [{ type: Output },],
    'changePageSize': [{ type: Output },],
    'nextPage': [{ type: Output },],
    'prevPage': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PaginationModule {
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ],
                exports: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
PaginationModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HostSettingsComponent {
    /**
     * @param {?} settingsService
     * @param {?} storage
     * @param {?} logService
     * @param {?} translationService
     */
    constructor(settingsService, storage, logService, translationService) {
        this.settingsService = settingsService;
        this.storage = storage;
        this.logService = logService;
        this.translationService = translationService;
        this.HOST_REGEX = '^(http|https):\/\/.*[^/]$';
        this.urlFormControlEcm = new FormControl('', [Validators.required, Validators.pattern(this.HOST_REGEX)]);
        this.urlFormControlBpm = new FormControl('', [Validators.required, Validators.pattern(this.HOST_REGEX)]);
        this.providers = 'ALL';
        this.error = new EventEmitter();
        this.ecmHostTmp = this.ecmHost = storage.getItem('ecmHost') || this.settingsService.ecmHost;
        this.bpmHostTmp = this.bpmHost = storage.getItem('bpmHost') || this.settingsService.bpmHost;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeECMHost(event) {
        let /** @type {?} */ value = ((event.target)).value.trim();
        if (value && this.isValidUrl(value)) {
            this.logService.info(`ECM host: ${value}`);
            this.ecmHostTmp = value;
        }
        else {
            this.translationService.get('CORE.HOST_SETTING.CS_URL_ERROR').subscribe((message) => {
                this.error.emit(message);
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeBPMHost(event) {
        let /** @type {?} */ value = ((event.target)).value.trim();
        if (value && this.isValidUrl(value)) {
            this.logService.info(`BPM host: ${value}`);
            this.bpmHostTmp = value;
        }
        else {
            this.translationService.get('CORE.HOST_SETTING.PS_URL_ERROR').subscribe((message) => {
                this.error.emit(message);
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    save(event) {
        if (this.bpmHost !== this.bpmHostTmp) {
            this.storage.setItem(`bpmHost`, this.bpmHostTmp);
        }
        if (this.ecmHost !== this.ecmHostTmp) {
            this.storage.setItem(`ecmHost`, this.ecmHostTmp);
        }
        window.location.href = '/';
    }
    /**
     * @param {?} url
     * @return {?}
     */
    isValidUrl(url) {
        return /^(http|https):\/\/.*/.test(url);
    }
}
HostSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-host-settings',
                template: `
      <div class="adf-setting-container">
          <div class="adf-setting-card-padding"></div>
          <mat-toolbar color="primary" class="adf-setting-toolbar">
              <h3>{{'CORE.HOST_SETTINGS.TITLE' | translate}}</h3>
          </mat-toolbar>

          <mat-card class="adf-setting-card">
              <div *ngIf="providers==='ALL' || providers==='ECM'">
                  <mat-card-header>
                      <mat-card-subtitle>{{'CORE.HOST_SETTINGS.CS-HOST' | translate }}</mat-card-subtitle>
                  </mat-card-header>
                  <mat-card-content>
                      <mat-form-field class="full-width">
                          <mat-icon class="adf-CORE.HOST_SETTINGS-link-icon" matPrefix>link</mat-icon>
                          <input matInput
                                 [formControl]="urlFormControlEcm"
                                 data-automation-id="ecmHost"
                                 type="text"
                                 (change)="onChangeECMHost($event)"
                                 tabindex="2"
                                 id="ecmHost"
                                 value="{{ecmHost}}"
                                 placeholder="http(s)://host|ip:port(/path)">
                          <mat-error *ngIf="urlFormControlEcm.hasError('pattern')">
                              {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}
                          </mat-error>
                      </mat-form-field>
                      <p>
                  </mat-card-content>
              </div>
              <p>
              <div *ngIf="providers==='ALL' || providers==='BPM'">
                  <mat-card-header>
                      <mat-card-subtitle>{{'CORE.HOST_SETTINGS.BP-HOST' | translate }}</mat-card-subtitle>
                  </mat-card-header>
                  <mat-card-content>

                      <mat-form-field class="full-width">
                          <mat-icon class="adf-CORE.HOST_SETTINGS-link-icon" matPrefix>link</mat-icon>
                          <input matInput
                                 [formControl]="urlFormControlBpm"
                                 data-automation-id="bpmHost"
                                 type="text"
                                 (change)="onChangeBPMHost($event)"
                                 tabindex="2"
                                 id="bpmHost"
                                 value="{{bpmHost}}"
                                 placeholder="http(s)://host|ip:port(/path)">
                          <mat-error *ngIf="urlFormControlBpm.hasError('pattern')">
                              {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}
                          </mat-error>
                      </mat-form-field>
                  </mat-card-content>
              </div>
              <mat-card-actions class="adf-CORE.HOST_SETTINGS-actions">

                  <button mat-button onclick="window.history.back()" color="primary">
                      {{'CORE.HOST_SETTINGS.BACK' | translate }}
                  </button>

                  <button mat-raised-button (click)="save($event)"
                          [disabled]="urlFormControlBpm.hasError('pattern') || urlFormControlEcm.hasError('pattern')"
                          color="primary">
                      {{'CORE.HOST_SETTINGS.APPLY' | translate }}
                  </button>

              </mat-card-actions>
          </mat-card>
          <div class="adf-setting-card-padding"></div>
      </div>
    `,
                host: {
                    'class': 'adf-host-settings'
                },
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
HostSettingsComponent.ctorParameters = () => [
    { type: SettingsService, },
    { type: StorageService, },
    { type: LogService, },
    { type: TranslationService, },
];
HostSettingsComponent.propDecorators = {
    'providers': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HostSettingsModule {
}
HostSettingsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    HostSettingsComponent
                ],
                exports: [
                    HostSettingsComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
HostSettingsModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarDividerComponent {
}
ToolbarDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-divider',
                template: '<div></div>',
                host: { 'class': 'adf-toolbar-divider' },
                styles: [`
        .adf-toolbar-divider > div {
            height: 24px;
            width: 1px;
            background: rgba(0, 0, 0, 0.26);
            margin-left: 5px;
            margin-right: 5px;
        }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
ToolbarDividerComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarTitleComponent {
}
ToolbarTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-title',
                template: '<ng-content></ng-content>',
                host: { 'class': 'adf-toolbar-title' }
            },] },
];
/**
 * @nocollapse
 */
ToolbarTitleComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarComponent {
    constructor() {
        this.title = '';
    }
}
ToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar',
                template: `
      <mat-toolbar [color]="color">
          <span *ngIf="title">{{ title }}</span>
          <ng-content select="adf-toolbar-title"></ng-content>
          <span class="adf-toolbar--spacer"></span>
          <ng-content></ng-content>
      </mat-toolbar>
    `,
                styles: [`

    `],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-toolbar' }
            },] },
];
/**
 * @nocollapse
 */
ToolbarComponent.ctorParameters = () => [];
ToolbarComponent.propDecorators = {
    'title': [{ type: Input },],
    'color': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarModule {
}
ToolbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ],
                exports: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
ToolbarModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BpmUserModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.apps = obj.apps;
            this.capabilities = obj.capabilities;
            this.company = obj.company;
            this.created = obj.created;
            this.email = obj.email;
            this.externalId = obj.externalId;
            this.firstName = obj.firstName;
            this.lastName = obj.lastName;
            this.fullname = obj.fullname;
            this.fullNameDisplay = obj ? this.formatValue(obj.firstName).trim() + ' ' + this.formatValue(obj.lastName).trim() : null;
            this.groups = obj.groups;
            this.id = obj.id;
            this.lastUpdate = obj.lastUpdate;
            this.latestSyncTimeStamp = obj.latestSyncTimeStamp;
            this.password = obj.password;
            this.pictureId = obj.pictureId;
            this.status = obj.status;
            this.tenantId = obj.tenantId;
            this.tenantName = obj.tenantName;
            this.tenantPictureId = obj.tenantPictureId;
            this.type = obj.type;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        return value && value !== 'null' ? value : '';
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EcmUserModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.firstName = obj && obj.firstName;
        this.lastName = obj && obj.lastName;
        this.fullNameDisplay = obj ? this.formatValue(obj.firstName).trim() + ' ' + this.formatValue(obj.lastName).trim() : null;
        this.description = obj && obj.description || null;
        this.avatarId = obj && obj.avatarId || null;
        this.email = obj && obj.email || null;
        this.skypeId = obj && obj.skypeId;
        this.googleId = obj && obj.googleId;
        this.instantMessageId = obj && obj.instantMessageId;
        this.jobTitle = obj && obj.jobTitle || null;
        this.location = obj && obj.location || null;
        this.company = obj && obj.company;
        this.mobile = obj && obj.mobile;
        this.telephone = obj && obj.telephone;
        this.statusUpdatedAt = obj && obj.statusUpdatedAt;
        this.userStatus = obj && obj.userStatus;
        this.enabled = obj && obj.enabled;
        this.emailNotificationsEnabled = obj && obj.emailNotificationsEnabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        return value && value !== 'null' ? value : '';
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * BPMUserService retrieve all the information of an Ecm user.
 *
 */
class BpmUserService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * get Current User information for BPM
     * @return {?}
     */
    getCurrentUserInfo() {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.profileApi.getProfile())
            .map((data) => /** @type {?} */ (data))
            .catch(err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getCurrentUserProfileImage() {
        return this.apiService.getInstance().activiti.profileApi.getProfilePictureUrl();
    }
    /**
     * Throw the error
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // in a real world app, we may send the error to some remote logging infrastructure
        // instead of just logging it to the console
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
BpmUserService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
BpmUserService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EcmUserService {
    /**
     * @param {?} apiService
     * @param {?} contentService
     * @param {?} logService
     */
    constructor(apiService, contentService, logService) {
        this.apiService = apiService;
        this.contentService = contentService;
        this.logService = logService;
    }
    /**
     * get User Information via ECM
     * @param {?} userName - the user name
     * @return {?}
     */
    getUserInfo(userName) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.peopleApi.getPerson(userName))
            .map(data => /** @type {?} */ (data['entry']))
            .catch(err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getCurrentUserInfo() {
        return this.getUserInfo('-me-');
    }
    /**
     * @param {?} avatarId
     * @return {?}
     */
    getUserProfileImage(avatarId) {
        if (avatarId) {
            let /** @type {?} */ nodeObj = { entry: { id: avatarId } };
            return this.contentService.getContentUrl(nodeObj);
        }
    }
    /**
     * Throw the error
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // in a real world app, we may send the error to some remote logging infrastructure
        // instead of just logging it to the console
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
EcmUserService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
EcmUserService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: ContentService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserInfoComponent {
    /**
     * @param {?} ecmUserService
     * @param {?} bpmUserService
     * @param {?} authService
     */
    constructor(ecmUserService, bpmUserService, authService) {
        this.ecmUserService = ecmUserService;
        this.bpmUserService = bpmUserService;
        this.authService = authService;
        this.ecmBackgroundImage = './assets/images/ecm-background.png';
        this.bpmBackgroundImage = './assets/images/bpm-background.png';
        this.menuPositionX = 'after';
        this.menuPositionY = 'below';
        this.showName = true;
        this.namePosition = 'right';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.getUserInfo();
    }
    /**
     * @return {?}
     */
    getUserInfo() {
        this.loadEcmUserInfo();
        this.loadBpmUserInfo();
    }
    /**
     * @return {?}
     */
    isLoggedIn() {
        return this.authService.isLoggedIn();
    }
    /**
     * @return {?}
     */
    loadEcmUserInfo() {
        if (this.authService.isEcmLoggedIn()) {
            this.ecmUserService.getCurrentUserInfo()
                .subscribe((res) => {
                this.ecmUser = new EcmUserModel(res);
                this.getEcmAvatar();
            });
        }
        else {
            this.ecmUser = null;
            this.ecmUserImage = null;
        }
    }
    /**
     * @return {?}
     */
    loadBpmUserInfo() {
        if (this.authService.isBpmLoggedIn()) {
            this.bpmUserService.getCurrentUserInfo()
                .subscribe((res) => {
                this.bpmUser = new BpmUserModel(res);
            });
            this.bpmUserImage = this.bpmUserService.getCurrentUserProfileImage();
        }
        else {
            this.bpmUser = null;
            this.bpmUserImage = null;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    stopClosing(event) {
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    getEcmAvatar() {
        this.ecmUserImage = this.ecmUserService.getUserProfileImage(this.ecmUser.avatarId);
    }
    /**
     * @return {?}
     */
    showOnRight() {
        return this.namePosition === 'right';
    }
    /**
     * @return {?}
     */
    hasBpmUserPictureId() {
        return !!this.bpmUser.pictureId;
    }
    /**
     * @return {?}
     */
    hasEcmUserAvatarId() {
        return !!this.ecmUser.avatarId;
    }
}
UserInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-userinfo',
                styles: [`

    `],
                template: `
      <div id="userinfo_container"
          [class.adf-userinfo-name-right]="showOnRight()"
          class="adf-userinfo-container" *ngIf="isLoggedIn()">
          <span *ngIf="ecmUser && showName" id="adf-userinfo-ecm-name-display"
                class="adf-userinfo-name">{{ecmUser.fullNameDisplay}}</span>
          <span *ngIf="bpmUser && !ecmUser && showName" id="adf-userinfo-bpm-name-display"
                class="adf-userinfo-name">{{bpmUser.fullNameDisplay}}</span>
          <button mat-button [matMenuTriggerFor]="menu" class="adf-userinfo-menu_button">
              <div class="adf-userinfo-button-profile" id="user-profile" data-automation-id="user-profile">
                  <div *ngIf="bpmUser && !ecmUser" id="bpm-user-image">
                      <div *ngIf="!hasBpmUserPictureId()" [outerHTML]="bpmUser | usernameInitials:'adf-userinfo-pic'"></div>
                      <div *ngIf="hasBpmUserPictureId()" class="adf-userinfo-profile-container">
                          <img id="logged-user-img" [src]="bpmUserImage" alt="user-info-profile-button"
                              class="adf-userinfo-profile-image"/>
                      </div>
                  </div>
                  <div *ngIf="ecmUser" id="ecm-user-image">
                          <div *ngIf="!hasEcmUserAvatarId()" [outerHTML]="ecmUser | usernameInitials:'adf-userinfo-pic'"></div>
                          <div *ngIf="hasEcmUserAvatarId()" class="adf-userinfo-profile-container">
                              <img id="logged-user-img" [src]="ecmUserImage" alt="user-info-profile-button"
                                  class="adf-userinfo-profile-image"/>
                          </div>
                  </div>
          </div>
      </button>
          <mat-menu #menu="matMenu" id="user-profile-lists" [xPosition]="menuPositionX" [yPosition]="menuPositionY" [overlapTrigger]="false" class="adf-userinfo-menu">
              <mat-tab-group id="tab-group-env" (click)="stopClosing($event)"
                  class="adf-userinfo-tab" [class.adf-hide-tab]="!bpmUser || !ecmUser">
                  <mat-tab id="ecm-panel" label="{{ 'USER_PROFILE.TAB.CS' | translate }}" *ngIf="ecmUser">
                      <mat-card class="adf-userinfo-card">
                          <mat-card-header class="adf-userinfo-card-header" [style.background-image]="'url(' + ecmBackgroundImage + ')'">
                              <div *ngIf="!hasEcmUserAvatarId()" [outerHTML]="ecmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'"></div>
                              <div *ngIf="hasEcmUserAvatarId()" class="adf-userinfo-profile-container adf-hide-small">
                                  <img class="adf-userinfo-profile-picture" id="ecm-user-detail-image"
                                      alt="ecm-profile-image" [src]="ecmUserImage" />
                              </div>
                             <div class="adf-userinfo-title" id="ecm-username">{{ecmUser.fullNameDisplay}}</div>
                          </mat-card-header>
                          <mat-card-content>
                              <div class="adf-userinfo-supporting-text">
                                      <div class="adf-userinfo-detail">
                                          <span id="ecm-full-name" class="adf-userinfo__detail-title">{{ecmUser.fullNameDisplay}}</span>
                                          <span class="adf-userinfo__detail-profile" id="ecm-email"> {{ecmUser.email}} </span>
                                      </div>
                                      <div class="adf-userinfo-detail">
                                          <span class="adf-userinfo__secondary-info">
                                              {{ 'USER_PROFILE.LABELS.ECM.JOB_TITLE' | translate }}
                                              <span id="ecm-job-title" class="adf-userinfo__detail-profile"> {{ ecmUser.jobTitle ? ecmUser.jobTitle : 'N/A' }} </span>
                                          </span>
                                      </div>
                              </div>
                          </mat-card-content>
                      </mat-card>
                  </mat-tab>
                  <mat-tab id="bpm-panel" label="{{ 'USER_PROFILE.TAB.PS' | translate }}" *ngIf="bpmUser">
                  <mat-card class="adf-userinfo-card">
                      <mat-card-header class="adf-userinfo-card-header" [style.background-image]="'url(' + bpmBackgroundImage + ')'">
                          <div *ngIf="!hasBpmUserPictureId()" [outerHTML]="bpmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'"></div>
                          <img *ngIf="hasBpmUserPictureId()" class="adf-userinfo-profile-picture adf-hide-small" id="bpm-user-detail-image"
                                  alt="bpm-profile-image" [src]="bpmUserImage"/>
                         <div class="adf-userinfo-title" id="bpm-username">{{bpmUser.fullNameDisplay}}</div>
                      </mat-card-header>
                      <mat-card-content>
                          <div class="adf-userinfo-supporting-text">
                                  <div class="adf-userinfo-detail">
                                      <span id="bpm-full-name" class="adf-userinfo__detail-title">{{ bpmUser.fullNameDisplay }}</span>
                                      <span class="adf-userinfo__detail-profile" id="bpm-email"> {{bpmUser.email}} </span>
                                  </div>
                                  <div class="adf-userinfo-detail">
                                      <span id="bpm-tenant" class="adf-userinfo__secondary-info">
                                          {{ 'USER_PROFILE.LABELS.BPM.TENANT' | translate }}
                                          <span class="adf-userinfo__detail-profile">{{ bpmUser.tenantName ? bpmUser.tenantName : '' }}</span>
                                      </span>
                                  </div>
                          </div>
                      </mat-card-content>
                  </mat-card>
                  </mat-tab>
              </mat-tab-group>
          </mat-menu>
      </div>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
UserInfoComponent.ctorParameters = () => [
    { type: EcmUserService, },
    { type: BpmUserService, },
    { type: AuthenticationService, },
];
UserInfoComponent.propDecorators = {
    'ecmBackgroundImage': [{ type: Input },],
    'bpmBackgroundImage': [{ type: Input },],
    'menuPositionX': [{ type: Input },],
    'menuPositionY': [{ type: Input },],
    'showName': [{ type: Input },],
    'namePosition': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserInfoModule {
}
UserInfoModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    PipeModule
                ],
                declarations: [
                    UserInfoComponent
                ],
                providers: [
                    EcmUserService,
                    BpmUserService
                ],
                exports: [
                    UserInfoComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
UserInfoModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ImgViewerComponent {
    /**
     * @param {?} contentService
     */
    constructor(contentService) {
        this.contentService = contentService;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
}
ImgViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-img-viewer',
                template: `
      <div class="image-container">
          <img id="viewer-image" [src]="urlFile" [alt]="nameFile" />
      </div>
    `,
                styles: [`
      .adf-img-viewer .image-container {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        text-align: center;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
            -ms-flex-direction: row;
                flex-direction: row;
        -webkit-box-pack: center;
            -ms-flex-pack: center;
                justify-content: center;
        height: 90vh; }
        .adf-img-viewer .image-container img {
          width: 100%;
          -o-object-fit: contain;
             object-fit: contain; }
    `],
                host: { 'class': 'adf-img-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
ImgViewerComponent.ctorParameters = () => [
    { type: ContentService, },
];
ImgViewerComponent.propDecorators = {
    'urlFile': [{ type: Input },],
    'blobFile': [{ type: Input },],
    'nameFile': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MediaPlayerComponent {
    /**
     * @param {?} contentService
     */
    constructor(contentService) {
        this.contentService = contentService;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
}
MediaPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-media-player',
                template: `
      <video controls>
          <source [src]="urlFile" [type]="mimeType" />
      </video>
    `,
                styles: [`
      .adf-media-player video {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        max-height: 90vh; }
    `],
                host: { 'class': 'adf-media-player' },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
MediaPlayerComponent.ctorParameters = () => [
    { type: ContentService, },
];
MediaPlayerComponent.propDecorators = {
    'urlFile': [{ type: Input },],
    'blobFile': [{ type: Input },],
    'mimeType': [{ type: Input },],
    'nameFile': [{ type: Input },],
};

/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * RenderingQueueServices rendering of the views for pages and thumbnails.
 *
 */
class RenderingQueueServices {
    constructor() {
        this.renderingStates = {
            INITIAL: 0,
            RUNNING: 1,
            PAUSED: 2,
            FINISHED: 3
        };
        this.CLEANUP_TIMEOUT = 30000;
        this.pdfViewer = null;
        this.pdfThumbnailViewer = null;
        this.onIdle = null;
        this.highestPriorityPage = null;
        this.idleTimeout = null;
        this.printing = false;
        this.isThumbnailViewEnabled = false;
    }
    /**
     * @param {?} pdfViewer
     * @return {?}
     */
    setViewer(pdfViewer) {
        this.pdfViewer = pdfViewer;
    }
    /**
     * @param {?} pdfThumbnailViewer
     * @return {?}
     */
    setThumbnailViewer(pdfThumbnailViewer) {
        this.pdfThumbnailViewer = pdfThumbnailViewer;
    }
    /**
     * @param {?} view
     * @return {?}
     */
    isHighestPriority(view) {
        return this.highestPriorityPage === view.renderingId;
    }
    /**
     * @param {?} currentlyVisiblePages
     * @return {?}
     */
    renderHighestPriority(currentlyVisiblePages) {
        if (this.idleTimeout) {
            clearTimeout(this.idleTimeout);
            this.idleTimeout = null;
        }
        // Pages have a higher priority than thumbnails, so check them first.
        if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
            return;
        }
        // No pages needed rendering so check thumbnails.
        if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
            if (this.pdfThumbnailViewer.forceRendering()) {
                return;
            }
        }
        if (this.printing) {
            // If printing is currently ongoing do not reschedule cleanup.
            return;
        }
        if (this.onIdle) {
            this.idleTimeout = setTimeout(this.onIdle.bind(this), this.CLEANUP_TIMEOUT);
        }
    }
    /**
     * @param {?} visible
     * @param {?} views
     * @param {?} scrolledDown
     * @return {?}
     */
    getHighestPriority(visible, views, scrolledDown) {
        // The state has changed figure out which page has the highest priority to
        // render next (if any).
        // Priority:
        // 1 visible pages
        // 2 if last scrolled down page after the visible pages
        // 2 if last scrolled up page before the visible pages
        let /** @type {?} */ visibleViews = visible.views;
        let /** @type {?} */ numVisible = visibleViews.length;
        if (numVisible === 0) {
            return false;
        }
        for (let /** @type {?} */ i = 0; i < numVisible; ++i) {
            let /** @type {?} */ view = visibleViews[i].view;
            if (!this.isViewFinished(view)) {
                return view;
            }
        }
        // All the visible views have rendered, try to render next/previous pages.
        if (scrolledDown) {
            let /** @type {?} */ nextPageIndex = visible.last.id;
            // ID's start at 1 so no need to add 1.
            if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
                return views[nextPageIndex];
            }
        }
        else {
            let /** @type {?} */ previousPageIndex = visible.first.id - 2;
            if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
                return views[previousPageIndex];
            }
        }
        // Everything that needs to be rendered has been.
        return null;
    }
    /**
     * @param {?} view
     * @return {?}
     */
    isViewFinished(view) {
        return view.renderingState === this.renderingStates.FINISHED;
    }
    /**
     * Render a page or thumbnail view. This calls the appropriate function
     * based on the views state. If the view is already rendered it will return
     * false.
     * @param {?} view
     * @return {?}
     */
    renderView(view) {
        let /** @type {?} */ state$$1 = view.renderingState;
        switch (state$$1) {
            case this.renderingStates.FINISHED:
                return false;
            case this.renderingStates.PAUSED:
                this.highestPriorityPage = view.renderingId;
                view.resume();
                break;
            case this.renderingStates.RUNNING:
                this.highestPriorityPage = view.renderingId;
                break;
            case this.renderingStates.INITIAL:
                this.highestPriorityPage = view.renderingId;
                let /** @type {?} */ continueRendering = function () {
                    this.renderHighestPriority();
                }.bind(this);
                view.draw().then(continueRendering, continueRendering);
                break;
            default:
                break;
        }
        return true;
    }
}
RenderingQueueServices.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
RenderingQueueServices.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PdfViewerComponent {
    /**
     * @param {?} renderingQueueServices
     * @param {?} logService
     */
    constructor(renderingQueueServices, logService) {
        this.renderingQueueServices = renderingQueueServices;
        this.logService = logService;
        this.showToolbar = true;
        this.allowThumbnails = false;
        this.currentScaleMode = 'auto';
        this.MAX_AUTO_SCALE = 1.25;
        this.DEFAULT_SCALE_DELTA = 1.1;
        this.MIN_SCALE = 0.25;
        this.MAX_SCALE = 10.0;
        // needed to preserve "this" context when setting as a global document event listener
        this.onDocumentScroll = this.onDocumentScroll.bind(this);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
        if (this.urlFile) {
            return new Promise((resolve, reject) => {
                this.executePdf(this.urlFile, resolve, reject);
            });
        }
        else {
            return new Promise((resolve, reject) => {
                let /** @type {?} */ reader = new FileReader();
                reader.onload = () => {
                    this.executePdf(reader.result, resolve, reject);
                };
                reader.readAsArrayBuffer(this.blobFile);
            });
        }
    }
    /**
     * @param {?} src
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    executePdf(src, resolve, reject) {
        let /** @type {?} */ loadingTask = this.getPDFJS().getDocument(src);
        loadingTask.onProgress = (progressData) => {
            let /** @type {?} */ level = progressData.loaded / progressData.total;
            this.loadingPercent = Math.round(level * 100);
        };
        loadingTask.then((pdfDocument) => {
            this.currentPdfDocument = pdfDocument;
            this.totalPages = pdfDocument.numPages;
            this.page = 1;
            this.displayPage = 1;
            this.initPDFViewer(this.currentPdfDocument);
            this.currentPdfDocument.getPage(1).then(() => {
                this.scalePage('auto');
                resolve();
            }, (error) => {
                reject(error);
            });
        }, (error) => {
            reject(error);
        });
    }
    /**
     * return the PDFJS global object (exist to facilitate the mock of PDFJS in the test)
     *
     * @return {?}
     */
    getPDFJS() {
        return PDFJS;
    }
    /**
     * @param {?} pdfDocument
     * @return {?}
     */
    initPDFViewer(pdfDocument) {
        PDFJS.verbosity = 1;
        PDFJS.disableWorker = false;
        let /** @type {?} */ documentContainer = document.getElementById('viewer-pdf-container');
        let /** @type {?} */ viewer = document.getElementById('viewer-viewerPdf');
        window.document.addEventListener('scroll', this.onDocumentScroll, true);
        this.pdfViewer = new PDFJS.PDFViewer({
            container: documentContainer,
            viewer: viewer,
            renderingQueue: this.renderingQueueServices
        });
        this.renderingQueueServices.setViewer(this.pdfViewer);
        this.pdfViewer.setDocument(pdfDocument);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        window.document.removeEventListener('scroll', this.onDocumentScroll, true);
    }
    /**
     * Method to scale the page current support implementation
     *
     * @param {?} scaleMode
     * @return {?}
     */
    scalePage(scaleMode) {
        this.currentScaleMode = scaleMode;
        if (this.pdfViewer) {
            let /** @type {?} */ viewerContainer = document.getElementById('viewer-main-container');
            let /** @type {?} */ documentContainer = document.getElementById('viewer-pdf-container');
            let /** @type {?} */ widthContainer;
            let /** @type {?} */ heigthContainer;
            if (viewerContainer && viewerContainer.clientWidth <= documentContainer.clientWidth) {
                widthContainer = viewerContainer.clientWidth;
                heigthContainer = viewerContainer.clientHeight;
            }
            else {
                widthContainer = documentContainer.clientWidth;
                heigthContainer = documentContainer.clientHeight;
            }
            let /** @type {?} */ currentPage = this.pdfViewer._pages[this.pdfViewer._currentPageNumber - 1];
            let /** @type {?} */ padding = 20;
            let /** @type {?} */ pageWidthScale = (widthContainer - padding) / currentPage.width * currentPage.scale;
            let /** @type {?} */ pageHeightScale = (heigthContainer - padding) / currentPage.width * currentPage.scale;
            let /** @type {?} */ scale;
            switch (this.currentScaleMode) {
                case 'page-actual':
                    scale = 1;
                    break;
                case 'page-width':
                    scale = pageWidthScale;
                    break;
                case 'page-height':
                    scale = pageHeightScale;
                    break;
                case 'page-fit':
                    scale = Math.min(pageWidthScale, pageHeightScale);
                    break;
                case 'auto':
                    let /** @type {?} */ horizontalScale;
                    if (this.isLandscape) {
                        horizontalScale = Math.min(pageHeightScale, pageWidthScale);
                    }
                    else {
                        horizontalScale = pageWidthScale;
                    }
                    scale = Math.min(this.MAX_AUTO_SCALE, horizontalScale);
                    break;
                default:
                    this.logService.error('pdfViewSetScale: \'' + scaleMode + '\' is an unknown zoom value.');
                    return;
            }
            this.setScaleUpdatePages(scale);
        }
    }
    /**
     * Update all the pages with the newScale scale
     *
     * @param {?} newScale
     * @return {?}
     */
    setScaleUpdatePages(newScale) {
        if (!this.isSameScale(this.currentScale, newScale)) {
            this.currentScale = newScale;
            this.pdfViewer._pages.forEach(function (currentPage) {
                currentPage.update(newScale);
            });
            this.pdfViewer.update();
        }
    }
    /**
     * method to check if the request scale of the page is the same for avoid unuseful re-rendering
     *
     *
     * @param {?} oldScale
     * @param {?} newScale
     * @return {?}
     */
    isSameScale(oldScale, newScale) {
        return (newScale === oldScale);
    }
    /**
     * method to check if is a land scape view
     *
     *
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    isLandscape(width, height) {
        return (width > height);
    }
    /**
     * Method triggered when the page is resized
     * @return {?}
     */
    onResize() {
        this.scalePage(this.currentScaleMode);
    }
    /**
     * toggle the fit page pdf
     * @return {?}
     */
    pageFit() {
        if (this.currentScaleMode !== 'page-fit') {
            this.scalePage('page-fit');
        }
        else {
            this.scalePage('auto');
        }
    }
    /**
     * zoom in page pdf
     *
     * @param {?} ticks
     * @return {?}
     */
    zoomIn(ticks) {
        let /** @type {?} */ newScale = this.currentScale;
        do {
            newScale = (newScale * this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.ceil(newScale * 10) / 10;
            newScale = Math.min(this.MAX_SCALE, newScale);
        } while (--ticks > 0 && newScale < this.MAX_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    /**
     * zoom out page pdf
     *
     * @param {?} ticks
     * @return {?}
     */
    zoomOut(ticks) {
        let /** @type {?} */ newScale = this.currentScale;
        do {
            newScale = (newScale / this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.floor(newScale * 10) / 10;
            newScale = Math.max(this.MIN_SCALE, newScale);
        } while (--ticks > 0 && newScale > this.MIN_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    /**
     * load the previous page
     * @return {?}
     */
    previousPage() {
        if (this.pdfViewer && this.page > 1) {
            this.page--;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    /**
     * load the next page
     * @return {?}
     */
    nextPage() {
        if (this.pdfViewer && this.page < this.totalPages) {
            this.page++;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    /**
     * load the page in input
     *
     * @param {?} page
     * @return {?}
     */
    inputPage(page) {
        let /** @type {?} */ pageInput = parseInt(page, 10);
        if (!isNaN(pageInput) && pageInput > 0 && pageInput <= this.totalPages) {
            this.page = pageInput;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
        else {
            this.displayPage = this.page;
        }
    }
    /**
     * Litener Scroll Event
     *
     * @param {?} target
     * @return {?}
     */
    watchScroll(target) {
        let /** @type {?} */ outputPage = this.getVisibleElement(target);
        if (outputPage) {
            this.page = outputPage.id;
            this.displayPage = this.page;
        }
    }
    /**
     * find out what elements are visible within a scroll pane
     *
     *
     * @param {?} target
     * @return {?}
     */
    getVisibleElement(target) {
        return this.pdfViewer._pages.find((page) => {
            return this.isOnScreen(page, target);
        });
    }
    /**
     * check if a page is visible
     *
     *
     * @param {?} page
     * @param {?} target
     * @return {?}
     */
    isOnScreen(page, target) {
        let /** @type {?} */ viewport = {};
        viewport.top = target.scrollTop;
        viewport.bottom = viewport.top + target.scrollHeight;
        let /** @type {?} */ bounds = {};
        bounds.top = page.div.offsetTop;
        bounds.bottom = bounds.top + page.viewport.height;
        return ((bounds.top <= viewport.bottom) && (bounds.bottom >= viewport.top));
    }
    /**
     * Litener Keyboard Event
     * @param {?} event
     * @return {?}
     */
    handleKeyboardEvent(event) {
        let /** @type {?} */ key = event.keyCode;
        if (key === 39) {
            this.nextPage();
        }
        else if (key === 37) {
            this.previousPage();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDocumentScroll(event) {
        if (event && event.target) {
            this.watchScroll(event.target);
        }
    }
}
PdfViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-viewer',
                template: `
      <div id="viewer-pdf-container" class="viewer-pdf-container" (window:resize)="onResize()">
          <div id="viewer-viewerPdf" class="pdfViewer">
              <div id="loader-container" class="loader-container">
                  <div class="loader-item">
                      <mat-progress-bar mode="indeterminate"></mat-progress-bar>
                  </div >
              </div>
          </div>
      </div>

      <div class="adf-pdf-viewer__toolbar" *ngIf="showToolbar">
          <adf-toolbar>

              <ng-container *ngIf="allowThumbnails">
                  <button mat-icon-button>
                      <mat-icon>dashboard</mat-icon>
                  </button>
                  <adf-toolbar-divider></adf-toolbar-divider>
              </ng-container>

              <button
                  id="viewer-previous-page-button"
                  attr.aria-label="{{ 'ADF_VIEWER.ARIA.PREVIOUS_PAGE' | translate }}"
                  mat-icon-button
                  (click)="previousPage()">
                  <mat-icon>keyboard_arrow_up</mat-icon>
              </button>

              <button
                  id="viewer-next-page-button"
                  attr.aria-label="{{ 'ADF_VIEWER.ARIA.NEXT_PAGE' | translate }}"
                  mat-icon-button
                  (click)="nextPage()">
                  <mat-icon>keyboard_arrow_down</mat-icon>
              </button>

              <div>
                  {{ 'ADF_VIEWER.PAGE_LABEL.SHOWING' | translate }}
                  <input #page
                      class="adf-pdf-viewer__toolbar-page-selector"
                      type="text"
                      pattern="-?[0-9]*(\\.[0-9]+)?"
                      value="{{ displayPage }}"
                      (keyup.enter)="inputPage(page.value)">
                  {{ 'ADF_VIEWER.PAGE_LABEL.OF' | translate }} {{ totalPages }}
              </div>

              <adf-toolbar-divider></adf-toolbar-divider>

              <button
                  id="viewer-zoom-in-button"
                  attr.aria-label="{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}"
                  mat-icon-button
                  (click)="zoomIn()">
                  <mat-icon>zoom_in</mat-icon>
              </button>

              <button
                  id="viewer-zoom-out-button"
                  attr.aria-label="{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}"
                  mat-icon-button
                  (click)="zoomOut()">
                  <mat-icon>zoom_out</mat-icon>
              </button>

              <button
                  id="viewer-scale-page-button"
                  attr.aria-label="{{ 'ADF_VIEWER.ARIA.FIT_PAGE' | translate }}"
                  mat-icon-button
                  (click)="pageFit()">
                  <mat-icon>zoom_out_map</mat-icon>
              </button>

          </adf-toolbar>
      </div>
    `,
                styles: [`
      .adf-pdf-viewer .loader-container {
        display: -webkit-box;
        /* OLD - iOS 6-, Safari 3.1-6 */
        /* OLD - Firefox 19- (buggy but mostly works) */
        /* NEW - Chrome */
        display: -ms-flexbox;
        display: flex;
        /* NEW, Spec - Opera 12.1, Firefox 20+ */
        -webkit-box-flex-direction: row;
        -moz-box-flex-direction: row;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
            -ms-flex-direction: row;
                flex-direction: row;
        height: 100%; }

      .adf-pdf-viewer .loader-item {
        margin: auto;
        max-height: 100px;
        max-width: 300px; }

      .adf-pdf-viewer__toolbar {
        position: absolute;
        bottom: 0;
        left: 50%;
        -webkit-transform: translateX(-50%);
                transform: translateX(-50%); }
        .adf-pdf-viewer__toolbar-page-selector {
          font-size: 16px;
          padding: 4px 0;
          text-align: right;
          width: 33px;
          margin-right: 4px;
          height: 20px;
          outline-width: 1px;
          outline-color: gray; }
      .adf-pdf-viewer .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        opacity: 0.2;
        line-height: 1.0;
        border: 1px solid gray; }
        .adf-pdf-viewer .textLayer > div {
          color: transparent;
          position: absolute;
          white-space: pre;
          cursor: text;
          -webkit-transform-origin: 0% 0%;
          transform-origin: 0% 0%; }
        .adf-pdf-viewer .textLayer .highlight {
          margin: -1px;
          padding: 1px;
          background-color: #b400aa;
          border-radius: 4px; }
          .adf-pdf-viewer .textLayer .highlight.begin {
            border-radius: 4px 0px 0px 4px; }
          .adf-pdf-viewer .textLayer .highlight.end {
            border-radius: 0px 4px 4px 0px; }
          .adf-pdf-viewer .textLayer .highlight.middle {
            border-radius: 0px; }
          .adf-pdf-viewer .textLayer .highlight.selected {
            background-color: darkgreen; }
        .adf-pdf-viewer .textLayer::-moz-selection {
          background: blue; }
        .adf-pdf-viewer .textLayer::selection {
          background: blue; }
        .adf-pdf-viewer .textLayer::-moz-selection {
          background: blue; }
        .adf-pdf-viewer .textLayer .endOfContent {
          display: block;
          position: absolute;
          left: 0px;
          top: 100%;
          right: 0px;
          bottom: 0px;
          z-index: -1;
          cursor: default;
          user-select: none;
          -webkit-user-select: none;
          -ms-user-select: none;
          -moz-user-select: none; }
          .adf-pdf-viewer .textLayer .endOfContent.active {
            top: 0px; }

      .adf-pdf-viewer .annotationLayer section {
        position: absolute; }

      .adf-pdf-viewer .annotationLayer .linkAnnotation > a {
        position: absolute;
        font-size: 1em;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url("data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7") 0 0 repeat; }
        .adf-pdf-viewer .annotationLayer .linkAnnotation > a:hover {
          opacity: 0.2;
          background: #ff0;
          -webkit-box-shadow: 0px 2px 10px #ff0;
                  box-shadow: 0px 2px 10px #ff0; }

      .adf-pdf-viewer .annotationLayer .textAnnotation img {
        position: absolute;
        cursor: pointer; }

      .adf-pdf-viewer .annotationLayer .popupWrapper {
        position: absolute;
        width: 20em; }

      .adf-pdf-viewer .annotationLayer .popup {
        position: absolute;
        z-index: 200;
        max-width: 20em;
        background-color: #FFFF99;
        -webkit-box-shadow: 0px 2px 5px #333;
                box-shadow: 0px 2px 5px #333;
        border-radius: 2px;
        padding: 0.6em;
        margin-left: 5px;
        cursor: pointer;
        word-wrap: break-word; }
        .adf-pdf-viewer .annotationLayer .popup h1 {
          font-size: 1em;
          border-bottom: 1px solid #000000;
          padding-bottom: 0.2em; }
        .adf-pdf-viewer .annotationLayer .popup p {
          padding-top: 0.2em; }

      .adf-pdf-viewer .annotationLayer .highlightAnnotation,
      .adf-pdf-viewer .annotationLayer .underlineAnnotation,
      .adf-pdf-viewer .annotationLayer .squigglyAnnotation,
      .adf-pdf-viewer .annotationLayer .strikeoutAnnotation,
      .adf-pdf-viewer .annotationLayer .fileAttachmentAnnotation {
        cursor: pointer; }

      .adf-pdf-viewer .pdfViewer canvasWrapper {
        overflow: hidden; }

      .adf-pdf-viewer .pdfViewer .page {
        direction: ltr;
        width: 816px;
        height: 1056px;
        margin: 1px auto -8px auto;
        position: relative;
        overflow: visible;
        border: 9px solid transparent;
        background-clip: content-box;
        background-color: white; }
        .adf-pdf-viewer .pdfViewer .page canvas {
          margin: 0;
          display: block; }
        .adf-pdf-viewer .pdfViewer .page .loadingIcon {
          position: absolute;
          display: block;
          left: 0;
          top: 0;
          right: 0;
          bottom: 0; }

      .adf-pdf-viewer .pdfViewer.removePageBorders .page {
        margin: 0px auto 10px auto;
        border: none; }

      .adf-pdf-viewer .pdfViewer .loadingIcon {
        width: 100px;
        height: 100px;
        left: 50% !important;
        top: 50% !important;
        margin-top: -50px;
        margin-left: -50px;
        font-size: 5px;
        text-indent: -9999em;
        border-top: 1.1em solid rgba(3, 0, 2, 0.2);
        border-right: 1.1em solid rgba(3, 0, 2, 0.2);
        border-bottom: 1.1em solid rgba(3, 0, 2, 0.2);
        border-left: 1.1em solid #030002;
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-animation: load8 1.1s infinite linear;
        animation: load8 1.1s infinite linear;
        border-radius: 50%; }
        .adf-pdf-viewer .pdfViewer .loadingIcon:after {
          border-radius: 50%; }

      .adf-pdf-viewer * {
        padding: 0;
        margin: 0; }

      .adf-pdf-viewer .hidden, .adf-pdf-viewer [hidden] {
        display: none !important; }

      @-webkit-keyframes load8 {
        0% {
          -webkit-transform: rotate(0deg);
          transform: rotate(0deg); }
        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg); } }

      @keyframes load8 {
        0% {
          -webkit-transform: rotate(0deg);
          transform: rotate(0deg); }
        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg); } }

      .viewer-pdf-container {
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        outline: none; }

      html[dir='ltr'] .viewer-pdf-container {
        -webkit-box-shadow: inset 1px 0 0 rgba(255, 255, 255, 0.05);
                box-shadow: inset 1px 0 0 rgba(255, 255, 255, 0.05); }

      html[dir='rtl'] .viewer-pdf-container {
        -webkit-box-shadow: inset -1px 0 0 rgba(255, 255, 255, 0.05);
                box-shadow: inset -1px 0 0 rgba(255, 255, 255, 0.05); }
    `],
                providers: [RenderingQueueServices],
                host: { 'class': 'adf-pdf-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
PdfViewerComponent.ctorParameters = () => [
    { type: RenderingQueueServices, },
    { type: LogService, },
];
PdfViewerComponent.propDecorators = {
    'urlFile': [{ type: Input },],
    'blobFile': [{ type: Input },],
    'nameFile': [{ type: Input },],
    'showToolbar': [{ type: Input },],
    'allowThumbnails': [{ type: Input },],
    'handleKeyboardEvent': [{ type: HostListener, args: ['document:keydown', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TxtViewerComponent {
    /**
     * @param {?} http
     */
    constructor(http$$1) {
        this.http = http$$1;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            return this.readBlob(blobFile.currentValue);
        }
        let /** @type {?} */ urlFile = changes['urlFile'];
        if (urlFile && urlFile.currentValue) {
            return this.getUrlContent(urlFile.currentValue);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    /**
     * @param {?} url
     * @return {?}
     */
    getUrlContent(url) {
        return new Promise((resolve, reject) => {
            this.http.get(url, { responseType: 'text' }).subscribe(res => {
                this.content = res;
                resolve();
            }, (event) => {
                reject(event);
            });
        });
    }
    /**
     * @param {?} blob
     * @return {?}
     */
    readBlob(blob) {
        return new Promise((resolve, reject) => {
            let /** @type {?} */ reader = new FileReader();
            reader.onload = () => {
                this.content = reader.result;
                resolve();
            };
            reader.onerror = (error) => {
                reject(error);
            };
            reader.readAsText(blob);
        });
    }
}
TxtViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-txt-viewer',
                template: `
      <pre class="adf-txt-viewer-content">
          {{content}}
      </pre>
    `,
                styles: [`
      .adf-txt-viewer {
        background-color: white;
        width: 100vw;
        overflow: hidden;
        overflow-y: scroll;
        margin-bottom: 42px; }
    `],
                host: { 'class': 'adf-txt-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TxtViewerComponent.ctorParameters = () => [
    { type: HttpClient, },
];
TxtViewerComponent.propDecorators = {
    'urlFile': [{ type: Input },],
    'blobFile': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UnknownFormatComponent {
}
UnknownFormatComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-unknown-format',
                template: `
      <div class="adf-viewer__unknown-format-view">
          <div>
              <mat-icon class="icon">wifi_tethering</mat-icon>
              <div class="label">{{ 'ADF_VIEWER.UNKNOWN_FORMAT' | translate }}</div>
          </div>
      </div>
    `,
                styles: [`
      .adf-viewer__unknown-format-view {
        height: 90vh;
        text-align: center;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column;
        -webkit-box-pack: center;
            -ms-flex-pack: center;
                justify-content: center; }
    `]
            },] },
];
/**
 * @nocollapse
 */
UnknownFormatComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerMoreActionsComponent {
}
ViewerMoreActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-more-actions',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-more-actions' },
                template: `<ng-content></ng-content>`
            },] },
];
/**
 * @nocollapse
 */
ViewerMoreActionsComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerOpenWithComponent {
}
ViewerOpenWithComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-open-with',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-open-with' },
                template: `<ng-content></ng-content>`
            },] },
];
/**
 * @nocollapse
 */
ViewerOpenWithComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerSidebarComponent {
}
ViewerSidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-sidebar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-sidebar' },
                template: `<ng-content></ng-content>`
            },] },
];
/**
 * @nocollapse
 */
ViewerSidebarComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerToolbarComponent {
}
ViewerToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-toolbar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-toolbar' },
                template: `<ng-content></ng-content>`
            },] },
];
/**
 * @nocollapse
 */
ViewerToolbarComponent.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * RenditionsService
 *
 */
class RenditionsService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * @param {?} nodeId
     * @param {?} encoding
     * @return {?}
     */
    isRenditionAvailable(nodeId, encoding) {
        return Observable$1.create((observer) => {
            this.getRendition(nodeId, encoding).subscribe((res) => {
                let /** @type {?} */ isAvailable = true;
                if (res.entry.status.toString() === 'NOT_CREATED') {
                    isAvailable = false;
                }
                observer.next(isAvailable);
                observer.complete();
            }, () => {
                observer.next(false);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} nodeId
     * @param {?} encoding
     * @return {?}
     */
    isConversionPossible(nodeId, encoding) {
        return Observable$1.create((observer) => {
            this.getRendition(nodeId, encoding).subscribe(() => {
                observer.next(true);
                observer.complete();
            }, () => {
                observer.next(false);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} nodeId
     * @param {?} encoding
     * @return {?}
     */
    getRenditionUrl(nodeId, encoding) {
        return this.apiService.contentApi.getRenditionUrl(nodeId, 'pdf');
    }
    /**
     * @param {?} nodeId
     * @param {?} encoding
     * @return {?}
     */
    getRendition(nodeId, encoding) {
        return Observable$1.fromPromise(this.apiService.renditionsApi.getRendition(nodeId, encoding));
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    getRenditionsListByNodeId(nodeId) {
        return Observable$1.fromPromise(this.apiService.renditionsApi.getRenditions(nodeId));
    }
    /**
     * @param {?} nodeId
     * @param {?} encoding
     * @return {?}
     */
    createRendition(nodeId, encoding) {
        return Observable$1.fromPromise(this.apiService.renditionsApi.createRendition(nodeId, { id: encoding }));
    }
    /**
     * @param {?} nodeId
     * @param {?} encoding
     * @param {?=} pollingInterval
     * @return {?}
     */
    convert(nodeId, encoding, pollingInterval = 1000) {
        return this.createRendition(nodeId, encoding)
            .concatMap(() => this.pollRendition(nodeId, encoding, pollingInterval));
    }
    /**
     * @param {?} nodeId
     * @param {?} encoding
     * @param {?=} interval
     * @return {?}
     */
    pollRendition(nodeId, encoding, interval$$1 = 1000) {
        return Observable$1.interval(interval$$1)
            .switchMap(() => this.getRendition(nodeId, encoding))
            .takeWhile((data) => {
            return (data.entry.status.toString() !== 'CREATED');
        });
    }
}
RenditionsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
RenditionsService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerComponent {
    /**
     * @param {?} apiService
     * @param {?} logService
     * @param {?} location
     * @param {?} renditionService
     */
    constructor(apiService, logService, location, renditionService) {
        this.apiService = apiService;
        this.logService = logService;
        this.location = location;
        this.renditionService = renditionService;
        this.urlFile = '';
        this.fileNodeId = null;
        this.overlayMode = false;
        this.showViewer = true;
        this.showToolbar = true;
        this.allowGoBack = true;
        this.allowDownload = true;
        this.allowPrint = false;
        this.allowShare = false;
        this.allowSidebar = false;
        this.showSidebar = false;
        this.sidebarPosition = 'right';
        this.sidebarTemplate = null;
        this.goBack = new EventEmitter();
        this.download = new EventEmitter();
        this.print = new EventEmitter();
        this.share = new EventEmitter();
        this.showViewerChange = new EventEmitter();
        this.extensionChange = new EventEmitter();
        this.viewerType = 'unknown';
        this.downloadUrl = null;
        this.fileName = 'document';
        this.isLoading = false;
        this.extensionTemplates = [];
        this.externalExtensions = [];
        this.sidebarTemplateContext = { node: null };
        this.extensions = {
            image: ['png', 'jpg', 'jpeg', 'gif', 'bpm'],
            media: ['wav', 'mp4', 'mp3', 'webm', 'ogg'],
            text: ['txt', 'xml', 'js', 'html', 'json'],
            pdf: ['pdf']
        };
        this.mimeTypes = [
            { mimeType: 'application/x-javascript', type: 'text' },
            { mimeType: 'application/pdf', type: 'pdf' }
        ];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.showViewer) {
            if (!this.urlFile && !this.blobFile && !this.fileNodeId) {
                throw new Error('Attribute urlFile or fileNodeId or blobFile is required');
            }
            return new Promise((resolve, reject) => {
                if (this.blobFile) {
                    this.displayName = this.getDisplayName('Unknown');
                    this.isLoading = true;
                    this.mimeType = this.blobFile.type;
                    this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
                    this.allowDownload = false;
                    // TODO: wrap blob into the data url and allow downloading
                    this.extensionChange.emit(this.mimeType);
                    this.isLoading = false;
                    this.scrollTop();
                    resolve();
                }
                else if (this.urlFile) {
                    this.isLoading = true;
                    let /** @type {?} */ filenameFromUrl = this.getFilenameFromUrl(this.urlFile);
                    this.displayName = this.getDisplayName(filenameFromUrl);
                    this.extension = this.getFileExtension(filenameFromUrl);
                    this.urlFileContent = this.urlFile;
                    this.downloadUrl = this.urlFile;
                    this.fileName = this.displayName;
                    this.viewerType = this.getViewerTypeByExtension(this.extension);
                    if (this.viewerType === 'unknown') {
                        this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
                    }
                    this.extensionChange.emit(this.extension);
                    this.isLoading = false;
                    this.scrollTop();
                    resolve();
                }
                else if (this.fileNodeId) {
                    this.isLoading = true;
                    this.apiService.getInstance().nodes.getNodeInfo(this.fileNodeId).then((data) => {
                        this.mimeType = data.content.mimeType;
                        this.displayName = this.getDisplayName(data.name);
                        this.urlFileContent = this.apiService.getInstance().content.getContentUrl(data.id);
                        this.extension = this.getFileExtension(data.name);
                        this.fileName = data.name;
                        this.downloadUrl = this.apiService.getInstance().content.getContentUrl(data.id, true);
                        this.viewerType = this.getViewerTypeByExtension(this.extension);
                        if (this.viewerType === 'unknown') {
                            this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
                        }
                        if (this.viewerType === 'unknown') {
                            this.displayAsPdf(data.id);
                        }
                        else {
                            this.isLoading = false;
                        }
                        this.extensionChange.emit(this.extension);
                        this.sidebarTemplateContext.node = data;
                        this.scrollTop();
                        resolve();
                    }, (error) => {
                        this.isLoading = false;
                        reject(error);
                        this.logService.error('This node does not exist');
                    });
                }
            });
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    getDisplayName(name) {
        return this.displayName || name;
    }
    /**
     * @return {?}
     */
    scrollTop() {
        window.scrollTo(0, 1);
    }
    /**
     * @param {?} mimeType
     * @return {?}
     */
    getViewerTypeByMimeType(mimeType) {
        if (mimeType) {
            mimeType = mimeType.toLowerCase();
            if (mimeType.startsWith('image/')) {
                return 'image';
            }
            if (mimeType.startsWith('text/')) {
                return 'text';
            }
            if (mimeType.startsWith('video/')) {
                return 'media';
            }
            if (mimeType.startsWith('audio/')) {
                return 'media';
            }
            const /** @type {?} */ registered = this.mimeTypes.find(t => t.mimeType === mimeType);
            if (registered) {
                return registered.type;
            }
        }
        return 'unknown';
    }
    /**
     * @param {?} extension
     * @return {?}
     */
    getViewerTypeByExtension(extension) {
        if (extension) {
            extension = extension.toLowerCase();
        }
        if (this.isCustomViewerExtension(extension)) {
            return 'custom';
        }
        if (this.extensions.image.indexOf(extension) >= 0) {
            return 'image';
        }
        if (this.extensions.media.indexOf(extension) >= 0) {
            return 'media';
        }
        if (this.extensions.text.indexOf(extension) >= 0) {
            return 'text';
        }
        if (this.extensions.pdf.indexOf(extension) >= 0) {
            return 'pdf';
        }
        return 'unknown';
    }
    /**
     * @return {?}
     */
    onBackButtonClick() {
        if (this.overlayMode) {
            this.close();
        }
        else {
            const /** @type {?} */ event = new BaseEvent();
            this.goBack.next(event);
            if (!event.defaultPrevented) {
                this.location.back();
            }
        }
    }
    /**
     * close the viewer
     * @return {?}
     */
    close() {
        if (this.otherMenu) {
            this.otherMenu.hidden = false;
        }
        this.showViewer = false;
        this.showViewerChange.emit(this.showViewer);
    }
    /**
     * get File name from url
     *
     * @param {?} url
     * @return {?}
     */
    getFilenameFromUrl(url) {
        let /** @type {?} */ anchor = url.indexOf('#');
        let /** @type {?} */ query = url.indexOf('?');
        let /** @type {?} */ end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
        return url.substring(url.lastIndexOf('/', end) + 1, end);
    }
    /**
     * Get the token from the local storage
     *
     * @param {?} fileName
     * @return {?}
     */
    getFileExtension(fileName) {
        return fileName.split('.').pop().toLowerCase();
    }
    /**
     * @param {?} extension
     * @return {?}
     */
    isCustomViewerExtension(extension) {
        const /** @type {?} */ extensions = this.externalExtensions || [];
        if (extension && extensions.length > 0) {
            extension = extension.toLowerCase();
            return extensions.indexOf(extension) >= 0;
        }
        return false;
    }
    /**
     * Litener Keyboard Event
     * @param {?} event
     * @return {?}
     */
    handleKeyboardEvent(event) {
        let /** @type {?} */ key = event.keyCode;
        if (key === 27 && this.overlayMode) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    downloadContent() {
        if (this.allowDownload && this.downloadUrl && this.fileName) {
            const /** @type {?} */ args = new BaseEvent();
            this.download.next(args);
            if (!args.defaultPrevented) {
                const /** @type {?} */ link = document.createElement('a');
                link.style.display = 'none';
                link.download = this.fileName;
                link.href = this.downloadUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }
    /**
     * @return {?}
     */
    printContent() {
        if (this.allowPrint) {
            const /** @type {?} */ args = new BaseEvent();
            this.print.next(args);
        }
    }
    /**
     * @return {?}
     */
    shareContent() {
        if (this.allowShare) {
            const /** @type {?} */ args = new BaseEvent();
            this.share.next(args);
        }
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    displayAsPdf(nodeId) {
        this.isLoading = true;
        this.renditionService.getRendition(nodeId, 'pdf').subscribe((response) => {
            const /** @type {?} */ status = response.entry.status.toString();
            if (status === 'CREATED') {
                this.isLoading = false;
                this.showPdfRendition(nodeId);
            }
            else if (status === 'NOT_CREATED') {
                this.renditionService.convert(nodeId, 'pdf').subscribe({
                    complete: () => {
                        this.isLoading = false;
                        this.showPdfRendition(nodeId);
                    },
                    error: (error) => {
                        this.isLoading = false;
                    }
                });
            }
            else {
                this.isLoading = false;
            }
        }, (err) => {
            this.isLoading = false;
        });
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    showPdfRendition(nodeId) {
        if (nodeId) {
            this.viewerType = 'pdf';
            this.urlFileContent = this.renditionService.getRenditionUrl(nodeId, 'pdf');
        }
    }
}
ViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer',
                template: `
      <div *ngIf="showViewer"
          class="adf-viewer-container"
          [class.adf-viewer-overlay-container]="overlayMode"
          [class.adf-viewer-inline-container]="!overlayMode">

          <div class="adf-viewer-content" fxLayout="column">
              <ng-content select="adf-viewer-toolbar"></ng-content>
              <ng-container *ngIf="showToolbar && !toolbar">
                  <adf-toolbar color="default" class="adf-viewer-toolbar">

                      <adf-toolbar-title>
                          <button *ngIf="allowGoBack"
                              class="adf-viewer-close-button"
                              data-automation-id="toolbar-back"
                              mat-icon-button
                              matTooltip="{{ 'ADF_VIEWER.ACTIONS.BACK' | translate }}"
                              (click)="onBackButtonClick()">
                              <mat-icon>arrow_back</mat-icon>
                          </button>
                          <img class="adf-viewer__mimeicon" [src]="mimeType | adfMimeTypeIcon">
                          <span id="adf-viewer-display-name">{{ displayName }}</span>
                      </adf-toolbar-title>

                      <ng-container *ngIf="mnuOpenWith">
                          <button
                              mat-button
                              [matMenuTriggerFor]="mnuOpenWith"
                              data-automation-id="toolbar-open-with">
                              <span>{{ 'ADF_VIEWER.ACTIONS.OPEN_WITH' | translate }}</span>
                              <mat-icon>arrow_drop_down</mat-icon>
                          </button>
                          <mat-menu #mnuOpenWith="matMenu" [overlapTrigger]="false">
                              <ng-content select="adf-viewer-open-with"></ng-content>
                          </mat-menu>
                      </ng-container>

                      <adf-toolbar-divider></adf-toolbar-divider>

                      <button
                          *ngIf="allowDownload"
                          mat-icon-button
                          matTooltip="{{ 'ADF_VIEWER.ACTIONS.DOWNLOAD' | translate }}"
                          data-automation-id="toolbar-download"
                          (click)="downloadContent()">
                          <mat-icon>file_download</mat-icon>
                      </button>

                      <button
                          *ngIf="allowPrint"
                          mat-icon-button
                          matTooltip="{{ 'ADF_VIEWER.ACTIONS.PRINT' | translate }}"
                          data-automation-id="toolbar-print"
                          (click)="printContent()">
                          <mat-icon>print</mat-icon>
                      </button>

                      <button
                          *ngIf="allowShare"
                          mat-icon-button
                          matTooltip="{{ 'ADF_VIEWER.ACTIONS.SHARE' | translate }}"
                          data-automation-id="toolbar-share"
                          (click)="shareContent()">
                          <mat-icon>share</mat-icon>
                      </button>

                      <ng-container *ngIf="mnuMoreActions">
                          <button
                              mat-icon-button
                              [matMenuTriggerFor]="mnuMoreActions"
                              matTooltip="{{ 'ADF_VIEWER.ACTIONS.MORE_ACTIONS' | translate }}"
                              data-automation-id="toolbar-more-actions">
                              <mat-icon>more_vert</mat-icon>
                          </button>
                          <mat-menu #mnuMoreActions="matMenu" [overlapTrigger]="false">
                              <ng-content select="adf-viewer-more-actions"></ng-content>
                          </mat-menu>
                      </ng-container>

                      <ng-container *ngIf="allowSidebar">
                          <adf-toolbar-divider></adf-toolbar-divider>

                          <button
                              mat-icon-button
                              matTooltip="{{ 'ADF_VIEWER.ACTIONS.INFO' | translate }}"
                              data-automation-id="toolbar-sidebar"
                              [color]="showSidebar ? 'accent' : 'default'"
                              (click)="showSidebar = !showSidebar">
                              <mat-icon>info_outline</mat-icon>
                          </button>
                      </ng-container>

                  </adf-toolbar>
              </ng-container>

              <ng-container *ngIf="isLoading">
                  <div class="adf-viewer__loading-screen" fxFlex="1 1 auto">
                      <h2>{{ 'ADF_VIEWER.LOADING' | translate }}</h2>
                      <div>
                          <mat-spinner></mat-spinner>
                      </div>
                  </div>
              </ng-container>

              <div *ngIf="!isLoading" fxLayout="row" fxFlex="1 1 auto">

                  <ng-container *ngIf="showSidebar">
                      <div class="adf-viewer__sidebar" fxFlexOrder="{{sidebarPosition === 'left'? 1: 2 }}">
                          <ng-container *ngIf="sidebarTemplate">
                              <ng-container *ngTemplateOutlet="sidebarTemplate;context:sidebarTemplateContext"></ng-container>
                          </ng-container>
                          <ng-content *ngIf="!sidebarTemplate" select="adf-viewer-sidebar"></ng-content>
                      </div>
                  </ng-container>

                  <div fxFlexOrder="{{sidebarPosition !== 'left'? 1: 2}}" fxFlex="1 1 auto">
                      <div class="adf-viewer-layout-content">
                          <div class="adf-viewer-content-container" [ngSwitch]="viewerType">

                              <ng-container *ngSwitchCase="'pdf'">
                                  <adf-pdf-viewer [blobFile]="blobFile" [urlFile]="urlFileContent" [nameFile]="displayName"></adf-pdf-viewer>
                              </ng-container>

                              <ng-container *ngSwitchCase="'image'">
                                  <adf-img-viewer [urlFile]="urlFileContent" [nameFile]="displayName" [blobFile]="blobFile"></adf-img-viewer>
                              </ng-container>

                              <ng-container *ngSwitchCase="'media'">
                                  <adf-media-player [urlFile]="urlFileContent" [mimeType]="mimeType" [blobFile]="blobFile" [nameFile]="displayName"></adf-media-player>
                              </ng-container>

                              <ng-container *ngSwitchCase="'text'">
                                  <adf-txt-viewer [urlFile]="urlFileContent" [blobFile]="blobFile"></adf-txt-viewer>
                              </ng-container>

                              <ng-container *ngSwitchCase="'custom'">
                                  <span *ngFor="let extensionTemplate of extensionTemplates">
                                      <ng-template *ngIf="extensionTemplate.isVisible" [ngTemplateOutlet]="extensionTemplate.template" [ngTemplateOutletContext]="{ urlFileContent: urlFileContent, extension:extension }">
                                      </ng-template>
                                  </span>
                              </ng-container>

                              <ng-container *ngSwitchDefault>
                                  <adf-viewer-unknown-format></adf-viewer-unknown-format>
                              </ng-container>

                          </div>
                      </div>
                  </div>
              </div>
          </div>
      </div>
    `,
                styles: [`

    `],
                host: { 'class': 'adf-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
ViewerComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
    { type: Location, },
    { type: RenditionsService, },
];
ViewerComponent.propDecorators = {
    'toolbar': [{ type: ContentChild, args: [ViewerToolbarComponent,] },],
    'sidebar': [{ type: ContentChild, args: [ViewerSidebarComponent,] },],
    'mnuOpenWith': [{ type: ContentChild, args: [ViewerOpenWithComponent,] },],
    'mnuMoreActions': [{ type: ContentChild, args: [ViewerMoreActionsComponent,] },],
    'urlFile': [{ type: Input },],
    'blobFile': [{ type: Input },],
    'fileNodeId': [{ type: Input },],
    'overlayMode': [{ type: Input },],
    'showViewer': [{ type: Input },],
    'showToolbar': [{ type: Input },],
    'displayName': [{ type: Input },],
    'allowGoBack': [{ type: Input },],
    'allowDownload': [{ type: Input },],
    'allowPrint': [{ type: Input },],
    'allowShare': [{ type: Input },],
    'allowSidebar': [{ type: Input },],
    'showSidebar': [{ type: Input },],
    'sidebarPosition': [{ type: Input },],
    'sidebarTemplate': [{ type: Input },],
    'goBack': [{ type: Output },],
    'download': [{ type: Output },],
    'print': [{ type: Output },],
    'share': [{ type: Output },],
    'showViewerChange': [{ type: Output },],
    'extensionChange': [{ type: Output },],
    'handleKeyboardEvent': [{ type: HostListener, args: ['document:keydown', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerExtensionDirective {
    /**
     * @param {?} viewerComponent
     */
    constructor(viewerComponent) {
        this.viewerComponent = viewerComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templateModel = { template: this.template, isVisible: false };
        this.viewerComponent.extensionTemplates.push(this.templateModel);
        this.viewerComponent.extensionChange.subscribe((fileExtension) => {
            this.templateModel.isVisible = this.isVisible(fileExtension);
        });
        if (this.supportedExtensions instanceof Array) {
            this.supportedExtensions.forEach((extension) => {
                this.viewerComponent.externalExtensions.push(extension);
            });
        }
    }
    /**
     * check if the current extension in the viewer is compatible with this extension checking against supportedExtensions
     *
     * @param {?} fileExtension
     * @return {?}
     */
    isVisible(fileExtension) {
        let /** @type {?} */ supportedExtension;
        if (this.supportedExtensions && (this.supportedExtensions instanceof Array)) {
            supportedExtension = this.supportedExtensions.find((extension) => {
                return extension.toLowerCase() === fileExtension;
            });
        }
        return !!supportedExtension;
    }
}
ViewerExtensionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-viewer-extension'
            },] },
];
/**
 * @nocollapse
 */
ViewerExtensionDirective.ctorParameters = () => [
    { type: ViewerComponent, },
];
ViewerExtensionDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
    'urlFileContent': [{ type: Input },],
    'extension': [{ type: Input },],
    'supportedExtensions': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerModule {
}
ViewerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    ToolbarModule,
                    PipeModule,
                    FlexLayoutModule
                ],
                declarations: [
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent
                ],
                exports: [
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
ViewerModule.ctorParameters = () => [];

class FormDefinitionModel {
    /**
     * @param {?} id
     * @param {?} name
     * @param {?} lastUpdatedByFullName
     * @param {?} lastUpdated
     * @param {?} metadata
     */
    constructor(id, name, lastUpdatedByFullName, lastUpdated, metadata) {
        this.reusable = false;
        this.newVersion = false;
        this.formImageBase64 = '';
        this.formRepresentation = {
            id: id,
            name: name,
            description: '',
            version: 1,
            lastUpdatedBy: 1,
            lastUpdatedByFullName: lastUpdatedByFullName,
            lastUpdated: lastUpdated,
            stencilSetId: 0,
            referenceId: null,
            formDefinition: {
                fields: [{
                        name: 'Label',
                        type: 'container',
                        fieldType: 'ContainerRepresentation',
                        numberOfColumns: 2,
                        required: false,
                        readOnly: false,
                        sizeX: 2,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        fields: { '1': this.metadataToFields(metadata) }
                    }],
                gridsterForm: false,
                javascriptEvents: [],
                metadata: {},
                outcomes: [],
                className: '',
                style: '',
                tabs: [],
                variables: []
            }
        };
    }
    /**
     * @param {?} metadata
     * @return {?}
     */
    metadataToFields(metadata) {
        let /** @type {?} */ fields = [];
        if (metadata) {
            metadata.forEach(function (property) {
                if (property) {
                    let /** @type {?} */ field = {
                        type: 'text',
                        id: property.name,
                        name: property.name,
                        required: false,
                        readOnly: false,
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        colspan: 1,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        layout: {
                            colspan: 1,
                            row: -1,
                            column: -1
                        }
                    };
                    fields.push(field);
                }
            });
        }
        return fields;
    }
}

class FormFieldTypes {
    /**
     * @param {?} type
     * @return {?}
     */
    static isReadOnlyType(type) {
        return FormFieldTypes.READONLY_TYPES.indexOf(type) > -1;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    static isContainerType(type) {
        return type === FormFieldTypes.CONTAINER || type === FormFieldTypes.GROUP;
    }
}
FormFieldTypes.CONTAINER = 'container';
FormFieldTypes.GROUP = 'group';
FormFieldTypes.DYNAMIC_TABLE = 'dynamic-table';
FormFieldTypes.TEXT = 'text';
FormFieldTypes.MULTILINE_TEXT = 'multi-line-text';
FormFieldTypes.DROPDOWN = 'dropdown';
FormFieldTypes.HYPERLINK = 'hyperlink';
FormFieldTypes.RADIO_BUTTONS = 'radio-buttons';
FormFieldTypes.DISPLAY_VALUE = 'readonly';
FormFieldTypes.READONLY_TEXT = 'readonly-text';
FormFieldTypes.UPLOAD = 'upload';
FormFieldTypes.TYPEAHEAD = 'typeahead';
FormFieldTypes.FUNCTIONAL_GROUP = 'functional-group';
FormFieldTypes.PEOPLE = 'people';
FormFieldTypes.BOOLEAN = 'boolean';
FormFieldTypes.NUMBER = 'integer';
FormFieldTypes.DATE = 'date';
FormFieldTypes.AMOUNT = 'amount';
FormFieldTypes.DOCUMENT = 'document';
FormFieldTypes.READONLY_TYPES = [
    FormFieldTypes.HYPERLINK,
    FormFieldTypes.DISPLAY_VALUE,
    FormFieldTypes.READONLY_TEXT
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @abstract
 */
class FormWidgetModel {
    /**
     * @param {?} form
     * @param {?} json
     */
    constructor(form, json) {
        this.form = form;
        this.json = json;
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this.tab = json.tab;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContainerColumnModel {
    constructor() {
        this.size = 12;
        this.fields = [];
        this.colspan = 1;
        this.rowspan = 1;
    }
    /**
     * @return {?}
     */
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
}

class ErrorMessageModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.message = '';
        this.attributes = null;
        this.message = obj && obj.message ? obj.message : '';
        this.attributes = new Map();
    }
    /**
     * @return {?}
     */
    isActive() {
        return this.message ? true : false;
    }
    /**
     * @return {?}
     */
    getAttributesAsJsonObj() {
        let /** @type {?} */ result = {};
        if (this.attributes.size > 0) {
            let /** @type {?} */ obj = Object.create(null);
            this.attributes.forEach((value, key) => {
                obj[key] = value;
            });
            result = JSON.stringify(obj);
        }
        return result;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class RequiredFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT,
            FormFieldTypes.NUMBER,
            FormFieldTypes.TYPEAHEAD,
            FormFieldTypes.DROPDOWN,
            FormFieldTypes.PEOPLE,
            FormFieldTypes.FUNCTIONAL_GROUP,
            FormFieldTypes.RADIO_BUTTONS,
            FormFieldTypes.UPLOAD,
            FormFieldTypes.AMOUNT,
            FormFieldTypes.DYNAMIC_TABLE,
            FormFieldTypes.DATE
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.required;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field)) {
            if (field.type === FormFieldTypes.DROPDOWN) {
                if (field.hasEmptyValue && field.emptyOption) {
                    if (field.value === field.emptyOption.id) {
                        return false;
                    }
                }
            }
            if (field.type === FormFieldTypes.RADIO_BUTTONS) {
                let /** @type {?} */ option = field.options.find(opt => opt.id === field.value);
                return !!option;
            }
            if (field.type === FormFieldTypes.UPLOAD) {
                return field.value && field.value.length > 0;
            }
            if (field.type === FormFieldTypes.DYNAMIC_TABLE) {
                return field.value && field.value instanceof Array && field.value.length > 0;
            }
            if (field.value === null || field.value === undefined || field.value === '') {
                return false;
            }
        }
        return true;
    }
}
class NumberFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field)) {
            if (field.value === null ||
                field.value === undefined ||
                field.value === '') {
                return true;
            }
            let /** @type {?} */ valueStr = '' + field.value;
            let /** @type {?} */ pattern = new RegExp(/^-?\d+$/);
            if (field.enableFractions) {
                pattern = new RegExp(/^-?[0-9]+(\.[0-9]{1,2})?$/);
            }
            if (valueStr.match(pattern)) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_NUMBER';
            return false;
        }
        return true;
    }
}
class DateFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    /**
     * @param {?} inputDate
     * @param {?=} dateFormat
     * @return {?}
     */
    static isValidDate(inputDate, dateFormat = 'D-M-YYYY') {
        if (inputDate) {
            let /** @type {?} */ d = moment(inputDate, dateFormat, true);
            return d.isValid();
        }
        return false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            if (DateFieldValidator.isValidDate(field.value, field.dateDisplayFormat)) {
                return true;
            }
            field.validationSummary.message = field.dateDisplayFormat;
            return false;
        }
        return true;
    }
}
class MinDateFieldValidator {
    constructor() {
        this.MIN_DATE_FORMAT = 'DD-MM-YYYY';
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.minValue;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            const /** @type {?} */ dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                return false;
            }
            // remove time and timezone info
            let /** @type {?} */ d;
            if (typeof field.value === 'string') {
                d = moment(field.value.split('T')[0], dateFormat);
            }
            else {
                d = field.value;
            }
            let /** @type {?} */ min = moment(field.minValue, this.MIN_DATE_FORMAT);
            if (d.isBefore(min)) {
                field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
                field.validationSummary.attributes.set('minValue', field.minValue.toLocaleString());
                return false;
            }
        }
        return true;
    }
}
class MaxDateFieldValidator {
    constructor() {
        this.MAX_DATE_FORMAT = 'DD-MM-YYYY';
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.maxValue;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            const /** @type {?} */ dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                return false;
            }
            // remove time and timezone info
            let /** @type {?} */ d;
            if (typeof field.value === 'string') {
                d = moment(field.value.split('T')[0], dateFormat);
            }
            else {
                d = field.value;
            }
            let /** @type {?} */ max = moment(field.maxValue, this.MAX_DATE_FORMAT);
            if (d.isAfter(max)) {
                field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
                field.validationSummary.attributes.set('maxValue', field.maxValue.toLocaleString());
                return false;
            }
        }
        return true;
    }
}
class MinLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.minLength > 0;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            if (field.value.length >= field.minLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.AT_LEAST_LONG`;
            field.validationSummary.attributes.set('minLength', field.minLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.maxLength > 0;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            if (field.value.length <= field.maxLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NO_LONGER_THAN`;
            field.validationSummary.attributes.set('maxLength', field.maxLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MinValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.minValue);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            let /** @type {?} */ value = +field.value;
            let /** @type {?} */ minValue = +field.minValue;
            if (value >= minValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', field.minValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.maxValue);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            let /** @type {?} */ value = +field.value;
            let /** @type {?} */ maxValue = +field.maxValue;
            if (value <= maxValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', field.maxValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class RegExFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.regexPattern;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value) {
            if (field.value.length > 0 && field.value.match(new RegExp('^' + field.regexPattern + '$'))) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            return false;
        }
        return true;
    }
}
class FixedValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TYPEAHEAD
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasValidNameOrValidId(field) {
        return this.hasValidName(field) || this.hasValidId(field);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasValidName(field) {
        return field.options.find(item => item.name && item.name.toLocaleLowerCase() === field.value.toLocaleLowerCase()) ? true : false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasValidId(field) {
        return field.options[field.value - 1] ? true : false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasStringValue(field) {
        return field.value && typeof field.value === 'string';
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasOptions(field) {
        return field.options && field.options.length > 0;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field)) {
            if (this.hasStringValue(field) && this.hasOptions(field) && !this.hasValidNameOrValidId(field)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
                return false;
            }
        }
        return true;
    }
}
const FORM_FIELD_VALIDATORS = [
    new RequiredFieldValidator(),
    new NumberFieldValidator(),
    new MinLengthFieldValidator(),
    new MaxLengthFieldValidator(),
    new MinValueFieldValidator(),
    new MaxValueFieldValidator(),
    new RegExFieldValidator(),
    new DateFieldValidator(),
    new MinDateFieldValidator(),
    new MaxDateFieldValidator(),
    new FixedValueFieldValidator()
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class FormFieldModel extends FormWidgetModel {
    /**
     * @param {?} form
     * @param {?=} json
     */
    constructor(form, json) {
        super(form, json);
        this._readOnly = false;
        this._isValid = true;
        this._required = false;
        this.defaultDateFormat = 'D-M-YYYY';
        this.rowspan = 1;
        this.colspan = 1;
        this.placeholder = null;
        this.minLength = 0;
        this.maxLength = 0;
        this.options = [];
        this.params = {};
        this.isVisible = true;
        this.visibilityCondition = null;
        this.enableFractions = false;
        this.currency = null;
        this.dateDisplayFormat = this.dateDisplayFormat || this.defaultDateFormat;
        // container model members
        this.numberOfColumns = 1;
        this.fields = [];
        this.columns = [];
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this._required = json.required;
            this._readOnly = json.readOnly || json.type === 'readonly';
            this.overrideId = json.overrideId;
            this.tab = json.tab;
            this.restUrl = json.restUrl;
            this.restResponsePath = json.restResponsePath;
            this.restIdProperty = json.restIdProperty;
            this.restLabelProperty = json.restLabelProperty;
            this.colspan = json.colspan;
            this.minLength = json.minLength || 0;
            this.maxLength = json.maxLength || 0;
            this.minValue = json.minValue;
            this.maxValue = json.maxValue;
            this.regexPattern = json.regexPattern;
            this.options = json.options || [];
            this.hasEmptyValue = json.hasEmptyValue;
            this.className = json.className;
            this.optionType = json.optionType;
            this.params = json.params || {};
            this.hyperlinkUrl = json.hyperlinkUrl;
            this.displayText = json.displayText;
            this.visibilityCondition = json.visibilityCondition;
            this.enableFractions = json.enableFractions;
            this.currency = json.currency;
            this.dateDisplayFormat = json.dateDisplayFormat || this.defaultDateFormat;
            this._value = this.parseValue(json);
            this.validationSummary = new ErrorMessageModel();
            if (json.placeholder && json.placeholder !== '' && json.placeholder !== 'null') {
                this.placeholder = json.placeholder;
            }
            if (FormFieldTypes.isReadOnlyType(json.type)) {
                if (json.params && json.params.field) {
                    if (form.processVariables) {
                        const processVariable = this.getProcessVariableValue(json.params.field, form);
                        if (processVariable) {
                            this.value = processVariable;
                        }
                    }
                    else if (json.params.field.responseVariable) {
                        const formVariable = this.getVariablesValue(json.params.field.name, form);
                        if (formVariable) {
                            this.value = formVariable;
                        }
                    }
                }
            }
            if (FormFieldTypes.isContainerType(json.type)) {
                this.containerFactory(json, form);
            }
        }
        if (this.hasEmptyValue && this.options && this.options.length > 0) {
            this.emptyOption = this.options[0];
        }
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        this._value = v;
        this.validate();
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get readOnly() {
        if (this.form && this.form.readOnly) {
            return true;
        }
        return this._readOnly;
    }
    /**
     * @param {?} readOnly
     * @return {?}
     */
    set readOnly(readOnly) {
        this._readOnly = readOnly;
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = value;
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get isValid() {
        return this._isValid;
    }
    /**
     * @return {?}
     */
    markAsInvalid() {
        this._isValid = false;
    }
    /**
     * @return {?}
     */
    validate() {
        this.validationSummary = new ErrorMessageModel();
        let /** @type {?} */ validators = this.form.fieldValidators || [];
        for (let /** @type {?} */ validator of validators) {
            if (!validator.validate(this)) {
                this._isValid = false;
                return this._isValid;
            }
        }
        this._isValid = true;
        return this._isValid;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    isTypeaHeadFieldType(type) {
        return type === 'typeahead' ? true : false;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    getFieldNameWithLabel(name) {
        return name += '_LABEL';
    }
    /**
     * @param {?} field
     * @param {?} form
     * @return {?}
     */
    getProcessVariableValue(field, form) {
        let /** @type {?} */ fieldName = field.name;
        if (this.isTypeaHeadFieldType(field.type)) {
            fieldName = this.getFieldNameWithLabel(field.id);
        }
        return this.findProcessVariableValue(fieldName, form);
    }
    /**
     * @param {?} variableName
     * @param {?} form
     * @return {?}
     */
    getVariablesValue(variableName, form) {
        let /** @type {?} */ variable = form.json.variables.find((currentVariable) => {
            return currentVariable.name === variableName;
        });
        if (variable) {
            if (variable.type === 'boolean') {
                return JSON.parse(variable.value);
            }
            return variable.value;
        }
        return null;
    }
    /**
     * @param {?} variableName
     * @param {?} form
     * @return {?}
     */
    findProcessVariableValue(variableName, form) {
        if (form.processVariables) {
            const /** @type {?} */ variable = form.processVariables.find((currentVariable) => {
                return currentVariable.name === variableName;
            });
            if (variable) {
                return variable.type === 'boolean' ? JSON.parse(variable.value) : variable.value;
            }
        }
        return undefined;
    }
    /**
     * @param {?} json
     * @param {?} form
     * @return {?}
     */
    containerFactory(json, form) {
        this.numberOfColumns = /** @type {?} */ (json.numberOfColumns) || 1;
        this.fields = json.fields;
        this.rowspan = 1;
        this.colspan = 1;
        if (json.fields) {
            for (let /** @type {?} */ currentField in json.fields) {
                if (json.fields.hasOwnProperty(currentField)) {
                    let /** @type {?} */ col = new ContainerColumnModel();
                    let /** @type {?} */ fields = (json.fields[currentField] || []).map(f => new FormFieldModel(form, f));
                    col.fields = fields;
                    col.rowspan = json.fields[currentField].length;
                    col.fields.forEach((colFields) => {
                        this.colspan = colFields.colspan > this.colspan ? colFields.colspan : this.colspan;
                    });
                    this.rowspan = this.rowspan < col.rowspan ? col.rowspan : this.rowspan;
                    this.columns.push(col);
                }
            }
        }
    }
    /**
     * @param {?} json
     * @return {?}
     */
    parseValue(json) {
        let /** @type {?} */ value = json.value;
        /*
         This is needed due to Activiti issue related to reading dropdown values as value string
         but saving back as object: { id: <id>, name: <name> }
         */
        if (json.type === FormFieldTypes.DROPDOWN) {
            if (json.hasEmptyValue && json.options) {
                let /** @type {?} */ options = (json.options) || [];
                if (options.length > 0) {
                    let /** @type {?} */ emptyOption = json.options[0];
                    if (value === '' || value === emptyOption.id || value === emptyOption.name) {
                        value = emptyOption.id;
                    }
                }
            }
        }
        /*
         This is needed due to Activiti issue related to reading radio button values as value string
         but saving back as object: { id: <id>, name: <name> }
         */
        if (json.type === FormFieldTypes.RADIO_BUTTONS) {
            // Activiti has a bug with default radio button value where initial selection passed as `name` value
            // so try resolving current one with a fallback to first entry via name or id
            // TODO: needs to be reported and fixed at Activiti side
            let /** @type {?} */ entry = this.options.filter(opt => opt.id === value || opt.name === value);
            if (entry.length > 0) {
                value = entry[0].id;
            }
        }
        /*
         This is needed due to Activiti displaying/editing dates in d-M-YYYY format
         but storing on server in ISO8601 format (i.e. 2013-02-04T22:44:30.652Z)
         */
        if (this.isDateField(json)) {
            if (value) {
                let /** @type {?} */ dateValue;
                if (NumberFieldValidator.isNumber(value)) {
                    dateValue = moment(value);
                }
                else {
                    dateValue = moment(value.split('T')[0], 'YYYY-M-D');
                }
                if (dateValue && dateValue.isValid()) {
                    value = dateValue.format(this.dateDisplayFormat);
                }
            }
        }
        return value;
    }
    /**
     * @return {?}
     */
    updateForm() {
        if (!this.form) {
            return;
        }
        switch (this.type) {
            case FormFieldTypes.DROPDOWN:
                /*
                 This is needed due to Activiti reading dropdown values as string
                 but saving back as object: { id: <id>, name: <name> }
                 */
                if (this.value === 'empty' || this.value === '') {
                    this.form.values[this.id] = {};
                }
                else {
                    let /** @type {?} */ entry = this.options.filter(opt => opt.id === this.value);
                    if (entry.length > 0) {
                        this.form.values[this.id] = entry[0];
                    }
                }
                break;
            case FormFieldTypes.RADIO_BUTTONS:
                /*
                 This is needed due to Activiti issue related to reading radio button values as value string
                 but saving back as object: { id: <id>, name: <name> }
                 */
                let /** @type {?} */ rbEntry = this.options.filter(opt => opt.id === this.value);
                if (rbEntry.length > 0) {
                    this.form.values[this.id] = rbEntry[0];
                }
                break;
            case FormFieldTypes.UPLOAD:
                if (this.value && this.value.length > 0) {
                    this.form.values[this.id] = this.value.map(elem => elem.id).join(',');
                }
                else {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.TYPEAHEAD:
                let /** @type {?} */ taEntry = this.options.filter(opt => opt.id === this.value);
                if (taEntry.length > 0) {
                    this.form.values[this.id] = taEntry[0];
                }
                else if (this.options.length > 0) {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.DATE:
                let /** @type {?} */ dateValue = moment(this.value, this.dateDisplayFormat, true);
                if (dateValue && dateValue.isValid()) {
                    this.form.values[this.id] = `${dateValue.format('YYYY-MM-DD')}T00:00:00.000Z`;
                }
                else {
                    this.form.values[this.id] = null;
                    this._value = this.value;
                }
                break;
            case FormFieldTypes.NUMBER:
                this.form.values[this.id] = parseInt(this.value, 10);
                break;
            case FormFieldTypes.AMOUNT:
                this.form.values[this.id] = this.enableFractions ? parseFloat(this.value) : parseInt(this.value, 10);
                break;
            default:
                if (!FormFieldTypes.isReadOnlyType(this.type) && !this.isInvalidFieldType(this.type)) {
                    this.form.values[this.id] = this.value;
                }
        }
        this.form.onFormFieldChanged(this);
    }
    /**
     * Skip the invalid field type
     * @param {?} type
     * @return {?}
     */
    isInvalidFieldType(type) {
        if (type === 'container') {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    getOptionName() {
        let /** @type {?} */ option = this.options.find(opt => opt.id === this.value);
        return option ? option.name : null;
    }
    /**
     * @return {?}
     */
    hasOptions() {
        return this.options && this.options.length > 0;
    }
    /**
     * @param {?} json
     * @return {?}
     */
    isDateField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.DATE) ||
            json.type === FormFieldTypes.DATE;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormEvent {
    /**
     * @param {?} form
     */
    constructor(form) {
        this.isDefaultPrevented = false;
        this.form = form;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this.isDefaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormErrorEvent extends FormEvent {
    /**
     * @param {?} form
     * @param {?} error
     */
    constructor(form, error) {
        super(form);
        this.error = error;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormFieldEvent extends FormEvent {
    /**
     * @param {?} form
     * @param {?} field
     */
    constructor(form, field) {
        super(form);
        this.field = field;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValidateFormFieldEvent extends FormFieldEvent {
    /**
     * @param {?} form
     * @param {?} field
     */
    constructor(form, field) {
        super(form, field);
        this.isValid = true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValidateFormEvent extends FormEvent {
    /**
     * @param {?} form
     */
    constructor(form) {
        super(form);
        this.isValid = true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValidateDynamicTableRowEvent extends FormFieldEvent {
    /**
     * @param {?} form
     * @param {?} field
     * @param {?} row
     * @param {?} summary
     */
    constructor(form, field, row, summary) {
        super(form, field);
        this.row = row;
        this.summary = summary;
        this.isValid = true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContainerModel extends FormWidgetModel {
    /**
     * @return {?}
     */
    get isVisible() {
        return this.field.isVisible;
    }
    /**
     * @param {?} field
     */
    constructor(field) {
        super(field.form, field.json);
        if (field) {
            this.field = field;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class FormOutcomeModel extends FormWidgetModel {
    /**
     * @param {?} form
     * @param {?=} json
     */
    constructor(form, json) {
        super(form, json);
        this.isSystem = false;
        this.isSelected = false;
        if (json) {
            this.isSystem = json.isSystem ? true : false;
            this.isSelected = form && json.name === form.selectedOutcome ? true : false;
        }
    }
}
FormOutcomeModel.SAVE_ACTION = 'Save'; // Activiti 'Save' action name
FormOutcomeModel.COMPLETE_ACTION = 'Complete'; // Activiti 'Complete' action name
FormOutcomeModel.START_PROCESS_ACTION = 'Start Process'; // Activiti 'Start Process' action name

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TabModel extends FormWidgetModel {
    /**
     * @param {?} form
     * @param {?=} json
     */
    constructor(form, json) {
        super(form, json);
        this.isVisible = true;
        this.fields = [];
        if (json) {
            this.title = json.title;
            this.visibilityCondition = json.visibilityCondition;
        }
    }
    /**
     * @return {?}
     */
    hasContent() {
        return this.fields && this.fields.length > 0;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class FormModel {
    /**
     * @param {?=} json
     * @param {?=} data
     * @param {?=} readOnly
     * @param {?=} formService
     */
    constructor(json, data, readOnly = false, formService) {
        this.formService = formService;
        this.taskName = FormModel.UNSET_TASK_NAME;
        this._isValid = true;
        this.readOnly = false;
        this.tabs = [];
        /**
         * Stores root containers
         */
        this.fields = [];
        this.outcomes = [];
        this.customFieldTemplates = {};
        this.fieldValidators = [...FORM_FIELD_VALIDATORS];
        this.values = {};
        this.readOnly = readOnly;
        if (json) {
            this.json = json;
            this.id = json.id;
            this.name = json.name;
            this.taskId = json.taskId;
            this.taskName = json.taskName || json.name || FormModel.UNSET_TASK_NAME;
            this.processDefinitionId = json.processDefinitionId;
            this.customFieldTemplates = json.customFieldTemplates || {};
            this.selectedOutcome = json.selectedOutcome || {};
            this.className = json.className || '';
            let tabCache = {};
            this.processVariables = json.processVariables;
            this.tabs = (json.tabs || []).map(t => {
                let model = new TabModel(this, t);
                tabCache[model.id] = model;
                return model;
            });
            this.fields = this.parseRootFields(json);
            if (data) {
                this.loadData(data);
            }
            for (let i = 0; i < this.fields.length; i++) {
                let field = this.fields[i];
                if (field.tab) {
                    let tab = tabCache[field.tab];
                    if (tab) {
                        tab.fields.push(field);
                    }
                }
            }
            if (json.fields) {
                let saveOutcome = new FormOutcomeModel(this, { id: FormModel.SAVE_OUTCOME, name: 'Save', isSystem: true });
                let completeOutcome = new FormOutcomeModel(this, { id: FormModel.COMPLETE_OUTCOME, name: 'Complete', isSystem: true });
                let startProcessOutcome = new FormOutcomeModel(this, { id: FormModel.START_PROCESS_OUTCOME, name: 'Start Process', isSystem: true });
                let customOutcomes = (json.outcomes || []).map(obj => new FormOutcomeModel(this, obj));
                this.outcomes = [saveOutcome].concat(customOutcomes.length > 0 ? customOutcomes : [completeOutcome, startProcessOutcome]);
            }
        }
        this.validateForm();
    }
    /**
     * @return {?}
     */
    get isValid() {
        return this._isValid;
    }
    /**
     * @return {?}
     */
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    /**
     * @return {?}
     */
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
    /**
     * @return {?}
     */
    hasOutcomes() {
        return this.outcomes && this.outcomes.length > 0;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    onFormFieldChanged(field) {
        this.validateField(field);
        if (this.formService) {
            this.formService.formFieldValueChanged.next(new FormFieldEvent(this, field));
        }
    }
    /**
     * @param {?} fieldId
     * @return {?}
     */
    getFieldById(fieldId) {
        return this.getFormFields().find(field => field.id === fieldId);
    }
    /**
     * @return {?}
     */
    getFormFields() {
        let /** @type {?} */ result = [];
        for (let /** @type {?} */ i = 0; i < this.fields.length; i++) {
            let /** @type {?} */ field = this.fields[i];
            if (field instanceof ContainerModel) {
                let /** @type {?} */ container = (field);
                result.push(container.field);
                container.field.columns.forEach((column) => {
                    result.push(...column.fields);
                });
            }
        }
        return result;
    }
    /**
     * @return {?}
     */
    markAsInvalid() {
        this._isValid = false;
    }
    /**
     * Validates entire form and all form fields.
     *
     * \@memberof FormModel
     * @return {?}
     */
    validateForm() {
        const /** @type {?} */ validateFormEvent = new ValidateFormEvent(this);
        if (this.formService) {
            this.formService.validateForm.next(validateFormEvent);
        }
        this._isValid = validateFormEvent.isValid;
        if (validateFormEvent.defaultPrevented) {
            return;
        }
        if (validateFormEvent.isValid) {
            let /** @type {?} */ fields = this.getFormFields();
            for (let /** @type {?} */ i = 0; i < fields.length; i++) {
                if (!fields[i].validate()) {
                    this._isValid = false;
                    return;
                }
            }
        }
    }
    /**
     * Validates a specific form field, triggers form validation.
     *
     * \@memberof FormModel
     * @param {?} field
     * @return {?}
     */
    validateField(field) {
        if (!field) {
            return;
        }
        const /** @type {?} */ validateFieldEvent = new ValidateFormFieldEvent(this, field);
        if (this.formService) {
            this.formService.validateFormField.next(validateFieldEvent);
        }
        if (!validateFieldEvent.isValid) {
            this._isValid = false;
            return;
        }
        if (validateFieldEvent.defaultPrevented) {
            return;
        }
        if (!field.validate()) {
            this._isValid = false;
            return;
        }
        this.validateForm();
    }
    /**
     * @param {?} json
     * @return {?}
     */
    parseRootFields(json) {
        let /** @type {?} */ fields = [];
        if (json.fields) {
            fields = json.fields;
        }
        else if (json.formDefinition && json.formDefinition.fields) {
            fields = json.formDefinition.fields;
        }
        let /** @type {?} */ result = [];
        for (let /** @type {?} */ field of fields) {
            if (field.type === FormFieldTypes.DISPLAY_VALUE) {
                // workaround for dynamic table on a completed/readonly form
                if (field.params) {
                    let /** @type {?} */ originalField = field.params['field'];
                    if (originalField.type === FormFieldTypes.DYNAMIC_TABLE) {
                        result.push(new ContainerModel(new FormFieldModel(this, field)));
                    }
                }
            }
            else {
                result.push(new ContainerModel(new FormFieldModel(this, field)));
            }
        }
        return result;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    loadData(data) {
        for (let /** @type {?} */ field of this.getFormFields()) {
            if (data[field.id]) {
                field.json.value = data[field.id];
                field.value = field.parseValue(field.json);
                if (field.type === FormFieldTypes.DROPDOWN ||
                    field.type === FormFieldTypes.RADIO_BUTTONS) {
                    field.value = data[field.id].id;
                }
            }
        }
    }
}
FormModel.UNSET_TASK_NAME = 'Nameless task';
FormModel.SAVE_OUTCOME = '$save';
FormModel.COMPLETE_OUTCOME = '$complete';
FormModel.START_PROCESS_OUTCOME = '$startProcess';

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormOutcomeEvent {
    /**
     * @param {?} outcome
     */
    constructor(outcome) {
        this._defaultPrevented = false;
        this._outcome = outcome;
    }
    /**
     * @return {?}
     */
    get outcome() {
        return this._outcome;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentLinkModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.contentAvailable = obj && obj.contentAvailable;
        this.created = obj && obj.created;
        this.createdBy = obj && obj.createdBy || {};
        this.id = obj && obj.id;
        this.link = obj && obj.link;
        this.mimeType = obj && obj.mimeType;
        this.name = obj && obj.name;
        this.previewStatus = obj && obj.previewStatus;
        this.relatedContent = obj && obj.relatedContent;
        this.simpleType = obj && obj.simpleType;
        this.thumbnailStatus = obj && obj.thumbnailStatus;
    }
    /**
     * @return {?}
     */
    hasPreviewStatus() {
        return this.previewStatus === 'supported' ? true : false;
    }
    /**
     * @return {?}
     */
    isTypeImage() {
        return this.simpleType === 'image' ? true : false;
    }
    /**
     * @return {?}
     */
    isTypePdf() {
        return this.simpleType === 'pdf' ? true : false;
    }
    /**
     * @return {?}
     */
    isTypeDoc() {
        return this.simpleType === 'word' || this.simpleType === 'content' ? true : false;
    }
    /**
     * @return {?}
     */
    isThumbnailReady() {
        return this.thumbnailStatus === 'created';
    }
    /**
     * @return {?}
     */
    isThumbnailSupported() {
        return this.isTypeImage() || ((this.isTypePdf() || this.isTypeDoc()) && this.isThumbnailReady());
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EcmModelService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    createEcmTypeForActivitiForm(formName, form) {
        return Observable$1.create(observer => {
            this.searchActivitiEcmModel().subscribe(model => {
                if (!model) {
                    this.createActivitiEcmModel(formName, form).subscribe(typeForm => {
                        observer.next(typeForm);
                        observer.complete();
                    });
                }
                else {
                    this.saveFomType(formName, form).subscribe(typeForm => {
                        observer.next(typeForm);
                        observer.complete();
                    });
                }
            }, err => this.handleError(err));
        });
    }
    /**
     * @return {?}
     */
    searchActivitiEcmModel() {
        return this.getEcmModels().map(function (ecmModels) {
            return ecmModels.list.entries.find(model => model.entry.name === EcmModelService.MODEL_NAME);
        });
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    createActivitiEcmModel(formName, form) {
        return Observable$1.create(observer => {
            this.createEcmModel(EcmModelService.MODEL_NAME, EcmModelService.MODEL_NAMESPACE).subscribe(model => {
                this.logService.info('model created', model);
                this.activeEcmModel(EcmModelService.MODEL_NAME).subscribe(modelActive => {
                    this.logService.info('model active', modelActive);
                    this.createEcmTypeWithProperties(formName, form).subscribe(typeCreated => {
                        observer.next(typeCreated);
                        observer.complete();
                    });
                }, err => this.handleError(err));
            }, err => this.handleError(err));
        });
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    saveFomType(formName, form) {
        return Observable$1.create(observer => {
            this.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe(ecmType => {
                this.logService.info('custom types', ecmType);
                if (!ecmType) {
                    this.createEcmTypeWithProperties(formName, form).subscribe(typeCreated => {
                        observer.next(typeCreated);
                        observer.complete();
                    });
                }
                else {
                    observer.next(ecmType);
                    observer.complete();
                }
            }, err => this.handleError(err));
        });
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    createEcmTypeWithProperties(formName, form) {
        return Observable$1.create(observer => {
            this.createEcmType(formName, EcmModelService.MODEL_NAME, EcmModelService.TYPE_MODEL).subscribe(typeCreated => {
                this.logService.info('type Created', typeCreated);
                this.addPropertyToAType(EcmModelService.MODEL_NAME, formName, form).subscribe(properyAdded => {
                    this.logService.info('property Added', properyAdded);
                    observer.next(typeCreated);
                    observer.complete();
                }, err => this.handleError(err));
            }, err => this.handleError(err));
        });
    }
    /**
     * @param {?} typeName
     * @param {?} modelName
     * @return {?}
     */
    searchEcmType(typeName, modelName) {
        return this.getEcmType(modelName).map(function (customTypes) {
            return customTypes.list.entries.find(type => type.entry.prefixedName === typeName || type.entry.title === typeName);
        });
    }
    /**
     * @param {?} modelName
     * @return {?}
     */
    activeEcmModel(modelName) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.customModelApi.activateCustomModel(modelName))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} modelName
     * @param {?} nameSpace
     * @return {?}
     */
    createEcmModel(modelName, nameSpace) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.customModelApi.createCustomModel('DRAFT', '', modelName, modelName, nameSpace))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getEcmModels() {
        return Observable$1.fromPromise(this.apiService.getInstance().core.customModelApi.getAllCustomModel())
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} modelName
     * @return {?}
     */
    getEcmType(modelName) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.customModelApi.getAllCustomType(modelName))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} typeName
     * @param {?} modelName
     * @param {?} parentType
     * @return {?}
     */
    createEcmType(typeName, modelName, parentType) {
        let /** @type {?} */ name = this.cleanNameType(typeName);
        return Observable$1.fromPromise(this.apiService.getInstance().core.customModelApi.createCustomType(modelName, name, parentType, typeName, ''))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} modelName
     * @param {?} typeName
     * @param {?} formFields
     * @return {?}
     */
    addPropertyToAType(modelName, typeName, formFields) {
        let /** @type {?} */ name = this.cleanNameType(typeName);
        let /** @type {?} */ properties = [];
        if (formFields && formFields.values) {
            for (let /** @type {?} */ key in formFields.values) {
                if (key) {
                    properties.push({
                        name: key,
                        title: key,
                        description: key,
                        dataType: 'd:text',
                        multiValued: false,
                        mandatory: false,
                        mandatoryEnforced: false
                    });
                }
            }
        }
        return Observable$1.fromPromise(this.apiService.getInstance().core.customModelApi.addPropertyToType(modelName, name, properties))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} name
     * @return {?}
     */
    cleanNameType(name) {
        let /** @type {?} */ cleanName = name;
        if (name.indexOf(':') !== -1) {
            cleanName = name.split(':')[1];
        }
        return cleanName.replace(/[^a-zA-Z ]/g, '');
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        this.logService.error(err);
    }
}
EcmModelService.MODEL_NAMESPACE = 'activitiForms';
EcmModelService.MODEL_NAME = 'activitiFormsModel';
EcmModelService.TYPE_MODEL = 'cm:folder';
EcmModelService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
EcmModelService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormService {
    /**
     * @param {?} ecmModelService
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(ecmModelService, apiService, logService) {
        this.ecmModelService = ecmModelService;
        this.apiService = apiService;
        this.logService = logService;
        this.formLoaded = new Subject$1();
        this.formDataRefreshed = new Subject$1();
        this.formFieldValueChanged = new Subject$1();
        this.formEvents = new Subject$1();
        this.taskCompleted = new Subject$1();
        this.taskCompletedError = new Subject$1();
        this.taskSaved = new Subject$1();
        this.taskSavedError = new Subject$1();
        this.formContentClicked = new Subject$1();
        this.validateForm = new Subject$1();
        this.validateFormField = new Subject$1();
        this.validateDynamicTableRow = new Subject$1();
        this.executeOutcome = new Subject$1();
    }
    /**
     * @return {?}
     */
    get taskApi() {
        return this.apiService.getInstance().activiti.taskApi;
    }
    /**
     * @return {?}
     */
    get modelsApi() {
        return this.apiService.getInstance().activiti.modelsApi;
    }
    /**
     * @return {?}
     */
    get editorApi() {
        return this.apiService.getInstance().activiti.editorApi;
    }
    /**
     * @return {?}
     */
    get processApi() {
        return this.apiService.getInstance().activiti.processApi;
    }
    /**
     * @return {?}
     */
    get processInstanceVariablesApi() {
        return this.apiService.getInstance().activiti.processInstanceVariablesApi;
    }
    /**
     * @return {?}
     */
    get usersWorkflowApi() {
        return this.apiService.getInstance().activiti.usersWorkflowApi;
    }
    /**
     * @return {?}
     */
    get groupsApi() {
        return this.apiService.getInstance().activiti.groupsApi;
    }
    /**
     * @param {?} json
     * @param {?=} data
     * @param {?=} readOnly
     * @return {?}
     */
    parseForm(json, data, readOnly = false) {
        if (json) {
            let /** @type {?} */ form = new FormModel(json, data, readOnly, this);
            if (!json.fields) {
                form.outcomes = [
                    new FormOutcomeModel(form, {
                        id: '$custom',
                        name: FormOutcomeModel.SAVE_ACTION,
                        isSystem: true
                    })
                ];
            }
            return form;
        }
        return null;
    }
    /**
     * Create a Form with a fields for each metadata properties
     * @param {?} formName
     * @return {?}
     */
    createFormFromANode(formName) {
        return Observable$1.create(observer => {
            this.createForm(formName).subscribe(form => {
                this.ecmModelService.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe(customType => {
                    let /** @type {?} */ formDefinitionModel = new FormDefinitionModel(form.id, form.name, form.lastUpdatedByFullName, form.lastUpdated, customType.entry.properties);
                    this.addFieldsToAForm(form.id, formDefinitionModel).subscribe(formData => {
                        observer.next(formData);
                        observer.complete();
                    }, err => this.handleError(err));
                }, err => this.handleError(err));
            }, err => this.handleError(err));
        });
    }
    /**
     * Create a Form
     * @param {?} formName
     * @return {?}
     */
    createForm(formName) {
        let /** @type {?} */ dataModel = {
            name: formName,
            description: '',
            modelType: 2,
            stencilSet: 0
        };
        return Observable$1.fromPromise(this.modelsApi.createModel(dataModel));
    }
    /**
     * @param {?} formId
     * @param {?} formModel
     * @return {?}
     */
    saveForm(formId, formModel) {
        return Observable$1.fromPromise(this.editorApi.saveForm(formId, formModel));
    }
    /**
     * @deprecated in 1.7.0, use saveForm API instead
     * Add Fileds to A form
     * @param {?} formId
     * @param {?} formModel
     * @return {?}
     */
    addFieldsToAForm(formId, formModel) {
        this.logService.log('addFieldsToAForm is deprecated in 1.7.0, use saveForm API instead');
        return Observable$1.fromPromise(this.editorApi.saveForm(formId, formModel));
    }
    /**
     * Search For A Form by name
     * @param {?} name
     * @return {?}
     */
    searchFrom(name) {
        let /** @type {?} */ opts = {
            'modelType': 2
        };
        return Observable$1.fromPromise(this.modelsApi.getModels(opts))
            .map(function (forms$$1) {
            return forms$$1.data.find(formdata => formdata.name === name);
        })
            .catch(err => this.handleError(err));
    }
    /**
     * Get All the forms
     * @return {?}
     */
    getForms() {
        let /** @type {?} */ opts = {
            'modelType': 2
        };
        return Observable$1.fromPromise(this.modelsApi.getModels(opts))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    /**
     * Get Process Definitions
     * @return {?}
     */
    getProcessDefinitions() {
        return Observable$1.fromPromise(this.processApi.getProcessDefinitions({}))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getProcessVarablesById(processInstanceId) {
        return Observable$1.fromPromise(this.processInstanceVariablesApi.getProcessInstanceVariables(processInstanceId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * Get All the Tasks
     * @return {?}
     */
    getTasks() {
        return Observable$1.fromPromise(this.taskApi.listTasks({}))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    /**
     * Get Task
     * @param {?} taskId Task Id
     * @return {?}
     */
    getTask(taskId) {
        return Observable$1.fromPromise(this.taskApi.getTask(taskId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * Save Task Form
     * @param {?} taskId Task Id
     * @param {?} formValues Form Values
     * @return {?}
     */
    saveTaskForm(taskId, formValues) {
        let /** @type {?} */ body = JSON.stringify({ values: formValues });
        return Observable$1.fromPromise(this.taskApi.saveTaskForm(taskId, body))
            .catch(err => this.handleError(err));
    }
    /**
     * Complete Task Form
     * @param {?} taskId Task Id
     * @param {?} formValues Form Values
     * @param {?=} outcome Form Outcome
     * @return {?}
     */
    completeTaskForm(taskId, formValues, outcome) {
        let /** @type {?} */ data = { values: formValues };
        if (outcome) {
            data.outcome = outcome;
        }
        let /** @type {?} */ body = JSON.stringify(data);
        return Observable$1.fromPromise(this.taskApi.completeTaskForm(taskId, body))
            .catch(err => this.handleError(err));
    }
    /**
     * Get Form related to a taskId
     * @param {?} taskId Task Id
     * @return {?}
     */
    getTaskForm(taskId) {
        return Observable$1.fromPromise(this.taskApi.getTaskForm(taskId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * Get Form Definition
     * @param {?} formId Form Id
     * @return {?}
     */
    getFormDefinitionById(formId) {
        return Observable$1.fromPromise(this.editorApi.getForm(formId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * Returns form definition by a given name.
     * @param {?} name
     * @return {?}
     */
    getFormDefinitionByName(name) {
        let /** @type {?} */ opts = {
            'filter': 'myReusableForms',
            'filterText': name,
            'modelType': 2
        };
        return Observable$1.fromPromise(this.modelsApi.getModels(opts))
            .map(this.getFormId)
            .catch(err => this.handleError(err));
    }
    /**
     * Get start form instance for a given processId
     * @param {?} processId Process definition ID
     * @return {?}
     */
    getStartFormInstance(processId) {
        return Observable$1.fromPromise(this.processApi.getProcessInstanceStartForm(processId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    getProcessIntance(processId) {
        return Observable$1.fromPromise(this.processApi.getProcessInstance(processId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * Get start form definition for a given process
     * @param {?} processId Process definition ID
     * @return {?}
     */
    getStartFormDefinition(processId) {
        return Observable$1.fromPromise(this.processApi.getProcessDefinitionStartForm(processId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @param {?} field
     * @return {?}
     */
    getRestFieldValues(taskId, field) {
        return Observable$1.fromPromise(this.taskApi.getRestFieldValues(taskId, field)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} processDefinitionId
     * @param {?} field
     * @return {?}
     */
    getRestFieldValuesByProcessId(processDefinitionId, field) {
        return Observable$1.fromPromise(this.processApi.getRestFieldValues(processDefinitionId, field)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} processDefinitionId
     * @param {?} field
     * @param {?=} column
     * @return {?}
     */
    getRestFieldValuesColumnByProcessId(processDefinitionId, field, column) {
        return Observable$1.fromPromise(this.processApi.getRestTableFieldValues(processDefinitionId, field, column)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @param {?} field
     * @param {?=} column
     * @return {?}
     */
    getRestFieldValuesColumn(taskId, field, column) {
        return Observable$1.fromPromise(this.taskApi.getRestFieldValuesColumn(taskId, field, column)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    getUserProfileImageApi(userId) {
        return this.apiService.getInstance().activiti.userApi.getUserProfilePictureUrl(userId);
    }
    /**
     * @param {?} filter
     * @param {?=} groupId
     * @return {?}
     */
    getWorkflowUsers(filter$$1, groupId) {
        let /** @type {?} */ option = { filter: filter$$1 };
        if (groupId) {
            option.groupId = groupId;
        }
        return Observable$1.fromPromise(this.usersWorkflowApi.getUsers(option))
            .switchMap((response) => /** @type {?} */ (response.data) || [])
            .map((user) => {
            user.userImage = this.getUserProfileImageApi(user.id);
            return Observable$1.of(user);
        })
            .combineAll()
            .defaultIfEmpty([])
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} filter
     * @param {?=} groupId
     * @return {?}
     */
    getWorkflowGroups(filter$$1, groupId) {
        let /** @type {?} */ option = { filter: filter$$1 };
        if (groupId) {
            option.groupId = groupId;
        }
        return Observable$1.fromPromise(this.groupsApi.getGroups(option))
            .map((response) => /** @type {?} */ (response.data) || [])
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} res
     * @return {?}
     */
    getFormId(res) {
        let /** @type {?} */ result = null;
        if (res && res.data && res.data.length > 0) {
            result = res.data[0].id;
        }
        return result;
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        let /** @type {?} */ errMsg = FormService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : FormService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return Observable$1.throw(errMsg);
    }
}
FormService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
FormService.GENERIC_ERROR_MESSAGE = 'Server error';
FormService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
FormService.ctorParameters = () => [
    { type: EcmModelService, },
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
const baseHost = {
    '(click)': 'event($event)',
    '(blur)': 'event($event)',
    '(change)': 'event($event)',
    '(focus)': 'event($event)',
    '(focusin)': 'event($event)',
    '(focusout)': 'event($event)',
    '(input)': 'event($event)',
    '(invalid)': 'event($event)',
    '(select)': 'event($event)'
};
/**
 * Base widget component.
 */
class WidgetComponent {
    /**
     * @param {?=} formService
     */
    constructor(formService) {
        this.formService = formService;
        this.readOnly = false;
        /**
         * @deprecated used only to trigger visibility engine, components should do that internally if needed
         */
        this.fieldChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    hasField() {
        return this.field ? true : false;
    }
    /**
     * @return {?}
     */
    isRequired() {
        if (this.field && this.field.required) {
            return true;
        }
        return null;
    }
    /**
     * @return {?}
     */
    isValid() {
        return this.field.validationSummary ? true : false;
    }
    /**
     * @return {?}
     */
    hasValue() {
        return this.field &&
            this.field.value !== null &&
            this.field.value !== undefined;
    }
    /**
     * @return {?}
     */
    isInvalidFieldRequired() {
        return !this.field.isValid && !this.field.validationSummary && this.isRequired();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.fieldChanged.emit(this.field);
    }
    /**
     * @deprecated used only to trigger visibility engine, components should do that internally if needed
     * @param {?} field
     * @return {?}
     */
    checkVisibility(field) {
        this.fieldChanged.emit(field);
    }
    /**
     * @deprecated used only to trigger visibility engine, components should do that internally if needed
     * @param {?} field
     * @return {?}
     */
    onFieldChanged(field) {
        this.fieldChanged.emit(field);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getHyperlinkUrl(field) {
        let /** @type {?} */ url = WidgetComponent.DEFAULT_HYPERLINK_URL;
        if (field && field.hyperlinkUrl) {
            url = field.hyperlinkUrl;
            if (!/^https?:\/\//i.test(url)) {
                url = `${WidgetComponent.DEFAULT_HYPERLINK_SCHEME}${url}`;
            }
        }
        return url;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getHyperlinkText(field) {
        if (field) {
            return field.displayText || field.hyperlinkUrl;
        }
        return null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    event(event) {
        this.formService.formEvents.next(event);
    }
}
WidgetComponent.DEFAULT_HYPERLINK_URL = '#';
WidgetComponent.DEFAULT_HYPERLINK_SCHEME = 'http://';
WidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'base-widget',
                template: '',
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
WidgetComponent.ctorParameters = () => [
    { type: FormService, },
];
WidgetComponent.propDecorators = {
    'readOnly': [{ type: Input },],
    'field': [{ type: Input },],
    'fieldChanged': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContainerWidgetComponentModel extends ContainerModel {
    /**
     * @param {?} field
     */
    constructor(field) {
        super(field);
        this.columns = [];
        this.isExpanded = true;
        this.rowspan = 1;
        this.colspan = 1;
        if (this.field) {
            this.columns = this.field.columns || [];
            this.isExpanded = !this.isCollapsedByDefault();
            this.colspan = field.colspan;
            this.rowspan = field.rowspan;
        }
    }
    /**
     * @return {?}
     */
    isGroup() {
        return this.type === FormFieldTypes.GROUP;
    }
    /**
     * @return {?}
     */
    isCollapsible() {
        let /** @type {?} */ allowCollapse = false;
        if (this.isGroup() && this.field.params['allowCollapse']) {
            allowCollapse = /** @type {?} */ (this.field.params['allowCollapse']);
        }
        return allowCollapse;
    }
    /**
     * @return {?}
     */
    isCollapsedByDefault() {
        let /** @type {?} */ collapseByDefault = false;
        if (this.isCollapsible() && this.field.params['collapseByDefault']) {
            collapseByDefault = /** @type {?} */ (this.field.params['collapseByDefault']);
        }
        return collapseByDefault;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class ContainerWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    /**
     * @return {?}
     */
    onExpanderClicked() {
        if (this.content && this.content.isCollapsible()) {
            this.content.isExpanded = !this.content.isExpanded;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            this.content = new ContainerWidgetComponentModel(this.field);
        }
    }
    /**
     * Serializes column fields
     * @return {?}
     */
    get fields() {
        const /** @type {?} */ fields = [];
        let /** @type {?} */ rowContainsElement = true, /** @type {?} */ rowIndex = 0;
        while (rowContainsElement) {
            rowContainsElement = false;
            for (let /** @type {?} */ i = 0; i < this.content.columns.length; i++) {
                let /** @type {?} */ field = this.content.columns[i].fields[rowIndex];
                if (field) {
                    rowContainsElement = true;
                }
                fields.push(field);
            }
            rowIndex++;
        }
        return fields;
    }
    /**
     * Calculate the column width based on the numberOfColumns and current field's colspan property
     *
     * @param {?} field
     * @return {?}
     */
    getColumnWith(field) {
        const /** @type {?} */ colspan = field ? field.colspan : 1;
        return (100 / this.content.json.numberOfColumns) * colspan + '%';
    }
}
ContainerWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'container-widget',
                template: `
      <div [hidden]="!(content?.isGroup() && content?.isVisible)" class="container-widget__header">
          <h4 class="container-widget__header-text" id="container-header"
              [class.collapsible]="content?.isCollapsible()">
              <button *ngIf="content?.isCollapsible()"
                      mat-icon-button
                      class="mdl-button--icon"
                      (click)="onExpanderClicked()">
                  <mat-icon>{{ content?.isExpanded ? 'expand_less' : 'expand_more' }}</mat-icon>
              </button>
              <span (click)="onExpanderClicked()" id="container-header-label">{{content.name}}</span>
          </h4>
      </div>

      <section class="grid-list" [ngClass]="{'hidden':!(content?.isVisible && content?.isExpanded)}">
          <div class="grid-list-item" *ngFor="let field of fields" [style.width]="getColumnWith(field)">
              <form-field *ngIf="field" [field]="field"></form-field>
          </div>
      </section>
    `,
                styles: [`

    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
ContainerWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class TabsWidgetComponent {
    constructor() {
        this.tabs = [];
        this.formTabChanged = new EventEmitter();
        this.visibleTabs = [];
    }
    /**
     * @return {?}
     */
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.filterVisibleTabs();
    }
    /**
     * @return {?}
     */
    filterVisibleTabs() {
        this.visibleTabs = this.tabs.filter(tab => {
            return tab.isVisible;
        });
    }
    /**
     * @param {?} field
     * @return {?}
     */
    tabChanged(field) {
        this.formTabChanged.emit(field);
    }
}
TabsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'tabs-widget',
                template: `
      <div *ngIf="hasTabs()" class="alfresco-tabs-widget">
          <mat-tab-group>
              <mat-tab *ngFor="let tab of visibleTabs" [label]="tab.title">
                  <div *ngFor="let field of tab.fields">
                      <form-field [field]="field.field"></form-field>
                   </div>
              </mat-tab>
          </mat-tab-group>
      </div>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TabsWidgetComponent.ctorParameters = () => [];
TabsWidgetComponent.propDecorators = {
    'tabs': [{ type: Input },],
    'formTabChanged': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class UnknownWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
UnknownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'unknown-widget',
                template: `
            <mat-list class="adf-unknown-widget">
                <mat-list-item>
                     <mat-icon class="mat-24">error_outline</mat-icon>
                     <span class="adf-unknown-text">Unknown type: {{field.type}}</span>
                </mat-list-item>
            </mat-list>

    `,
                styles: [`
      .adf-unknown-text {
        margin-left: 10px;
        color: red; }

      .adf-unknown-widget {
        margin: 42px; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
UnknownWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class AmountWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.currency = AmountWidgetComponent.DEFAULT_CURRENCY;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field && this.field.currency) {
            this.currency = this.field.currency;
        }
    }
}
AmountWidgetComponent.DEFAULT_CURRENCY = '$';
AmountWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'amount-widget',
                template: `
      <div class="adf-amount-widget__container adf-amount-widget {{field.className}}" [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
          <mat-form-field floatPlaceholder="never" class="adf-amount-widget__input">
              <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
              <span matPrefix class="adf-amount-widget__prefix-spacing"> {{currency }}</span>
              <input matInput
                      class="adf-amount-widget"
                      type="text"
                      [id]="field.id"
                      [required]="isRequired()"
                      [value]="field.value"
                      [(ngModel)]="field.value"
                      (ngModelChange)="checkVisibility(field)"
                      [disabled]="field.readOnly"
                      placeholder="{{field.placeholder}}">
          </mat-form-field>
          <error-widget [error]="field.validationSummary" ></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-amount-widget {
        width: 100%;
        vertical-align: baseline !important; }
        .adf-amount-widget .mat-input-element {
          margin-left: 11px; }
        .adf-amount-widget .mat-input-prefix {
          position: absolute;
          margin-top: 42px; }
        .adf-amount-widget .mat-input-placeholder {
          margin-top: 5px; }

      .adf-amount-widget__container {
        max-width: 100%; }
        .adf-amount-widget__container .mat-input-placeholder-wrapper {
          top: -6px !important; }
        .adf-amount-widget__container .mat-input-placeholder-wrapper {
          top: 0 !important;
          left: 13px; }

      .adf-amount-widget__input .mat-focused {
        -webkit-transition: none;
        transition: none; }

      .adf-amount-widget__prefix-spacing {
        padding-right: 5px; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AmountWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ActivitiContentService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Returns a list of child nodes below the specified folder
     *
     * @param {?} accountId
     * @param {?} folderId
     * @return {?}
     */
    getAlfrescoNodes(accountId, folderId) {
        let /** @type {?} */ apiService = this.apiService.getInstance();
        let /** @type {?} */ accountShortId = accountId.replace('alfresco-', '');
        return Observable$1.fromPromise(apiService.activiti.alfrescoApi.getContentInFolder(accountShortId, folderId))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    /**
     * Returns a list of child nodes below the specified folder
     *
     * @param {?} accountId
     * @param {?} node
     * @param {?} siteId
     * @return {?}
     */
    linkAlfrescoNode(accountId, node, siteId) {
        let /** @type {?} */ apiService = this.apiService.getInstance();
        return Observable$1.fromPromise(apiService.activiti.contentApi.createTemporaryRelatedContent({
            link: true,
            name: node.title,
            simpleType: node.simpleType,
            source: accountId,
            sourceId: node.id + '@' + siteId
        })).map(this.toJson).catch(err => this.handleError(err));
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        let /** @type {?} */ errMsg = ActivitiContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ActivitiContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return Observable$1.throw(errMsg);
    }
}
ActivitiContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ActivitiContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ActivitiContentService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ActivitiContentService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class AttachWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} contentService
     */
    constructor(formService, contentService) {
        super(formService);
        this.formService = formService;
        this.contentService = contentService;
        this.fieldChanged = new EventEmitter();
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            let /** @type {?} */ params = this.field.params;
            if (params &&
                params.fileSource &&
                params.fileSource.selectedFolder) {
                this.selectedFolderSiteId = params.fileSource.selectedFolder.siteId;
                this.selectedFolderSiteName = params.fileSource.selectedFolder.site;
                this.setupFileBrowser();
                this.getExternalContentNodes();
            }
        }
    }
    /**
     * @return {?}
     */
    setupFileBrowser() {
        if (this.field) {
            let /** @type {?} */ params = this.field.params;
            this.selectedFolderPathId = params.fileSource.selectedFolder.pathId;
            this.selectedFolderAccountId = params.fileSource.selectedFolder.accountId;
        }
    }
    /**
     * @return {?}
     */
    getLinkedFileName() {
        let /** @type {?} */ result = this.fileName;
        if (this.selectedFile &&
            this.selectedFile.title) {
            result = this.selectedFile.title;
        }
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0 &&
            this.field.value[0].name) {
            result = this.field.value[0].name;
        }
        return result;
    }
    /**
     * @return {?}
     */
    getExternalContentNodes() {
        this.contentService.getAlfrescoNodes(this.selectedFolderAccountId, this.selectedFolderPathId)
            .subscribe(nodes => this.selectedFolderNodes = nodes, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    selectFile(node, $event) {
        this.contentService.linkAlfrescoNode(this.selectedFolderAccountId, node, this.selectedFolderSiteId).subscribe((link) => {
            this.selectedFile = node;
            this.field.value = [link];
            this.field.json.value = [link];
            this.closeDialog();
            this.fieldChanged.emit(this.field);
        });
    }
    /**
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    selectFolder(node, $event) {
        this.selectedFolderPathId = node.id;
        this.getExternalContentNodes();
    }
    /**
     * @return {?}
     */
    showDialog() {
        this.setupFileBrowser();
        this.getExternalContentNodes();
        if (this.dialog) {
            // todo: show dialog
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    closeDialog() {
        if (this.dialog) {
            this.dialog.nativeElement.close();
        }
    }
    /**
     * @return {?}
     */
    cancel() {
        this.closeDialog();
    }
    /**
     * @return {?}
     */
    reset() {
        this.field.value = null;
        this.field.json.value = null;
    }
    /**
     * @return {?}
     */
    hasFile() {
        return this.field && this.field.value;
    }
}
AttachWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'attach-widget',
                template: `
      <div class="attach-widget {{field.className}}">
          <label [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
          <div>
              <span *ngIf="hasFile()" class="attach-widget__file mdl-chip"><span class="mdl-chip__text">{{getLinkedFileName()}}</span></span>
              <button #browseFile [disabled]="field.readOnly" (click)="showDialog();" class="mdl-button mdl-jsm-button mdl-js-ripple-effect attach-widget__browser">
                  <mat-icon>image</mat-icon>
                  Browse {{selectedFolderSiteName}}
              </button>
              <button *ngIf="hasFile" [disabled]="field.readOnly" (click)="reset(file);" class="mdl-button mdl-js-button mdl-js-ripple-effect attach-widget__reset">Clear</button>
          </div>
      </div>

      <dialog class="mdl-dialog" #dialog>
          <h4 class="mdl-dialog__title">Select content</h4>
          <div class="mdl-dialog__content">
              <ul class='mdl-list'>
                  <li class="mdl-list__item" *ngFor="let node of selectedFolderNodes">
                  <span class="mdl-list__item-primary-content" *ngIf="node.folder">
                  <mat-icon class="mdl-list__item-icon">folder</mat-icon>
                  <a (click)="selectFolder(node, $event)">{{node.title}}</a>
                  </span>
                  <span class="mdl-list__item-primary-content" *ngIf="!node.folder">
                  <mat-icon class="mdl-list__item-icon">description</mat-icon>
                  <a (click)="selectFile(node, $event)">{{node.title}}</a>
                  </span>
                  </li>
              </ul>
          </div>
          <div class="mdl-dialog__actions">
              <button type="button" (click)="cancel()" class="mdl-button close">Cancel</button>
          </div>
      </dialog>
    `,
                styles: [`
      .attach-widget {
          width:100%
      }

      .attach-widget__icon {
          float: left;
      }

      .attach-widget__file {
          margin-top: 4px;
      }

      .attach-widget__reset {
          margin-top: 4px;
      }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AttachWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: ActivitiContentService, },
];
AttachWidgetComponent.propDecorators = {
    'fieldChanged': [{ type: Output },],
    'error': [{ type: Output },],
    'dialog': [{ type: ViewChild, args: ['dialog',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WidgetVisibilityService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @param {?} form
     * @return {?}
     */
    refreshVisibility(form) {
        if (form && form.tabs && form.tabs.length > 0) {
            form.tabs.map(tabModel => this.refreshEntityVisibility(tabModel));
        }
        if (form) {
            form.getFormFields().map(field => this.refreshEntityVisibility(field));
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    refreshEntityVisibility(element) {
        let /** @type {?} */ visible = this.evaluateVisibility(element.form, element.visibilityCondition);
        element.isVisible = visible;
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    evaluateVisibility(form, visibilityObj) {
        let /** @type {?} */ isLeftFieldPresent = visibilityObj && (visibilityObj.leftFormFieldId || visibilityObj.leftRestResponseId);
        if (!isLeftFieldPresent || isLeftFieldPresent === 'null') {
            return true;
        }
        else {
            return this.isFieldVisible(form, visibilityObj);
        }
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    isFieldVisible(form, visibilityObj) {
        let /** @type {?} */ leftValue = this.getLeftValue(form, visibilityObj);
        let /** @type {?} */ rightValue = this.getRightValue(form, visibilityObj);
        let /** @type {?} */ actualResult = this.evaluateCondition(leftValue, rightValue, visibilityObj.operator);
        if (visibilityObj.nextCondition) {
            return this.evaluateLogicalOperation(visibilityObj.nextConditionOperator, actualResult, this.isFieldVisible(form, visibilityObj.nextCondition));
        }
        else {
            return actualResult;
        }
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    getLeftValue(form, visibilityObj) {
        let /** @type {?} */ leftValue = '';
        if (visibilityObj.leftRestResponseId && visibilityObj.leftRestResponseId !== 'null') {
            leftValue = this.getVariableValue(form, visibilityObj.leftRestResponseId, this.processVarList);
        }
        else {
            leftValue = this.getFormValue(form, visibilityObj.leftFormFieldId);
            leftValue = leftValue ? leftValue : this.getVariableValue(form, visibilityObj.leftFormFieldId, this.processVarList);
        }
        return leftValue;
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    getRightValue(form, visibilityObj) {
        let /** @type {?} */ valueFound = '';
        if (visibilityObj.rightRestResponseId) {
            valueFound = this.getVariableValue(form, visibilityObj.rightRestResponseId, this.processVarList);
        }
        else if (visibilityObj.rightFormFieldId) {
            valueFound = this.getFormValue(form, visibilityObj.rightFormFieldId);
        }
        else {
            if (moment(visibilityObj.rightValue, 'YYYY-MM-DD', true).isValid()) {
                valueFound = visibilityObj.rightValue + 'T00:00:00.000Z';
            }
            else {
                valueFound = visibilityObj.rightValue;
            }
        }
        return valueFound;
    }
    /**
     * @param {?} form
     * @param {?} fieldId
     * @return {?}
     */
    getFormValue(form, fieldId) {
        let /** @type {?} */ value = this.getFieldValue(form.values, fieldId);
        if (!value) {
            value = this.searchValueInForm(form, fieldId);
        }
        return value;
    }
    /**
     * @param {?} valueList
     * @param {?} fieldId
     * @return {?}
     */
    getFieldValue(valueList, fieldId) {
        let /** @type {?} */ dropDownFilterByName, /** @type {?} */ valueFound;
        if (fieldId && fieldId.indexOf('_LABEL') > 0) {
            dropDownFilterByName = fieldId.substring(0, fieldId.length - 6);
            if (valueList[dropDownFilterByName]) {
                valueFound = valueList[dropDownFilterByName].name;
            }
        }
        else if (valueList[fieldId] && valueList[fieldId].id) {
            valueFound = valueList[fieldId].id;
        }
        else {
            valueFound = valueList[fieldId];
        }
        return valueFound;
    }
    /**
     * @param {?} form
     * @param {?} fieldId
     * @return {?}
     */
    searchValueInForm(form, fieldId) {
        let /** @type {?} */ fieldValue = '';
        form.getFormFields().forEach((formField) => {
            if (this.isSearchedField(formField, fieldId)) {
                fieldValue = this.getObjectValue(formField);
                if (!fieldValue) {
                    if (formField.value && formField.value.id) {
                        fieldValue = formField.value.id;
                    }
                    else {
                        fieldValue = formField.value;
                    }
                }
            }
        });
        return fieldValue;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getObjectValue(field) {
        let /** @type {?} */ value = '';
        if (field.value && field.value.name) {
            value = field.value.name;
        }
        else if (field.options) {
            let /** @type {?} */ option = field.options.find(opt => opt.id === field.value);
            if (option) {
                value = option.name;
            }
            else {
                value = field.value;
            }
        }
        return value;
    }
    /**
     * @param {?} field
     * @param {?} fieldToFind
     * @return {?}
     */
    isSearchedField(field, fieldToFind) {
        let /** @type {?} */ formattedFieldName = this.removeLabel(field, fieldToFind);
        return field.id ? field.id.toUpperCase() === formattedFieldName.toUpperCase() : false;
    }
    /**
     * @param {?} field
     * @param {?} fieldToFind
     * @return {?}
     */
    removeLabel(field, fieldToFind) {
        let /** @type {?} */ formattedFieldName = fieldToFind || '';
        if (field.fieldType === 'RestFieldRepresentation' && fieldToFind.indexOf('_LABEL') > 0) {
            formattedFieldName = fieldToFind.substring(0, fieldToFind.length - 6);
        }
        return formattedFieldName;
    }
    /**
     * @param {?} form
     * @param {?} name
     * @param {?} processVarList
     * @return {?}
     */
    getVariableValue(form, name, processVarList) {
        return this.getFormVariableValue(form, name) ||
            this.getProcessVariableValue(name, processVarList);
    }
    /**
     * @param {?} form
     * @param {?} name
     * @return {?}
     */
    getFormVariableValue(form, name) {
        if (form.json.variables) {
            let /** @type {?} */ formVariable = form.json.variables.find(formVar => formVar.name === name);
            return formVariable ? formVariable.value : formVariable;
        }
    }
    /**
     * @param {?} name
     * @param {?} processVarList
     * @return {?}
     */
    getProcessVariableValue(name, processVarList) {
        if (this.processVarList) {
            let /** @type {?} */ processVariable = this.processVarList.find(variable => variable.id === name);
            return processVariable ? processVariable.value : processVariable;
        }
    }
    /**
     * @param {?} logicOp
     * @param {?} previousValue
     * @param {?} newValue
     * @return {?}
     */
    evaluateLogicalOperation(logicOp, previousValue, newValue) {
        switch (logicOp) {
            case 'and':
                return previousValue && newValue;
            case 'or':
                return previousValue || newValue;
            case 'and-not':
                return previousValue && !newValue;
            case 'or-not':
                return previousValue || !newValue;
            default:
                this.logService.error('NO valid operation! wrong op request : ' + logicOp);
                break;
        }
    }
    /**
     * @param {?} leftValue
     * @param {?} rightValue
     * @param {?} operator
     * @return {?}
     */
    evaluateCondition(leftValue, rightValue, operator) {
        switch (operator) {
            case '==':
                return leftValue + '' === rightValue + '';
            case '<':
                return leftValue < rightValue;
            case '!=':
                return leftValue + '' !== rightValue + '';
            case '>':
                return leftValue > rightValue;
            case '>=':
                return leftValue >= rightValue;
            case '<=':
                return leftValue <= rightValue;
            case 'empty':
                return leftValue ? leftValue === '' : true;
            case '!empty':
                return leftValue ? leftValue !== '' : false;
            default:
                this.logService.error('NO valid operation!');
                break;
        }
        return;
    }
    /**
     * @return {?}
     */
    cleanProcessVariable() {
        this.processVarList = [];
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getTaskProcessVariable(taskId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskFormsApi.getTaskFormVariables(taskId))
            .map(res => {
            let /** @type {?} */ jsonRes = this.toJson(res);
            this.processVarList = /** @type {?} */ (jsonRes);
            return jsonRes;
        })
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        return res || {};
    }
    /**
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        this.logService.error('Error while performing a call');
        return Observable$1.throw('Error while performing a call - Server error');
    }
}
WidgetVisibilityService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
WidgetVisibilityService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class CheckboxWidgetComponent extends WidgetComponent {
    /**
     * @param {?} visibilityService
     * @param {?} formService
     */
    constructor(visibilityService, formService) {
        super(formService);
        this.visibilityService = visibilityService;
        this.formService = formService;
    }
    /**
     * @return {?}
     */
    onChange() {
        this.visibilityService.refreshVisibility(this.field.form);
    }
}
CheckboxWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'checkbox-widget',
                template: `
      <div [ngClass]="field.className">
          <mat-checkbox
              [id]="field.id"
              color="primary"
              [required]="field.required"
              [disabled]="field.readOnly || readOnly"
              [(ngModel)]="field.value"
              (change)="onChange()">
              {{field.name}}
              <span *ngIf="field.required">*</span>
          </mat-checkbox>
      </div>
    `,
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
CheckboxWidgetComponent.ctorParameters = () => [
    { type: WidgetVisibilityService, },
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DateWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} dateAdapter
     * @param {?} preferences
     */
    constructor(formService, dateAdapter, preferences) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        let /** @type {?} */ momentDateAdapter = (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, 'DD/MM/YYYY');
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, 'DD/MM/YYYY');
            }
        }
        this.displayDate = moment(this.field.value, this.field.dateDisplayFormat);
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            this.field.value = newDateValue.value.format(this.field.dateDisplayFormat);
        }
        else if (newDateValue) {
            this.field.value = newDateValue;
        }
        else {
            this.field.value = null;
        }
        this.checkVisibility(this.field);
    }
}
DateWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'date-widget',
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: MOMENT_DATE_FORMATS }
                ],
                template: `
      <div class="{{field.className}}" *ngIf="field?.isVisible" id="data-widget" [class.adf-invalid]="!field.isValid || field.validationSummary.message">
          <mat-form-field class="adf-date-widget">
              <label class="adf-label" [attr.for]="field.id">{{field.name}} ({{field.dateDisplayFormat}})<span *ngIf="isRequired()">*</span></label>
              <input matInput
                     [id]="field.id"
                     [matDatepicker]="datePicker"
                     [(ngModel)]="displayDate"
                     [required]="isRequired()"
                     [disabled]="field.readOnly"
                     [min]="minDate"
                     [max]="maxDate"
                     (focusout)="onDateChanged($event.srcElement.value)"
                     (dateChange)="onDateChanged($event)"
                     placeholder="{{field.placeholder}}">
              <mat-datepicker-toggle  matSuffix [for]="datePicker" [disabled]="field.readOnly" ></mat-datepicker-toggle>
          </mat-form-field>
          <error-widget [error]="field.validationSummary"></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
          <mat-datepicker #datePicker [touchUi]="true" [startAt]="startAt" ></mat-datepicker>
      </div>
    `,
                styles: [`
      .adf-date-widget .mat-input-suffix {
        text-align: right;
        position: absolute;
        margin-top: 30px;
        width: 100%; }

      .adf-date-widget-date-widget-button {
        position: relative;
        float: right; }

      .adf-date-widget-date-input {
        padding-top: 5px;
        padding-bottom: 5px; }

      .adf-date-widget-grid-date-widget {
        -webkit-box-align: center;
            -ms-flex-align: center;
                align-items: center;
        padding: 0; }

      .adf-date-widget-date-widget-button__cell {
        margin-top: 0;
        margin-bottom: 0; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DateWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DisplayTextWidgetComponentComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
DisplayTextWidgetComponentComponent.decorators = [
    { type: Component, args: [{
                selector: 'display-text-widget',
                template: `
      <div class="adf-display-text-widget {{field.className}}">{{field.value}}</div>
    `,
                styles: [`
      .adf-display-text-widget {
        white-space: pre-wrap; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DisplayTextWidgetComponentComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.fileId = null;
        this.hasFile = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            const /** @type {?} */ file = this.field.value;
            if (file) {
                this.fileId = file.id;
                this.hasFile = true;
            }
            else {
                this.fileId = null;
                this.hasFile = false;
            }
        }
    }
}
DocumentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-document-widget',
                template: `
      <div class="adf-form-document-widget {{field.className}}">
          <ng-container *ngIf="hasFile">
              <adf-content [id]="fileId" [showDocumentContent]="true"></adf-content>
          </ng-container>
      </div>
    `,
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DocumentWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DropdownWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} visibilityService
     * @param {?} logService
     */
    constructor(formService, visibilityService, logService) {
        super(formService);
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.logService = logService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getValuesByTaskId();
            }
            else {
                this.getValuesByProcessDefinitionId();
            }
        }
    }
    /**
     * @return {?}
     */
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((result) => {
            let /** @type {?} */ options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((result || []));
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((result) => {
            let /** @type {?} */ options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((result || []));
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    /**
     * @param {?} option
     * @param {?} fieldValue
     * @return {?}
     */
    getOptionValue(option, fieldValue) {
        let /** @type {?} */ optionValue = '';
        if (option.id === 'empty' || option.name !== fieldValue) {
            optionValue = option.id;
        }
        else {
            optionValue = option.name;
        }
        return optionValue;
    }
    /**
     * @return {?}
     */
    checkVisibility() {
        this.visibilityService.refreshVisibility(this.field.form);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
    /**
     * @return {?}
     */
    isReadOnlyType() {
        return this.field.type === 'readonly' ? true : false;
    }
}
DropdownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-widget',
                template: `
      <div class="adf-dropdown-widget {{field.className}}"
           [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly" *ngIf="field?.isVisible">
          <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
          <mat-form-field>
              <mat-select class="adf-select"
                          [id]="field.id"
                          [(ngModel)]="field.value"
                          [disabled]="field.readOnly"
                          (ngModelChange)="checkVisibility(field)">
                  <mat-option *ngFor="let opt of field.options"
                              [value]="getOptionValue(opt, field.value)"
                              [id]="opt.id">{{opt.name}}
                  </mat-option>
                  <mat-option id="readonlyOption" *ngIf="isReadOnlyType()" [value]="field.value">{{field.value}}</mat-option>
              </mat-select>
          </mat-form-field>
          <error-widget [error]="field.validationSummary"></error-widget>
          <error-widget class="adf-dropdown-required-message" *ngIf="isInvalidFieldRequired()"
                        required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-dropdown-widget {
        width: 100%;
        margin-top: 13px; }
        .adf-dropdown-widget .adf-select {
          padding-top: 0 !important;
          width: 100%; }
        .adf-dropdown-widget .mat-select-value-text {
          font-size: 14px; }
        .adf-dropdown-widget-select {
          width: 100%; }
        .adf-dropdown-widget-dropdown-required-message .adf-error-text-container {
          margin-top: 1px !important; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DropdownWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: WidgetVisibilityService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DateCellValidator {
    constructor() {
        this.supportedTypes = [
            'Date'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.editable && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            let /** @type {?} */ value = row.value[column.id];
            let /** @type {?} */ dateValue = moment(value, 'D-M-YYYY');
            if (!dateValue.isValid()) {
                if (summary) {
                    summary.isValid = false;
                    summary.message = `Invalid '${column.name}' format.`;
                }
                return false;
            }
        }
        return true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DynamicRowValidationSummary extends ErrorMessageModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.isValid = json.isValid;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NumberCellValidator {
    constructor() {
        this.supportedTypes = [
            'Number',
            'Amount'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            let /** @type {?} */ value = row.value[column.id];
            if (value === null ||
                value === undefined ||
                value === '' ||
                this.isNumber(value)) {
                return true;
            }
            if (summary) {
                summary.isValid = false;
                summary.message = `Field '${column.name}' must be a number.`;
            }
            return false;
        }
        return true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RequiredCellValidator {
    constructor() {
        this.supportedTypes = [
            'String',
            'Number',
            'Amount',
            'Date',
            'Dropdown'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            let /** @type {?} */ value = row.value[column.id];
            if (column.required) {
                if (value === null || value === undefined || value === '') {
                    if (summary) {
                        summary.isValid = false;
                        summary.message = `Field '${column.name}' is required.`;
                    }
                    return false;
                }
            }
        }
        return true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DynamicTableModel extends FormWidgetModel {
    /**
     * @param {?} field
     * @param {?} formService
     */
    constructor(field, formService) {
        super(field.form, field.json);
        this.formService = formService;
        this.columns = [];
        this.visibleColumns = [];
        this.rows = [];
        this._validators = [];
        this.field = field;
        if (field.json) {
            const columns = this.getColumns(field);
            if (columns) {
                this.columns = columns;
                this.visibleColumns = this.columns.filter(col => col.visible);
            }
            if (field.json.value) {
                this.rows = field.json.value.map(obj => ({ selected: false, value: obj }));
            }
        }
        this._validators = [
            new RequiredCellValidator(),
            new DateCellValidator(),
            new NumberCellValidator()
        ];
    }
    /**
     * @return {?}
     */
    get selectedRow() {
        return this._selectedRow;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedRow(value) {
        if (this._selectedRow && this._selectedRow === value) {
            this._selectedRow.selected = false;
            this._selectedRow = null;
            return;
        }
        this.rows.forEach(row => row.selected = false);
        this._selectedRow = value;
        if (value) {
            this._selectedRow.selected = true;
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getColumns(field) {
        if (field && field.json) {
            let /** @type {?} */ definitions = field.json.columnDefinitions;
            if (!definitions && field.json.params && field.json.params.field) {
                definitions = field.json.params.field.columnDefinitions;
            }
            if (definitions) {
                return definitions.map(obj => /** @type {?} */ (obj));
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    flushValue() {
        if (this.field) {
            this.field.value = this.rows.map(r => r.value);
            this.field.updateForm();
        }
    }
    /**
     * @param {?} row
     * @param {?} offset
     * @return {?}
     */
    moveRow(row, offset) {
        let /** @type {?} */ oldIndex = this.rows.indexOf(row);
        if (oldIndex > -1) {
            let /** @type {?} */ newIndex = (oldIndex + offset);
            if (newIndex < 0) {
                newIndex = 0;
            }
            else if (newIndex >= this.rows.length) {
                newIndex = this.rows.length;
            }
            let /** @type {?} */ arr = this.rows.slice();
            arr.splice(oldIndex, 1);
            arr.splice(newIndex, 0, row);
            this.rows = arr;
            this.flushValue();
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    deleteRow(row) {
        if (row) {
            if (this.selectedRow === row) {
                this.selectedRow = null;
            }
            let /** @type {?} */ idx = this.rows.indexOf(row);
            if (idx > -1) {
                this.rows.splice(idx, 1);
                this.flushValue();
            }
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    addRow(row) {
        if (row) {
            this.rows.push(row);
            // this.selectedRow = row;
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    validateRow(row) {
        const /** @type {?} */ summary = new DynamicRowValidationSummary({
            isValid: true,
            message: null
        });
        const /** @type {?} */ event = new ValidateDynamicTableRowEvent(this.form, this.field, row, summary);
        this.formService.validateDynamicTableRow.next(event);
        if (event.defaultPrevented || !summary.isValid) {
            return summary;
        }
        if (row) {
            for (let /** @type {?} */ col of this.columns) {
                for (let /** @type {?} */ validator of this._validators) {
                    if (!validator.validate(row, col, summary)) {
                        return summary;
                    }
                }
            }
        }
        return summary;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    getCellValue(row, column) {
        let /** @type {?} */ result = row.value[column.id];
        if (column.type === 'Dropdown') {
            if (result) {
                return result.name;
            }
        }
        if (column.type === 'Boolean') {
            return result ? true : false;
        }
        if (column.type === 'Date') {
            if (result) {
                return moment(result.split('T')[0], 'YYYY-MM-DD').format('DD-MM-YYYY');
            }
        }
        return result || '';
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getDisplayText(column) {
        let /** @type {?} */ result = column.name;
        if (column.type === 'Amount') {
            let /** @type {?} */ currency = column.amountCurrency || '$';
            result = `${column.name} (${currency})`;
        }
        return result;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DynamicTableWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} elementRef
     * @param {?} visibilityService
     * @param {?} logService
     * @param {?} cd
     */
    constructor(formService, elementRef, visibilityService, logService, cd) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.visibilityService = visibilityService;
        this.logService = logService;
        this.cd = cd;
        this.ERROR_MODEL_NOT_FOUND = 'Table model not found';
        this.editMode = false;
        this.editRow = null;
        this.selectArrayCode = [32, 0, 13];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            this.content = new DynamicTableModel(this.field, this.formService);
            this.visibilityService.refreshVisibility(this.field.form);
        }
    }
    /**
     * @return {?}
     */
    forceFocusOnAddButton() {
        if (this.content) {
            this.cd.detectChanges();
            let /** @type {?} */ buttonAddRow = (this.elementRef.nativeElement.querySelector('#' + this.content.id + '-add-row'));
            if (this.isDynamicTableReady(buttonAddRow)) {
                buttonAddRow.focus();
            }
        }
    }
    /**
     * @param {?} buttonAddRow
     * @return {?}
     */
    isDynamicTableReady(buttonAddRow) {
        return this.field && !this.editMode && buttonAddRow;
    }
    /**
     * @return {?}
     */
    isValid() {
        let /** @type {?} */ result = true;
        if (this.content && this.content.field) {
            result = this.content.field.isValid;
        }
        return result;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    onRowClicked(row) {
        if (this.content) {
            this.content.selectedRow = row;
        }
    }
    /**
     * @param {?} $event
     * @param {?} row
     * @return {?}
     */
    onKeyPressed($event, row) {
        if (this.content && this.isEnterOrSpacePressed($event.keyCode)) {
            this.content.selectedRow = row;
        }
    }
    /**
     * @param {?} keycode
     * @return {?}
     */
    isEnterOrSpacePressed(keycode) {
        return this.selectArrayCode.indexOf(keycode) !== -1;
    }
    /**
     * @return {?}
     */
    hasSelection() {
        return !!(this.content && this.content.selectedRow);
    }
    /**
     * @return {?}
     */
    moveSelectionUp() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, -1);
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    moveSelectionDown() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, 1);
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    deleteSelection() {
        if (this.content && !this.readOnly) {
            this.content.deleteRow(this.content.selectedRow);
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    addNewRow() {
        if (this.content && !this.readOnly) {
            this.editRow = /** @type {?} */ ({
                isNew: true,
                selected: false,
                value: {}
            });
            this.editMode = true;
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    editSelection() {
        if (this.content && !this.readOnly) {
            this.editRow = this.copyRow(this.content.selectedRow);
            this.editMode = true;
            return true;
        }
        return false;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    getCellValue(row, column) {
        if (this.content) {
            let /** @type {?} */ result = this.content.getCellValue(row, column);
            if (column.type === 'Amount') {
                return (column.amountCurrency || '$') + ' ' + (result || 0);
            }
            return result;
        }
        return null;
    }
    /**
     * @return {?}
     */
    onSaveChanges() {
        if (this.content) {
            if (this.editRow.isNew) {
                let /** @type {?} */ row = this.copyRow(this.editRow);
                this.content.selectedRow = null;
                this.content.addRow(row);
                this.editRow.isNew = false;
            }
            else {
                this.content.selectedRow.value = this.copyObject(this.editRow.value);
            }
            this.content.flushValue();
        }
        else {
            this.logService.error(this.ERROR_MODEL_NOT_FOUND);
        }
        this.editMode = false;
        this.forceFocusOnAddButton();
    }
    /**
     * @return {?}
     */
    onCancelChanges() {
        this.editMode = false;
        this.editRow = null;
        this.forceFocusOnAddButton();
    }
    /**
     * @param {?} row
     * @return {?}
     */
    copyRow(row) {
        return /** @type {?} */ ({
            value: this.copyObject(row.value)
        });
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    copyObject(obj) {
        let /** @type {?} */ result = obj;
        if (typeof obj === 'object' && obj !== null && obj !== undefined) {
            result = Object.assign({}, obj);
            Object.keys(obj).forEach(key => {
                if (typeof obj[key] === 'object') {
                    result[key] = this.copyObject(obj[key]);
                }
            });
        }
        return result;
    }
}
DynamicTableWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dynamic-table-widget',
                template: `
      <div class="{{field.className}}"
          [class.adf-invalid]="!isValid()" *ngIf="field?.isVisible">
          <div class="adf-label">{{content.name}}<span *ngIf="isRequired()">*</span></div>

          <div *ngIf="!editMode">
              <div class="adf-table-container">
                  <table class="full-width adf-dynamic-table" id="dynamic-table-{{content.id}}">
                      <thead>
                          <tr>
                              <th *ngFor="let column of content.visibleColumns">
                                  {{column.name}}
                              </th>
                          </tr>
                      </thead>
                      <tbody>
                          <tr *ngFor="let row of content.rows; let idx = index" tabindex="0" id="{{content.id}}-row-{{idx}}"
                              [class.adf-dynamic-table-widget__row-selected]="row.selected" (keyup)="onKeyPressed($event, row)">
                              <td *ngFor="let column of content.visibleColumns"
                                  (click)="onRowClicked(row)">
                                  {{ getCellValue(row, column) }}
                              </td>
                          </tr>
                      </tbody>
                  </table>
              </div>

              <div *ngIf="!readOnly">
                  <button mat-button
                          [disabled]="!hasSelection()"
                          (click)="moveSelectionUp()">
                      <mat-icon>arrow_upward</mat-icon>
                  </button>
                  <button mat-button
                          [disabled]="!hasSelection()"
                          (click)="moveSelectionDown()">
                      <mat-icon>arrow_downward</mat-icon>
                  </button>
                  <button mat-button
                          [disabled]="field.readOnly"
                          id="{{content.id}}-add-row"
                          (click)="addNewRow()">
                      <mat-icon>add_circle_outline</mat-icon>
                  </button>
                  <button mat-button
                          [disabled]="!hasSelection()"
                          (click)="deleteSelection()">
                      <mat-icon>remove_circle_outline</mat-icon>
                  </button>
                  <button mat-button
                          [disabled]="!hasSelection()"
                          (click)="editSelection()">
                      <mat-icon>edit</mat-icon>
                  </button>
              </div>
           </div>

           <row-editor *ngIf="editMode"
              [table]="content"
              [row]="editRow"
              [column]="column"
              (save)="onSaveChanges()"
              (cancel)="onCancelChanges()">
           </row-editor>
          <error-widget [error]="field.validationSummary" ></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`

    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DynamicTableWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: ElementRef, },
    { type: WidgetVisibilityService, },
    { type: LogService, },
    { type: ChangeDetectorRef, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class BooleanEditorComponent {
    /**
     * @param {?} row
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    onValueChanged(row, column, event) {
        let /** @type {?} */ value = ((event)).checked;
        row.value[column.id] = value;
    }
}
BooleanEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-boolean-editor',
                template: `
       <label [attr.for]="column.id">
          <mat-checkbox
              color="primary"
              [id]="column.id"
              [checked]="table.getCellValue(row, column)"
              [required]="column.required"
              [disabled]="!column.editable"
              (change)="onValueChanged(row, column, $event)">
          <span class="adf-checkbox-label">{{column.name}}</span>
          </mat-checkbox>
      </label>
    `,
                styles: [`
      .adf-checkbox-label {
        position: relative;
        cursor: pointer;
        font-size: 16px;
        line-height: 24px;
        margin: 0; }
    `]
            },] },
];
/**
 * @nocollapse
 */
BooleanEditorComponent.ctorParameters = () => [];
BooleanEditorComponent.propDecorators = {
    'table': [{ type: Input },],
    'row': [{ type: Input },],
    'column': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DateEditorComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} preferences
     */
    constructor(dateAdapter, preferences) {
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.DATE_FORMAT = 'DD-MM-YYYY';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        let /** @type {?} */ momentDateAdapter = (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), this.DATE_FORMAT);
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue) {
            let /** @type {?} */ momentDate = moment(newDateValue, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = '';
            }
            else {
                this.row.value[this.column.id] = `${momentDate.format('YYYY-MM-DD')}T00:00:00.000Z`;
                this.table.flushValue();
            }
        }
    }
}
DateEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-editor',
                template: `
      <div>
          <mat-form-field class="adf-date-editor">
              <label [attr.for]="column.id">{{column.name}} (d-M-yyyy)</label>
              <input matInput
                  id="dateInput"
                  type="text"
                  [matDatepicker]="datePicker"
                  [value]="value"
                  [id]="column.id"
                  [required]="column.required"
                  [disabled]="!column.editable"
                 (focusout)="onDateChanged($event.srcElement.value)">
              <mat-datepicker-toggle  *ngIf="column.editable" matSuffix [for]="datePicker" class="adf-date-editor-button" ></mat-datepicker-toggle>
          </mat-form-field>
          <mat-datepicker #datePicker (dateChange)="onDateChanged($event)" [touchUi]="true"></mat-datepicker>
      </div>
    `,
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: MOMENT_DATE_FORMATS }
                ],
                styles: [`
      .adf-date-editor {
        width: 100%; }

      .adf-date-editor-button {
        position: relative;
        top: 25px; }
    `]
            },] },
];
/**
 * @nocollapse
 */
DateEditorComponent.ctorParameters = () => [
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];
DateEditorComponent.propDecorators = {
    'table': [{ type: Input },],
    'row': [{ type: Input },],
    'column': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DropdownEditorComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     */
    constructor(formService, logService) {
        this.formService = formService;
        this.logService = logService;
        this.value = null;
        this.options = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ field = this.table.field;
        if (field) {
            if (this.column.optionType === 'rest') {
                if (this.table.form && this.table.form.taskId) {
                    this.getValuesByTaskId(field);
                }
                else {
                    this.getValuesByProcessDefinitionId(field);
                }
            }
            else {
                this.options = this.column.options || [];
                this.value = this.table.getCellValue(this.row, this.column);
            }
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getValuesByTaskId(field) {
        this.formService
            .getRestFieldValuesColumn(field.form.taskId, field.id, this.column.id)
            .subscribe((result) => {
            this.column.options = result || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, err => this.handleError(err));
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getValuesByProcessDefinitionId(field) {
        this.formService
            .getRestFieldValuesColumnByProcessId(field.form.processDefinitionId, field.id, this.column.id)
            .subscribe((result) => {
            this.column.options = result || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, err => this.handleError(err));
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    onValueChanged(row, column, event) {
        let /** @type {?} */ value = ((event)).value;
        value = column.options.find(opt => opt.name === value);
        row.value[column.id] = value;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
}
DropdownEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-editor',
                template: `
      <div class="dropdown-editor">
          <label [attr.for]="column.id">{{column.name}}</label>
          <mat-form-field>
              <mat-select
                  floatPlaceholder="never"
                  class="adf-dropdown-editor-select"
                  [id]="column.id"
                  [(ngModel)]="value"
                  [required]="column.required"
                  [disabled]="!column.editable"
                  (change)="onValueChanged(row, column, $event)">
                  <mat-option></mat-option>
                  <mat-option *ngFor="let opt of options" [value]="opt.name" [id]="opt.id">{{opt.name}}</mat-option>
              </mat-select>
          </mat-form-field>
      </div>
    `,
                styles: [`
      .adf-dropdown-editor-select {
        width: 100%; }
    `]
            },] },
];
/**
 * @nocollapse
 */
DropdownEditorComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
];
DropdownEditorComponent.propDecorators = {
    'table': [{ type: Input },],
    'row': [{ type: Input },],
    'column': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class RowEditorComponent {
    constructor() {
        this.save = new EventEmitter();
        this.cancel = new EventEmitter();
        this.validationSummary = new DynamicRowValidationSummary({ isValid: true, message: '' });
    }
    /**
     * @return {?}
     */
    onCancelChanges() {
        this.cancel.emit({
            table: this.table,
            row: this.row,
            column: this.column
        });
    }
    /**
     * @return {?}
     */
    onSaveChanges() {
        this.validate();
        if (this.isValid()) {
            this.save.emit({
                table: this.table,
                row: this.row,
                column: this.column
            });
        }
    }
    /**
     * @return {?}
     */
    isValid() {
        return this.validationSummary && this.validationSummary.isValid;
    }
    /**
     * @return {?}
     */
    validate() {
        this.validationSummary = this.table.validateRow(this.row);
    }
}
RowEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'row-editor',
                template: `
      <div class="row-editor mdl-shadow--2dp"
          [class.row-editor__invalid]="!validationSummary.isValid">
          <div class="mdl-grid" *ngFor="let column of table.columns">
              <div class="mdl-cell mdl-cell--6-col" [ngSwitch]="column.type">
                  <div *ngSwitchCase="'Dropdown'">
                      <adf-dropdown-editor
                          [table]="table"
                          [row]="row"
                          [column]="column">
                      </adf-dropdown-editor>
                      </div>
                      <div *ngSwitchCase="'Date'">
                          <adf-date-editor
                          [table]="table"
                          [row]="row"
                          [column]="column">
                      </adf-date-editor>
                      </div>

                      <div *ngSwitchCase="'Boolean'">
                      <adf-boolean-editor
                          [table]="table"
                          [row]="row"
                          [column]="column">
                      </adf-boolean-editor>
                      </div>
                      <div *ngSwitchDefault>
                      <adf-text-editor
                          [table]="table"
                          [row]="row"
                          [column]="column">
                      </adf-text-editor>
                  </div>
              </div>
          </div>
          <error-widget [error]="validationSummary"></error-widget>
          <div>
              <button mat-button (click)="onCancelChanges()">Cancel</button>
              <button mat-button (click)="onSaveChanges()">Save</button>
          </div>
      </div>
    `,
                styles: [`
      .row-editor {
          padding: 8px;
      }

      .row-editor__validation-summary {
          visibility: hidden;
      }

      .row-editor__invalid .row-editor__validation-summary {
          padding-left: 16px;
          padding-right: 16px;
          padding-top: 8px;
          padding-bottom: 8px;
          color: #d50000;
          visibility: visible;
      }
    `]
            },] },
];
/**
 * @nocollapse
 */
RowEditorComponent.ctorParameters = () => [];
RowEditorComponent.propDecorators = {
    'table': [{ type: Input },],
    'row': [{ type: Input },],
    'column': [{ type: Input },],
    'save': [{ type: Output },],
    'cancel': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class TextEditorComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.displayName = this.table.getDisplayText(this.column);
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    onValueChanged(row, column, event) {
        let /** @type {?} */ value = ((event.target)).value;
        row.value[column.id] = value;
    }
}
TextEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-text-editor',
                template: `
      <div class="adf-text-editor">
          <mat-form-field>
          <label [attr.for]="column.id">{{displayName}}</label>
          <input matInput
              type="text"
              [value]="table.getCellValue(row, column)"
              (keyup)="onValueChanged(row, column, $event)"
              [required]="column.required"
              [disabled]="!column.editable"
              [id]="column.id">
          </mat-form-field>
      </div>
    `,
                styles: [`
      .adf-text-editor {
        width: 100%; }
    `]
            },] },
];
/**
 * @nocollapse
 */
TextEditorComponent.ctorParameters = () => [];
TextEditorComponent.propDecorators = {
    'table': [{ type: Input },],
    'row': [{ type: Input },],
    'column': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class ErrorWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.translateParameters = null;
        this._subscriptAnimationState = '';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['required']) {
            this.required = changes.required.currentValue;
            this._subscriptAnimationState = 'enter';
        }
        if (changes['error'] && changes['error'].currentValue) {
            if (changes.error.currentValue.isActive()) {
                this.error = changes.error.currentValue;
                this.translateParameters = this.error.getAttributesAsJsonObj();
                this._subscriptAnimationState = 'enter';
            }
        }
    }
}
ErrorWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'error-widget',
                template: `
      <div class="adf-error-text-container">
          <div *ngIf="error?.isActive()" [@transitionMessages]="_subscriptAnimationState">
              <div class="adf-error-text">{{error.message | translate:translateParameters}}</div>
              <mat-icon class="adf-error-icon">warning</mat-icon>
          </div>
          <div *ngIf="required" [@transitionMessages]="_subscriptAnimationState">
                  <div class="adf-error-text">{{required}}</div>
          </div>
      </div>
    `,
                styles: [`
      .adf-error-text {
        width: 85%; }
    `],
                animations: [
                    trigger('transitionMessages', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
                        transition('void => enter', [
                            style({ opacity: 0, transform: 'translateY(-100%)' }),
                            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                        ])
                    ])
                ],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
ErrorWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];
ErrorWidgetComponent.propDecorators = {
    'error': [{ type: Input },],
    'required': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class FunctionalGroupWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} elementRef
     */
    constructor(formService, elementRef) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.groups = [];
        this.minTermLength = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            let /** @type {?} */ group = this.field.value;
            if (group) {
                this.value = group.name;
            }
            let /** @type {?} */ params = this.field.params;
            if (params && params['restrictWithGroup']) {
                let /** @type {?} */ restrictWithGroup = (params['restrictWithGroup']);
                this.groupId = restrictWithGroup.id;
            }
            // Load auto-completion for previously saved value
            if (this.value) {
                this.formService
                    .getWorkflowGroups(this.value, this.groupId)
                    .subscribe((result) => this.groups = result || []);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        if (this.value && this.value.length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                this.oldValue = this.value;
                this.formService.getWorkflowGroups(this.value, this.groupId)
                    .subscribe((result) => {
                    this.groups = result || [];
                });
            }
        }
    }
    /**
     * @return {?}
     */
    flushValue() {
        let /** @type {?} */ option = this.groups.find(item => item.name.toLocaleLowerCase() === this.value.toLocaleLowerCase());
        if (option) {
            this.field.value = option;
            this.value = option.name;
        }
        else {
            this.field.value = null;
            this.value = null;
        }
        this.field.updateForm();
    }
    /**
     * @param {?} item
     * @param {?} event
     * @return {?}
     */
    onItemClick(item, event) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
        if (event) {
            event.preventDefault();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
    }
}
FunctionalGroupWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'functional-group-widget',
                template: `
      <div class="adf-group-widget {{field.className}}"
           [class.is-dirty]="value"
           [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly" id="functional-group-div" *ngIf="field.isVisible">
          <mat-form-field>
              <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
              <input matInput
                     class="adf-input"
                     type="text"
                     [id]="field.id"
                     [(ngModel)]="value"
                     (keyup)="onKeyUp($event)"
                     [disabled]="field.readOnly"
                     placeholder="{{field.placeholder}}"
                     [matAutocomplete]="auto">
              <mat-autocomplete #auto="matAutocomplete" (optionSelected)="onItemSelect($event.option.value)">
                  <mat-option *ngFor="let item of groups"
                             [id]="field.id +'-'+item.id"
                             (click)="onItemClick(item, $event)"  [value]="item">
                      <span>{{item.name}}</span>
                  </mat-option>
              </mat-autocomplete>

          </mat-form-field>
          <error-widget [error]="field.validationSummary"></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-group-widget {
        width: 100%; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
FunctionalGroupWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: ElementRef, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class HyperlinkWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.linkUrl = WidgetComponent.DEFAULT_HYPERLINK_URL;
        this.linkText = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            this.linkUrl = this.getHyperlinkUrl(this.field);
            this.linkText = this.getHyperlinkText(this.field);
        }
    }
}
HyperlinkWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'hyperlink-widget',
                template: `
      <div class="adf-hyperlink-widget {{field.className}}">
          <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
          <div>
              <a [href]="linkUrl" target="_blank" rel="nofollow">{{linkText}}</a>
          </div>
      </div>
    `,
                styles: [`

    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
HyperlinkWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class MultilineTextWidgetComponentComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
MultilineTextWidgetComponentComponent.decorators = [
    { type: Component, args: [{
                selector: 'multiline-text-widget',
                template: `
      <div class="adf-multiline-text-widget {{field.className}}"
           [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
          <mat-form-field floatPlaceholder="never">
              <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
              <textarea matInput class="adf-input"
                        matTextareaAutosize
                        type="text"
                        rows="3"
                        [id]="field.id"
                        [required]="isRequired()"
                        [(ngModel)]="field.value"
                        (ngModelChange)="checkVisibility(field)"
                        [disabled]="field.readOnly || readOnly"
                        placeholder="{{field.placeholder}}">
              </textarea>
          </mat-form-field>
          <div *ngIf="field.maxLength > 0" class="adf-multiline-word-counter">
              <span>{{field?.value?.length || 0}}/{{field.maxLength}}</span>
          </div>
          <error-widget [error]="field.validationSummary"></error-widget>
          <error-widget class="adf-multiline-required-message" *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-multiline-text-widget {
        width: 100%; }

      .adf-multiline-word-counter {
        float: right;
        margin-top: -20px !important;
        min-height: 24px;
        min-width: 1px;
        font-size: 12px;
        line-height: 14px;
        overflow: hidden;
        -webkit-transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);
        transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);
        opacity: 1;
        padding-top: 5px;
        text-align: right;
        padding-right: 2px;
        padding-left: 0; }

      .adf-multiline-required-message {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
MultilineTextWidgetComponentComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class NumberWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
NumberWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'number-widget',
                template: `
      <div class="adf-textfield adf-number-widget {{field.className}}"
           [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
          <mat-form-field>
              <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
              <input matInput
                     class="adf-input"
                     type="text"
                     pattern="-?[0-9]*(\\.[0-9]+)?"
                     [id]="field.id"
                     [required]="isRequired()"
                     [value]="field.value"
                     [(ngModel)]="field.value"
                     (ngModelChange)="checkVisibility(field)"
                     [disabled]="field.readOnly"
                     placeholder="{{field.placeholder}}">
          </mat-form-field>
          <error-widget [error]="field.validationSummary" ></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-number-widget {
        width: 100%; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
NumberWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleProcessService {
    /**
     * @param {?} alfrescoJsApi
     * @param {?} logService
     */
    constructor(alfrescoJsApi, logService) {
        this.alfrescoJsApi = alfrescoJsApi;
        this.logService = logService;
    }
    /**
     * @param {?=} taskId
     * @param {?=} searchWord
     * @return {?}
     */
    getWorkflowUsers(taskId, searchWord) {
        let /** @type {?} */ option = { excludeTaskId: taskId, filter: searchWord };
        return Observable$1.fromPromise(this.getWorkflowUserApi(option))
            .map((response) => /** @type {?} */ (response.data) || [])
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getUserImage(user) {
        return this.getUserProfileImageApi(user.id);
    }
    /**
     * @param {?} taskId
     * @param {?} idToInvolve
     * @return {?}
     */
    involveUserWithTask(taskId, idToInvolve) {
        let /** @type {?} */ node = { userId: idToInvolve };
        return Observable$1.fromPromise(this.involveUserToTaskApi(taskId, node))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @param {?} idToRemove
     * @return {?}
     */
    removeInvolvedUser(taskId, idToRemove) {
        let /** @type {?} */ node = { userId: idToRemove };
        return Observable$1.fromPromise(this.removeInvolvedUserFromTaskApi(taskId, node))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    getWorkflowUserApi(options) {
        return this.alfrescoJsApi.getInstance().activiti.usersWorkflowApi.getUsers(options);
    }
    /**
     * @param {?} taskId
     * @param {?} node
     * @return {?}
     */
    involveUserToTaskApi(taskId, node) {
        return this.alfrescoJsApi.getInstance().activiti.taskActionsApi.involveUser(taskId, node);
    }
    /**
     * @param {?} taskId
     * @param {?} node
     * @return {?}
     */
    removeInvolvedUserFromTaskApi(taskId, node) {
        return this.alfrescoJsApi.getInstance().activiti.taskActionsApi.removeInvolvedUser(taskId, node);
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    getUserProfileImageApi(userId) {
        return this.alfrescoJsApi.getInstance().activiti.userApi.getUserProfilePictureUrl(userId);
    }
    /**
     * Throw the error
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
PeopleProcessService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
PeopleProcessService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class PeopleWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} peopleProcessService
     */
    constructor(formService, peopleProcessService) {
        super(formService);
        this.formService = formService;
        this.peopleProcessService = peopleProcessService;
        this.minTermLength = 1;
        this.users = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            let /** @type {?} */ params = this.field.params;
            if (params && params.restrictWithGroup) {
                let /** @type {?} */ restrictWithGroup = (params.restrictWithGroup);
                this.groupId = restrictWithGroup.id;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        let /** @type {?} */ value = ((this.input.nativeElement)).value;
        if (value && value.length >= this.minTermLength && this.oldValue !== value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                if (value.length >= this.minTermLength) {
                    this.oldValue = value;
                    this.searchUsers(value);
                }
            }
        }
        else {
            this.validateValue(value);
        }
    }
    /**
     * @param {?} userName
     * @return {?}
     */
    searchUsers(userName) {
        this.formService.getWorkflowUsers(userName, this.groupId)
            .subscribe((result) => {
            this.users = result || [];
            this.validateValue(userName);
        });
    }
    /**
     * @param {?} userName
     * @return {?}
     */
    validateValue(userName) {
        if (this.isValidUser(userName)) {
            this.field.validationSummary.message = '';
        }
        else if (!userName) {
            this.field.value = null;
            this.users = [];
        }
        else {
            this.field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            this.field.markAsInvalid();
            this.field.form.markAsInvalid();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValidUser(value) {
        let /** @type {?} */ isValid = false;
        if (value) {
            let /** @type {?} */ resultUser = this.users.find((user) => this.getDisplayName(user).toLocaleLowerCase() === value.toLocaleLowerCase());
            if (resultUser) {
                isValid = true;
            }
        }
        return isValid;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    getDisplayName(model) {
        if (model) {
            let /** @type {?} */ displayName = `${model.firstName || ''} ${model.lastName || ''}`;
            return displayName.trim();
        }
        return '';
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
        }
    }
}
PeopleWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'people-widget',
                template: `
      <div class="adf-people-widget {{field.className}}"
           [class.is-dirty]="value"
           [class.adf-invalid]="!field.isValid"
           [class.adf-readonly]="field.readOnly"
           id="people-widget-content"
           *ngIf="field.isVisible">
          <mat-form-field>
              <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
              <input #inputValue
                     matInput
                     class="adf-input"
                     type="text"
                     [id]="field.id"
                     [value]="getDisplayName(field.value)"
                     (keyup)="onKeyUp($event)"
                     [disabled]="field.readOnly"
                     placeholder="{{field.placeholder}}"
                     [matAutocomplete]="auto">
              <mat-autocomplete #auto="matAutocomplete" (optionSelected)="onItemSelect($event.option.value)"  [displayWith]="getDisplayName">
                  <mat-option *ngFor="let user of users; let i = index" [value]="user">
                      <div class="adf-people-widget-row" id="adf-people-widget-user-{{i}}">
                          <div [outerHTML]="user | usernameInitials:'adf-people-widget-pic'"></div>
                          <div *ngIf="user.pictureId" class="adf-people-widget-image-row">
                              <img id="adf-people-widget-pic-{{i}}" class="adf-people-widget-image"
                                   [src]="peopleProcessService.getUserImage(user)"/>
                          </div>
                          <span class="adf-people-label-name">{{getDisplayName(user)}}</span>
                      </div>
                  </mat-option>
              </mat-autocomplete>
          </mat-form-field>
          <error-widget [error]="field.validationSummary"></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`

    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
PeopleWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: PeopleProcessService, },
];
PeopleWidgetComponent.propDecorators = {
    'input': [{ type: ViewChild, args: ['inputValue',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class RadioButtonsWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} visibilityService
     * @param {?} logService
     */
    constructor(formService, visibilityService, logService) {
        super(formService);
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.logService = logService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getOptionsByTaskId();
            }
            else {
                this.getOptionsByProcessDefinitionId();
            }
        }
    }
    /**
     * @return {?}
     */
    getOptionsByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((result) => {
            this.field.options = result || [];
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getOptionsByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((result) => {
            this.field.options = result || [];
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    /**
     * @param {?} optionSelected
     * @return {?}
     */
    onOptionClick(optionSelected) {
        this.field.value = optionSelected;
        this.checkVisibility();
    }
    /**
     * @return {?}
     */
    checkVisibility() {
        this.visibilityService.refreshVisibility(this.field.form);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
}
RadioButtonsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'radio-buttons-widget',
                template: `
      <div class="adf-radio-buttons-widget {{field.className}}"
           [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly" [id]="field.id" *ngIf="field?.isVisible">
          <div class="adf-radio-button-container">
              <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
              <mat-radio-group class="adf-radio-group" [(ngModel)]="field.value">
                  <mat-radio-button
                      [id]="field.id + '-' + opt.id"
                      [name]="field.id"
                      [value]="opt.id"
                      [disabled]="field.readOnly"
                      [checked]="field.value === opt.id"
                      (change)="onOptionClick(opt.id)"
                      color="primary"
                      class="adf-radio-button" *ngFor="let opt of field.options" >
                      {{opt.name}}
                  </mat-radio-button>
              </mat-radio-group>
          </div>
          <error-widget [error]="field.validationSummary" ></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-radio-button-container {
        margin-bottom: 15px; }

      .adf-radio-group {
        display: -webkit-inline-box;
        display: -ms-inline-flexbox;
        display: inline-flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column; }

      .adf-radio-button {
        margin: 5px; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
RadioButtonsWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: WidgetVisibilityService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable: component-selector, no-use-before-declare  */
const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => InputMaskDirective),
    multi: true
};
class InputMaskDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.translationMask = {
            '0': { pattern: /\d/ },
            '9': { pattern: /\d/, optional: true },
            '#': { pattern: /\d/, recursive: true },
            'A': { pattern: /[a-zA-Z0-9]/ },
            'S': { pattern: /[a-zA-Z]/ }
        };
        this.byPassKeys = [9, 16, 17, 18, 36, 37, 38, 39, 40, 91];
        this.invalidCharacters = [];
        this._onChange = (_) => {
        };
        this._onTouched = () => {
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTextInput(event) {
        if (this.inputMask && this.inputMask.mask) {
            this.maskValue(this.el.nativeElement.value, this.el.nativeElement.selectionStart, this.inputMask.mask, this.inputMask.isReversed, event.keyCode);
        }
        else {
            this._onChange(this.el.nativeElement.value);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['inputMask'] && changes['inputMask'].currentValue['mask']) {
            this.inputMask = changes['inputMask'].currentValue;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.el.nativeElement.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} actualValue
     * @param {?} startCaret
     * @param {?} maskToApply
     * @param {?} isMaskReversed
     * @param {?} keyCode
     * @return {?}
     */
    maskValue(actualValue, startCaret, maskToApply, isMaskReversed, keyCode) {
        if (this.byPassKeys.indexOf(keyCode) === -1) {
            let /** @type {?} */ value = this.getMasked(false, actualValue, maskToApply, isMaskReversed);
            let /** @type {?} */ calculatedCaret = this.calculateCaretPosition(startCaret, actualValue, keyCode);
            this.render.setElementAttribute(this.el.nativeElement, 'value', value);
            this.el.nativeElement.value = value;
            this.setValue(value);
            this._onChange(value);
            this.setCaretPosition(calculatedCaret);
        }
    }
    /**
     * @param {?} caretPosition
     * @return {?}
     */
    setCaretPosition(caretPosition) {
        this.el.nativeElement.moveStart = caretPosition;
        this.el.nativeElement.moveEnd = caretPosition;
    }
    /**
     * @param {?} caretPosition
     * @param {?} newValue
     * @param {?} keyCode
     * @return {?}
     */
    calculateCaretPosition(caretPosition, newValue, keyCode) {
        let /** @type {?} */ newValueLength = newValue.length;
        let /** @type {?} */ oldValue = this.getValue() || '';
        let /** @type {?} */ oldValueLength = oldValue.length;
        if (keyCode === 8 && oldValue !== newValue) {
            caretPosition = caretPosition - (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
        }
        else if (oldValue !== newValue) {
            if (caretPosition >= oldValueLength) {
                caretPosition = newValueLength;
            }
            else {
                caretPosition = caretPosition + (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
            }
        }
        return caretPosition;
    }
    /**
     * @param {?} skipMaskChars
     * @param {?} val
     * @param {?} mask
     * @param {?=} isReversed
     * @return {?}
     */
    getMasked(skipMaskChars, val, mask, isReversed = false) {
        let /** @type {?} */ buf = [], /** @type {?} */ value = val, /** @type {?} */ maskIndex = 0, /** @type {?} */ maskLen = mask.length, /** @type {?} */ valueIndex = 0, /** @type {?} */ valueLength = value.length, /** @type {?} */ offset = 1, /** @type {?} */ addMethod = 'push', /** @type {?} */ resetPos = -1, /** @type {?} */ lastMaskChar, /** @type {?} */ lastUntranslatedMaskChar, /** @type {?} */ check;
        if (isReversed) {
            addMethod = 'unshift';
            offset = -1;
            lastMaskChar = 0;
            maskIndex = maskLen - 1;
            valueIndex = valueLength - 1;
        }
        else {
            lastMaskChar = maskLen - 1;
        }
        check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        while (check) {
            let /** @type {?} */ maskDigit = mask.charAt(maskIndex), /** @type {?} */ valDigit = value.charAt(valueIndex), /** @type {?} */ translation = this.translationMask[maskDigit];
            if (translation) {
                if (valDigit.match(translation.pattern)) {
                    buf[addMethod](valDigit);
                    if (translation.recursive) {
                        if (resetPos === -1) {
                            resetPos = maskIndex;
                        }
                        else if (maskIndex === lastMaskChar) {
                            maskIndex = resetPos - offset;
                        }
                        if (lastMaskChar === resetPos) {
                            maskIndex -= offset;
                        }
                    }
                    maskIndex += offset;
                }
                else if (valDigit === lastUntranslatedMaskChar) {
                    lastUntranslatedMaskChar = undefined;
                }
                else if (translation.optional) {
                    maskIndex += offset;
                    valueIndex -= offset;
                }
                else {
                    this.invalidCharacters.push({
                        index: valueIndex,
                        digit: valDigit,
                        translated: translation.pattern
                    });
                }
                valueIndex += offset;
            }
            else {
                if (!skipMaskChars) {
                    buf[addMethod](maskDigit);
                }
                if (valDigit === maskDigit) {
                    valueIndex += offset;
                }
                else {
                    lastUntranslatedMaskChar = maskDigit;
                }
                maskIndex += offset;
            }
            check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        }
        let /** @type {?} */ lastMaskCharDigit = mask.charAt(lastMaskChar);
        if (maskLen === valueLength + 1 && !this.translationMask[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
        }
        return buf.join('');
    }
    /**
     * @param {?} isReversed
     * @param {?} maskIndex
     * @param {?} maskLen
     * @param {?} valueIndex
     * @param {?} valueLength
     * @return {?}
     */
    isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength) {
        let /** @type {?} */ check = false;
        if (isReversed) {
            check = (maskIndex > -1) && (valueIndex > -1);
        }
        else {
            check = (maskIndex < maskLen) && (valueIndex < valueLength);
        }
        return check;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        this.value = value;
    }
    /**
     * @return {?}
     */
    getValue() {
        return this.value;
    }
}
InputMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[textMask]',
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR]
            },] },
];
/**
 * @nocollapse
 */
InputMaskDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
];
InputMaskDirective.propDecorators = {
    'inputMask': [{ type: Input, args: ['textMask',] },],
    'onTextInput': [{ type: HostListener, args: ['input', ['$event'],] }, { type: HostListener, args: ['keyup', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class TextWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field.params && this.field.params['inputMask']) {
            this.mask = this.field.params['inputMask'];
            this.isMaskReversed = this.field.params['inputMaskReversed'] ? this.field.params['inputMaskReversed'] : false;
        }
    }
}
TextWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'text-widget',
                template: `
      <div class="adf-textfield adf-text-widget {{field.className}}"
           [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
          <mat-form-field>
              <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
              <input matInput
                     class="adf-input"
                     type="text"
                     [id]="field.id"
                     [required]="isRequired()"
                     [value]="field.value"
                     [(ngModel)]="field.value"
                     (ngModelChange)="onFieldChanged(field)"
                     [disabled]="field.readOnly || readOnly"
                     [textMask]="{mask: mask, isReversed: isMaskReversed}"
                     placeholder="{{field.placeholder}}">
          </mat-form-field>
          <error-widget [error]="field.validationSummary"></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-text-widget {
        width: 100%; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TextWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class TypeaheadWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} visibilityService
     * @param {?} logService
     */
    constructor(formService, visibilityService, logService) {
        super(formService);
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.logService = logService;
        this.minTermLength = 1;
        this.options = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field.form.taskId) {
            this.getValuesByTaskId();
        }
        else if (this.field.form.processDefinitionId) {
            this.getValuesByProcessDefinitionId();
        }
        if (this.isReadOnlyType()) {
            this.value = this.field.value;
        }
    }
    /**
     * @return {?}
     */
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((result) => {
            let /** @type {?} */ options = result || [];
            this.field.options = options;
            let /** @type {?} */ fieldValue = this.field.value;
            if (fieldValue) {
                let /** @type {?} */ toSelect = options.find(item => item.id === fieldValue);
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.field.updateForm();
            this.visibilityService.refreshEntityVisibility(this.field);
        }, err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((result) => {
            let /** @type {?} */ options = result || [];
            this.field.options = options;
            let /** @type {?} */ fieldValue = this.field.value;
            if (fieldValue) {
                let /** @type {?} */ toSelect = options.find(item => item.id === fieldValue);
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.field.updateForm();
            this.visibilityService.refreshEntityVisibility(this.field);
        }, err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getOptions() {
        let /** @type {?} */ val = this.value.trim().toLocaleLowerCase();
        return this.field.options.filter(item => {
            let /** @type {?} */ name = item.name.toLocaleLowerCase();
            return name.indexOf(val) > -1;
        });
    }
    /**
     * @param {?} optionName
     * @return {?}
     */
    isValidOptionName(optionName) {
        let /** @type {?} */ option = this.field.options.find(item => item.name && item.name.toLocaleLowerCase() === optionName.toLocaleLowerCase());
        return option ? true : false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        if (this.value && this.value.trim().length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                if (this.value.length >= this.minTermLength) {
                    this.options = this.getOptions();
                    this.oldValue = this.value;
                    if (this.isValidOptionName(this.value)) {
                        this.field.value = this.options[0].id;
                    }
                }
            }
        }
        if (this.isValueDefined() && this.value.trim().length === 0) {
            this.oldValue = this.value;
            this.options = [];
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        if (item) {
            this.field.value = item.id;
            this.value = item.name;
            this.checkVisibility();
        }
    }
    /**
     * @return {?}
     */
    validate() {
        this.field.value = this.value;
    }
    /**
     * @return {?}
     */
    isValueDefined() {
        return this.value !== null && this.value !== undefined;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
    /**
     * @return {?}
     */
    checkVisibility() {
        this.visibilityService.refreshVisibility(this.field.form);
    }
    /**
     * @return {?}
     */
    isReadOnlyType() {
        return this.field.type === 'readonly' ? true : false;
    }
}
TypeaheadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'typeahead-widget',
                template: `
      <div class="adf-typeahead-widget-container">
          <div class="adf-typeahead-widget {{field.className}}"
              [class.is-dirty]="value"
              [class.adf-invalid]="!field.isValid"
              [class.adf-readonly]="field.readOnly"
              id="typehead-div" *ngIf="field.isVisible">
              <mat-form-field>
                  <label class="adf-label" [attr.for]="field.id">{{field.name}}</label>
                  <input matInput class="adf-input"
                         type="text"
                         [id]="field.id"
                         [(ngModel)]="value"
                         (ngModelChange)="validate()"
                         (keyup)="onKeyUp($event)"
                         [disabled]="field.readOnly"
                         placeholder="{{field.placeholder}}"
                         [matAutocomplete]="auto">
                  <mat-autocomplete #auto="matAutocomplete" (optionSelected)="onItemSelect($event.option.value)">
                      <mat-option *ngFor="let item of options" [value]="item">
                          <span [id]="field.name+'_option_'+item.id">{{item.name}}</span>
                      </mat-option>
                  </mat-autocomplete>
              </mat-form-field>

              <error-widget [error]="field.validationSummary"></error-widget>
              <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
          </div>
      </div>
    `,
                styles: [`
      .adf-typeahead-widget-container {
        position: relative;
        display: block; }

      .adf-typeahead-widget {
        width: 100%; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TypeaheadWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: WidgetVisibilityService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessContentService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @return {?}
     */
    get contentApi() {
        return this.apiService.getInstance().activiti.contentApi;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    createTemporaryRawRelatedContent(file) {
        return Observable$1.fromPromise(this.contentApi.createTemporaryRawRelatedContent(file)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    getFileContent(contentId) {
        return Observable$1.fromPromise(this.contentApi.getContent(contentId)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    getFileRawContent(contentId) {
        return Observable$1.fromPromise(this.contentApi.getRawContent(contentId)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    getContentPreview(contentId) {
        return new Observable$1(observer => {
            this.contentApi.getContentPreview(contentId).then((result) => {
                observer.next(result);
                observer.complete();
            }, () => {
                this.contentApi.getRawContent(contentId).then((data) => {
                    observer.next(data);
                    observer.complete();
                }, (err) => {
                    observer.error(err);
                    observer.complete();
                });
            });
        });
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    getFileRawContentUrl(contentId) {
        return this.contentApi.getRawContentUrl(contentId);
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    getContentThumbnail(contentId) {
        return Observable$1.fromPromise(this.contentApi.getContentThumbnail(contentId)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getTaskRelatedContent(taskId) {
        return Observable$1.fromPromise(this.contentApi.getRelatedContentForTask(taskId))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    getProcessRelatedContent(processId) {
        return Observable$1.fromPromise(this.contentApi.getRelatedContentForProcessInstance(processId))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    deleteRelatedContent(contentId) {
        return Observable$1.fromPromise(this.contentApi.deleteContent(contentId))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} processInstanceId
     * @param {?} content
     * @param {?=} opts
     * @return {?}
     */
    createProcessRelatedContent(processInstanceId, content, opts) {
        return Observable$1.fromPromise(this.contentApi.createRelatedContentOnProcessInstance(processInstanceId, content, opts))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @param {?} file
     * @param {?=} opts
     * @return {?}
     */
    createTaskRelatedContent(taskId, file, opts) {
        return Observable$1.fromPromise(this.contentApi.createRelatedContentOnTask(taskId, file, opts))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        let /** @type {?} */ errMsg = ProcessContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ProcessContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return Observable$1.throw(errMsg);
    }
}
ProcessContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ProcessContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ProcessContentService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ProcessContentService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class UploadWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     * @param {?} thumbnailService
     * @param {?} processContentService
     */
    constructor(formService, logService, thumbnailService, processContentService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
        this.processContentService = processContentService;
        this.multipleOption = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0) {
            this.hasFile = true;
        }
        this.getMultipleFileParam();
    }
    /**
     * @param {?} file
     * @return {?}
     */
    removeFile(file) {
        if (this.field) {
            this.removeElementFromList(file);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileChanged(event) {
        let /** @type {?} */ files = event.target.files;
        let /** @type {?} */ filesSaved = [];
        if (this.field.json.value) {
            filesSaved = [...this.field.json.value];
        }
        if (files && files.length > 0) {
            Observable$1.from(files).mergeMap(file => this.uploadRawContent(file)).subscribe((res) => {
                filesSaved.push(res);
            }, (error) => {
                this.logService.error('Error uploading file. See console output for more details.');
            }, () => {
                this.field.value = filesSaved;
                this.field.json.value = filesSaved;
            });
            this.hasFile = true;
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    uploadRawContent(file) {
        return this.processContentService.createTemporaryRawRelatedContent(file)
            .map((response) => {
            this.logService.info(response);
            return response;
        });
    }
    /**
     * @return {?}
     */
    getMultipleFileParam() {
        if (this.field &&
            this.field.params &&
            this.field.params.multiple) {
            this.multipleOption = this.field.params.multiple ? 'multiple' : '';
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    removeElementFromList(file) {
        let /** @type {?} */ index = this.field.value.indexOf(file);
        if (index !== -1) {
            this.field.value.splice(index, 1);
            this.field.json.value = this.field.value;
            this.field.updateForm();
        }
        this.hasFile = this.field.value.length > 0;
        this.resetFormValueWithNoFiles();
    }
    /**
     * @return {?}
     */
    resetFormValueWithNoFiles() {
        if (this.field.value.length === 0) {
            this.field.value = [];
            this.field.json.value = [];
        }
    }
    /**
     * @param {?} mimeType
     * @return {?}
     */
    getIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    fileClicked(obj) {
        const /** @type {?} */ file = new ContentLinkModel(obj);
        let /** @type {?} */ fetch = this.processContentService.getContentPreview(file.id);
        if (file.isTypeImage() || file.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(file.id);
        }
        fetch.subscribe((blob) => {
            file.contentBlob = blob;
            this.formService.formContentClicked.next(file);
        }, (error) => {
            this.logService.error('Unable to send event for file ' + file.name);
        });
    }
}
UploadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'upload-widget',
                template: `
      <div class="adf-upload-widget {{field.className}}"
           [class.adf-invalid]="!field.isValid"
           [class.adf-readonly]="field.readOnly">
          <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
          <div class="adf-upload-widget-container">
              <div>
                  <mat-list *ngIf="hasFile">
                      <mat-list-item class="adf-upload-files-row" *ngFor="let file of field.value">
                          <img mat-list-icon class="adf-upload-widget__icon"
                               [id]="'file-'+file.id+'-icon'"
                               [src]="getIcon(file.mimeType)"
                               [alt]="mimeTypeIcon"
                               (click)="fileClicked(file)"
                               (keyup.enter)="fileClicked(file)"
                               role="button"
                               tabindex="0"/>
                          <span matLine id="{{'file-'+file.id}}" (click)="fileClicked(file)" (keyup.enter)="fileClicked(file)"
                                role="button" tabindex="0" class="adf-file">{{file.name}}</span>
                          <button *ngIf="!field.readOnly" mat-icon-button [id]="'file-'+file.id+'-remove'"
                                  (click)="removeFile(file);" (keyup.enter)="removeFile(file);">
                              <mat-icon class="mat-24">highlight_off</mat-icon>
                          </button>
                      </mat-list-item>
                  </mat-list>
              </div>

              <div class="button-row" *ngIf="(!hasFile || multipleOption) && !field.readOnly">
                  <a mat-raised-button color="primary">
                      {{ 'FORM.FIELD.UPLOAD' | translate }}<mat-icon>file_upload</mat-icon>
                      <input #uploadFiles
                             [multiple]="multipleOption"
                             type="file"
                             [id]="field.id"
                             (change)="onFileChanged($event)"/>
                  </a>
              </div>
          </div>
          <error-widget [error]="field.validationSummary"></error-widget>
          <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
      </div>
    `,
                styles: [`
      .adf-upload-widget-container {
        margin-bottom: 15px; }
        .adf-upload-widget-container input {
          cursor: pointer;
          height: 100%;
          right: 0;
          opacity: 0;
          position: absolute;
          top: 0;
          width: 300px;
          z-index: 4; }

      .adf-upload-widget {
        width: 100%;
        word-break: break-all;
        padding: 0.4375em 0;
        border-top: 0.84375em solid transparent; }

      .adf-upload-widget__icon {
        padding: 6px;
        float: left;
        cursor: pointer; }

      .adf-upload-widget__reset {
        margin-top: -2px; }

      .adf-upload-files-row .mat-line {
        margin-bottom: 0px; }
    `],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
UploadWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
    { type: ThumbnailService, },
    { type: ProcessContentService, },
];
UploadWidgetComponent.propDecorators = {
    'fileInput': [{ type: ViewChild, args: ['uploadFiles',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WIDGET_DIRECTIVES = [
    UnknownWidgetComponent,
    TabsWidgetComponent,
    ContainerWidgetComponent,
    TextWidgetComponent,
    NumberWidgetComponent,
    CheckboxWidgetComponent,
    MultilineTextWidgetComponentComponent,
    DropdownWidgetComponent,
    HyperlinkWidgetComponent,
    RadioButtonsWidgetComponent,
    DisplayTextWidgetComponentComponent,
    UploadWidgetComponent,
    AttachWidgetComponent,
    TypeaheadWidgetComponent,
    FunctionalGroupWidgetComponent,
    PeopleWidgetComponent,
    DateWidgetComponent,
    AmountWidgetComponent,
    DynamicTableWidgetComponent,
    DateEditorComponent,
    DropdownEditorComponent,
    BooleanEditorComponent,
    TextEditorComponent,
    RowEditorComponent,
    ErrorWidgetComponent,
    DocumentWidgetComponent
];
const MASK_DIRECTIVE = [
    InputMaskDirective
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartFormCustomButtonDirective {
}
StartFormCustomButtonDirective.decorators = [
    { type: Directive, args: [{ selector: '[form-custom-button]' },] },
];
/**
 * @nocollapse
 */
StartFormCustomButtonDirective.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormRenderingService extends DynamicComponentMapper {
    constructor() {
        super();
        this.defaultValue = UnknownWidgetComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(TextWidgetComponent),
            'string': DynamicComponentResolver.fromType(TextWidgetComponent),
            'integer': DynamicComponentResolver.fromType(NumberWidgetComponent),
            'multi-line-text': DynamicComponentResolver.fromType(MultilineTextWidgetComponentComponent),
            'boolean': DynamicComponentResolver.fromType(CheckboxWidgetComponent),
            'dropdown': DynamicComponentResolver.fromType(DropdownWidgetComponent),
            'date': DynamicComponentResolver.fromType(DateWidgetComponent),
            'amount': DynamicComponentResolver.fromType(AmountWidgetComponent),
            'radio-buttons': DynamicComponentResolver.fromType(RadioButtonsWidgetComponent),
            'hyperlink': DynamicComponentResolver.fromType(HyperlinkWidgetComponent),
            'readonly-text': DynamicComponentResolver.fromType(DisplayTextWidgetComponentComponent),
            'typeahead': DynamicComponentResolver.fromType(TypeaheadWidgetComponent),
            'people': DynamicComponentResolver.fromType(PeopleWidgetComponent),
            'functional-group': DynamicComponentResolver.fromType(FunctionalGroupWidgetComponent),
            'dynamic-table': DynamicComponentResolver.fromType(DynamicTableWidgetComponent),
            'container': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'group': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'document': DynamicComponentResolver.fromType(DocumentWidgetComponent)
        };
        this.types['upload'] = (field) => {
            if (field) {
                let params = field.params;
                if (params && params.link) {
                    return AttachWidgetComponent;
                }
                return UploadWidgetComponent;
            }
            return UnknownWidgetComponent;
        };
    }
}
FormRenderingService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
FormRenderingService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormFieldComponent {
    /**
     * @param {?} formRenderingService
     * @param {?} componentFactoryResolver
     * @param {?} visibilityService
     * @param {?} compiler
     */
    constructor(formRenderingService, componentFactoryResolver, visibilityService, compiler) {
        this.formRenderingService = formRenderingService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.visibilityService = visibilityService;
        this.compiler = compiler;
        this.field = null;
        this.focus = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ originalField = this.getField();
        if (originalField) {
            let /** @type {?} */ customTemplate = this.field.form.customFieldTemplates[originalField.type];
            if (customTemplate && this.hasController(originalField.type)) {
                let /** @type {?} */ factory = this.getComponentFactorySync(originalField.type, customTemplate);
                this.componentRef = this.container.createComponent(factory);
                let /** @type {?} */ instance = this.componentRef.instance;
                if (instance) {
                    instance.field = originalField;
                }
            }
            else {
                let /** @type {?} */ componentType = this.formRenderingService.resolveComponentType(originalField);
                if (componentType) {
                    let /** @type {?} */ factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
                    this.componentRef = this.container.createComponent(factory);
                    let /** @type {?} */ instance = (this.componentRef.instance);
                    instance.field = this.field;
                    instance.fieldChanged.subscribe(field => {
                        if (field && this.field.form) {
                            this.visibilityService.refreshVisibility(this.field.form);
                        }
                    });
                }
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    /**
     * @return {?}
     */
    getField() {
        if (this.field && this.field.params) {
            const /** @type {?} */ wrappedField = this.field.params.field;
            if (wrappedField && wrappedField.type) {
                return wrappedField;
            }
        }
        return this.field;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    hasController(type) {
        return (adf && adf.components && adf.components[type]);
    }
    /**
     * @param {?} type
     * @param {?} template
     * @return {?}
     */
    getComponentFactorySync(type, template) {
        let /** @type {?} */ componentInfo = adf.components[type];
        if (componentInfo.factory) {
            return componentInfo.factory;
        }
        let /** @type {?} */ metadata = {
            selector: `runtime-component-${type}`,
            template: template
        };
        let /** @type {?} */ factory = this.createComponentFactorySync(this.compiler, metadata, componentInfo.class);
        componentInfo.factory = factory;
        return factory;
    }
    /**
     * @param {?} compiler
     * @param {?} metadata
     * @param {?} componentClass
     * @return {?}
     */
    createComponentFactorySync(compiler, metadata, componentClass) {
        const /** @type {?} */ cmpClass = componentClass || class RuntimeComponent {
        };
        const /** @type {?} */ decoratedCmp = Component(metadata)(cmpClass);
        class RuntimeComponentModule {
        }
        RuntimeComponentModule.decorators = [
            { type: NgModule, args: [{ imports: [], declarations: [decoratedCmp] },] },
        ];
        /**
         * @nocollapse
         */
        RuntimeComponentModule.ctorParameters = () => [];
        let /** @type {?} */ module = compiler.compileModuleAndAllComponentsSync(RuntimeComponentModule);
        return module.componentFactories.find(x => x.componentType === decoratedCmp);
    }
    /**
     * @return {?}
     */
    focusToggle() {
        this.focus = !this.focus;
    }
}
FormFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-field, form-field',
                template: `
        <div [hidden]="!field?.isVisible"
            [class.adf-focus]="focus"
            (focusin)="focusToggle()"
            (focusout)="focusToggle()">
            <div #container></div>
        </div>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
FormFieldComponent.ctorParameters = () => [
    { type: FormRenderingService, },
    { type: ComponentFactoryResolver, },
    { type: WidgetVisibilityService, },
    { type: Compiler, },
];
FormFieldComponent.propDecorators = {
    'container': [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] },],
    'field': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormListComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        this.formService = formService;
        this.forms = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.getForms();
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.forms && this.forms.length === 0;
    }
    /**
     * @return {?}
     */
    getForms() {
        this.formService.getForms().subscribe((forms$$1) => {
            this.forms.push(...forms$$1);
        });
    }
}
FormListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-list',
                template: `
      <adf-datatable *ngIf="!isEmpty()"
          [rows]="forms">
          <data-columns>
              <data-column key="name" type="text" title="Name" class="ellipsis-cell" [sortable]="true"></data-column>
              <data-column key="lastUpdatedByFullName" type="text" title="User" class="ellipsis-cell" [sortable]="true"></data-column>
              <data-column key="lastUpdated" type="date" format="shortDate" title="Date"></data-column>
          </data-columns>
      </adf-datatable>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
FormListComponent.ctorParameters = () => [
    { type: FormService, },
];
FormListComponent.propDecorators = {
    'forms': [{ type: Input },],
};

class NodeMetadata {
    /**
     * @param {?} metadata
     * @param {?} nodeType
     */
    constructor(metadata, nodeType) {
        this.metadata = metadata;
        this.nodeType = nodeType;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Get All the metadata and the nodeType for a nodeId cleaned by the prefix
     * @param {?} nodeId Node Id
     * @return {?} NodeMetadata
     */
    getNodeMetadata(nodeId) {
        return Observable$1.fromPromise(this.apiService.getInstance().nodes.getNodeInfo(nodeId)).map(this.cleanMetadataFromSemicolon);
    }
    /**
     * Create a new Node from form metadata
     * @param {?} nodeType node type
     * @param {?} nameSpace namespace node
     * @param {?} data data to store
     * @param {?} path path
     * @param {?=} name
     * @return {?} NodeMetadata
     */
    createNodeMetadata(nodeType, nameSpace, data, path, name) {
        let /** @type {?} */ properties = {};
        for (let /** @type {?} */ key in data) {
            if (data[key]) {
                properties[nameSpace + ':' + key] = data[key];
            }
        }
        return this.createNode(name || this.generateUuid(), nodeType, properties, path);
    }
    /**
     * Create a new Node from form metadata
     * @param {?} name path
     * @param {?} nodeType node type
     * @param {?} properties namespace node
     * @param {?} path path
     * @return {?} NodeMetadata
     */
    createNode(name, nodeType, properties, path) {
        let /** @type {?} */ body = {
            name: name,
            nodeType: nodeType,
            properties: properties,
            relativePath: path
        };
        // TODO: requires update to alfresco-js-api typings
        let /** @type {?} */ apiService = this.apiService.getInstance();
        return Observable$1.fromPromise(apiService.nodes.addNode('-root-', body, {}));
    }
    /**
     * @return {?}
     */
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            let /** @type {?} */ r = Math.random() * 16 | 0, /** @type {?} */ v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    cleanMetadataFromSemicolon(data) {
        let /** @type {?} */ metadata = {};
        if (data && data.properties) {
            for (let /** @type {?} */ key in data.properties) {
                if (key) {
                    if (key.indexOf(':') !== -1) {
                        metadata[key.split(':')[1]] = data.properties[key];
                    }
                    else {
                        metadata[key] = data.properties[key];
                    }
                }
            }
        }
        return new NodeMetadata(metadata, data.nodeType);
    }
}
NodeService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NodeService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable */
class FormComponent {
    /**
     * @param {?} formService
     * @param {?} visibilityService
     * @param {?} ecmModelService
     * @param {?} nodeService
     */
    constructor(formService, visibilityService, ecmModelService, nodeService) {
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.ecmModelService = ecmModelService;
        this.nodeService = nodeService;
        this.saveMetadata = false;
        this.showTitle = true;
        this.showCompleteButton = true;
        this.disableCompleteButton = false;
        this.disableStartProcessButton = false;
        this.showSaveButton = true;
        this.showDebugButton = false;
        this.readOnly = false;
        this.showRefreshButton = true;
        this.showValidationIcon = true;
        this.fieldValidators = [];
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.formLoaded = new EventEmitter();
        this.formDataRefreshed = new EventEmitter();
        this.executeOutcome = new EventEmitter();
        this.onError = new EventEmitter();
        this.debugMode = false;
    }
    /**
     * @return {?}
     */
    hasForm() {
        return this.form ? true : false;
    }
    /**
     * @return {?}
     */
    isTitleEnabled() {
        if (this.showTitle) {
            if (this.form && this.form.taskName) {
                return true;
            }
        }
        return false;
    }
    /**
     * @param {?} outcome
     * @return {?}
     */
    isOutcomeButtonEnabled(outcome) {
        if (this.form.readOnly) {
            return false;
        }
        if (outcome) {
            // Make 'Save' button always available
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return true;
            }
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.disableCompleteButton ? false : this.form.isValid;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return this.disableStartProcessButton ? false : this.form.isValid;
            }
            return this.form.isValid;
        }
        return false;
    }
    /**
     * @param {?} outcome
     * @param {?} isFormReadOnly
     * @return {?}
     */
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.name) {
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.showCompleteButton;
            }
            if (isFormReadOnly) {
                return outcome.isSelected;
            }
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return this.showSaveButton;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return false;
            }
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.formService.formContentClicked.subscribe((content) => {
            this.formContentClicked.emit(content);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.getFormByTaskId(taskId.currentValue);
            return;
        }
        let /** @type {?} */ formId = changes['formId'];
        if (formId && formId.currentValue) {
            this.getFormDefinitionByFormId(formId.currentValue);
            return;
        }
        let /** @type {?} */ formName = changes['formName'];
        if (formName && formName.currentValue) {
            this.getFormDefinitionByFormName(formName.currentValue);
            return;
        }
        let /** @type {?} */ nodeId = changes['nodeId'];
        if (nodeId && nodeId.currentValue) {
            this.loadFormForEcmNode(nodeId.currentValue);
            return;
        }
        let /** @type {?} */ data = changes['data'];
        if (data && data.currentValue) {
            this.refreshFormData();
            return;
        }
    }
    /**
     * Invoked when user clicks outcome button.
     * @param {?} outcome Form outcome model
     * @return {?}
     */
    onOutcomeClicked(outcome) {
        if (!this.readOnly && outcome && this.form) {
            if (!this.onExecuteOutcome(outcome)) {
                return false;
            }
            if (outcome.isSystem) {
                if (outcome.id === FormComponent.SAVE_OUTCOME_ID) {
                    this.saveTaskForm();
                    return true;
                }
                if (outcome.id === FormComponent.COMPLETE_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormComponent.START_PROCESS_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormComponent.CUSTOM_OUTCOME_ID) {
                    this.onTaskSaved(this.form);
                    this.storeFormAsMetadata();
                    return true;
                }
            }
            else {
                // Note: Activiti is using NAME field rather than ID for outcomes
                if (outcome.name) {
                    this.onTaskSaved(this.form);
                    this.completeTaskForm(outcome.name);
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Invoked when user clicks form refresh button.
     * @return {?}
     */
    onRefreshClicked() {
        this.loadForm();
    }
    /**
     * @return {?}
     */
    loadForm() {
        if (this.taskId) {
            this.getFormByTaskId(this.taskId);
            return;
        }
        if (this.formId) {
            this.getFormDefinitionByFormId(this.formId);
            return;
        }
        if (this.formName) {
            this.getFormDefinitionByFormName(this.formName);
            return;
        }
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    findProcessVariablesByTaskId(taskId) {
        return this.formService.getTask(taskId).
            switchMap((task) => {
            if (this.isAProcessTask(task)) {
                return this.visibilityService.getTaskProcessVariable(taskId);
            }
            else {
                return Observable$1.of({});
            }
        });
    }
    /**
     * @param {?} taskRepresentation
     * @return {?}
     */
    isAProcessTask(taskRepresentation) {
        return taskRepresentation.processDefinitionId && taskRepresentation.processDefinitionDeploymentId !== 'null';
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getFormByTaskId(taskId) {
        return new Promise((resolve, reject) => {
            this.findProcessVariablesByTaskId(taskId).subscribe((processVariables) => {
                this.formService
                    .getTaskForm(taskId)
                    .subscribe(form => {
                    const /** @type {?} */ parsedForm = this.parseForm(form);
                    this.visibilityService.refreshVisibility(parsedForm);
                    this.form = parsedForm;
                    this.onFormLoaded(this.form);
                    resolve(this.form);
                }, error => {
                    this.handleError(error);
                    // reject(error);
                    resolve(null);
                });
            });
        });
    }
    /**
     * @param {?} formId
     * @return {?}
     */
    getFormDefinitionByFormId(formId) {
        this.formService
            .getFormDefinitionById(formId)
            .subscribe(form => {
            this.formName = form.name;
            this.form = this.parseForm(form);
            this.onFormLoaded(this.form);
        }, (error) => {
            this.handleError(error);
        });
    }
    /**
     * @param {?} formName
     * @return {?}
     */
    getFormDefinitionByFormName(formName) {
        this.formService
            .getFormDefinitionByName(formName)
            .subscribe(id => {
            this.formService.getFormDefinitionById(id).subscribe(form => {
                this.form = this.parseForm(form);
                this.onFormLoaded(this.form);
            }, (error) => {
                this.handleError(error);
            });
        }, (error) => {
            this.handleError(error);
        });
    }
    /**
     * @return {?}
     */
    saveTaskForm() {
        if (this.form && this.form.taskId) {
            this.formService
                .saveTaskForm(this.form.taskId, this.form.values)
                .subscribe(() => {
                this.onTaskSaved(this.form);
                this.storeFormAsMetadata();
            }, error => this.onTaskSavedError(this.form, error));
        }
    }
    /**
     * @param {?=} outcome
     * @return {?}
     */
    completeTaskForm(outcome) {
        if (this.form && this.form.taskId) {
            this.formService
                .completeTaskForm(this.form.taskId, this.form.values, outcome)
                .subscribe(() => {
                this.onTaskCompleted(this.form);
                this.storeFormAsMetadata();
            }, error => this.onTaskCompletedError(this.form, error));
        }
    }
    /**
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        this.onError.emit(err);
    }
    /**
     * @param {?} json
     * @return {?}
     */
    parseForm(json) {
        if (json) {
            let /** @type {?} */ form = new FormModel(json, this.data, this.readOnly, this.formService);
            if (!json.fields) {
                form.outcomes = this.getFormDefinitionOutcomes(form);
            }
            if (this.fieldValidators && this.fieldValidators.length > 0) {
                form.fieldValidators = this.fieldValidators;
            }
            return form;
        }
        return null;
    }
    /**
     * Get custom set of outcomes for a Form Definition.
     * @param {?} form Form definition model.
     * @return {?}
     */
    getFormDefinitionOutcomes(form) {
        return [
            new FormOutcomeModel(form, { id: '$custom', name: FormOutcomeModel.SAVE_ACTION, isSystem: true })
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    checkVisibility(field) {
        if (field && field.form) {
            this.visibilityService.refreshVisibility(field.form);
        }
    }
    /**
     * @return {?}
     */
    refreshFormData() {
        this.form = this.parseForm(this.form.json);
        this.onFormLoaded(this.form);
        this.onFormDataRefreshed(this.form);
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    loadFormForEcmNode(nodeId) {
        this.nodeService.getNodeMetadata(nodeId).subscribe(data => {
            this.data = data.metadata;
            this.loadFormFromActiviti(data.nodeType);
        }, this.handleError);
    }
    /**
     * @param {?} nodeType
     * @return {?}
     */
    loadFormFromActiviti(nodeType) {
        this.formService.searchFrom(nodeType).subscribe(form => {
            if (!form) {
                this.formService.createFormFromANode(nodeType).subscribe(formMetadata => {
                    this.loadFormFromFormId(formMetadata.id);
                });
            }
            else {
                this.loadFormFromFormId(form.id);
            }
        }, (error) => {
            this.handleError(error);
        });
    }
    /**
     * @param {?} formId
     * @return {?}
     */
    loadFormFromFormId(formId) {
        this.formId = formId;
        this.loadForm();
    }
    /**
     * @return {?}
     */
    storeFormAsMetadata() {
        if (this.saveMetadata) {
            this.ecmModelService.createEcmTypeForActivitiForm(this.formName, this.form).subscribe(type => {
                this.nodeService.createNodeMetadata(type.nodeType || type.entry.prefixedName, EcmModelService.MODEL_NAMESPACE, this.form.values, this.path, this.nameNode);
            }, (error) => {
                this.handleError(error);
            });
        }
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormLoaded(form) {
        this.formLoaded.emit(form);
        this.formService.formLoaded.next(new FormEvent(form));
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormDataRefreshed(form) {
        this.formDataRefreshed.emit(form);
        this.formService.formDataRefreshed.next(new FormEvent(form));
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onTaskSaved(form) {
        this.formSaved.emit(form);
        this.formService.taskSaved.next(new FormEvent(form));
    }
    /**
     * @param {?} form
     * @param {?} error
     * @return {?}
     */
    onTaskSavedError(form, error) {
        this.handleError(error);
        this.formService.taskSavedError.next(new FormErrorEvent(form, error));
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onTaskCompleted(form) {
        this.formCompleted.emit(form);
        this.formService.taskCompleted.next(new FormEvent(form));
    }
    /**
     * @param {?} form
     * @param {?} error
     * @return {?}
     */
    onTaskCompletedError(form, error) {
        this.handleError(error);
        this.formService.taskCompletedError.next(new FormErrorEvent(form, error));
    }
    /**
     * @param {?} outcome
     * @return {?}
     */
    onExecuteOutcome(outcome) {
        let /** @type {?} */ args = new FormOutcomeEvent(outcome);
        this.formService.executeOutcome.next(args);
        if (args.defaultPrevented) {
            return false;
        }
        this.executeOutcome.emit(args);
        if (args.defaultPrevented) {
            return false;
        }
        return true;
    }
}
FormComponent.SAVE_OUTCOME_ID = '$save';
FormComponent.COMPLETE_OUTCOME_ID = '$complete';
FormComponent.START_PROCESS_OUTCOME_ID = '$startProcess';
FormComponent.CUSTOM_OUTCOME_ID = '$custom';
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form',
                template: `
      <div *ngIf="!hasForm()">
          <ng-content select="[empty-form]">
          </ng-content>
      </div>
      <div *ngIf="hasForm()" class="{{form.className}}">
          <mat-card>
              <mat-card-header>
                  <mat-card-title>
                      <h4 *ngIf="isTitleEnabled()">
                          <div *ngIf="showRefreshButton" class="adf-form-reload-button">
                              <button mat-icon-button (click)="onRefreshClicked()">
                                  <mat-icon>refresh</mat-icon>
                              </button>
                          </div>
                          <mat-icon>{{ form.isValid ? 'event_available' : 'event_busy' }}</mat-icon>
                          <span>{{form.taskName}}</span>

                      </h4>
                  </mat-card-title>
              </mat-card-header>
              <mat-card-content>
                  <div *ngIf="form.hasTabs()">
                      <tabs-widget [tabs]="form.tabs" (formTabChanged)="checkVisibility($event);"></tabs-widget>
                  </div>

                  <div *ngIf="!form.hasTabs() && form.hasFields()">
                      <div *ngFor="let field of form.fields">
                          <form-field [field]="field.field"></form-field>
                      </div>
                  </div>
              </mat-card-content>
              <mat-card-actions *ngIf="form.hasOutcomes()">
                  <!--[class.mdl-button--colored]="!outcome.isSystem"-->
                  <button *ngFor="let outcome of form.outcomes"
                          mat-button
                          [disabled]="!isOutcomeButtonEnabled(outcome)"
                          [class.adf-form-hide-button]="!isOutcomeButtonVisible(outcome, form.readOnly)"
                          (click)="onOutcomeClicked(outcome, $event)">
                      {{outcome.name | uppercase}}
                  </button>
              </mat-card-actions>
          </mat-card>
      </div>
      <!--
      For debugging and data visualisation purposes,
      will be removed during future revisions
      -->
      <div *ngIf="showDebugButton" class="adf-form-debug-container">
          <mat-slide-toggle [(ngModel)]="debugMode">Debug mode</mat-slide-toggle>
          <div *ngIf="debugMode && hasForm()">
              <h4>Values</h4>
              <pre>{{form.values | json}}</pre>

              <h4>Form</h4>
              <pre>{{form.json | json}}</pre>
          </div>
      </div>
    `,
                styles: [`
      .adf-form-container {
        width: 100%;
        min-height: 100px;
        overflow: visible; }

      .adf-form-debug-container {
        padding: 10px; }

      .adf-form-debug-container .debug-toggle-text {
        padding-left: 15px;
        cursor: pointer; }

      .adf-form-debug-container .debug-toggle-text:hover {
        font-weight: bold; }

      .adf-form-reload-button {
        position: absolute;
        right: 0;
        top: 0; }

      .adf-form-hide-button {
        display: none; }

      .adf-task-title {
        text-align: center; }

      form-field {
        width: 100%; }
        form-field .mat-input-element {
          font-size: 14px;
          padding-top: 8px;
          line-height: normal; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
FormComponent.ctorParameters = () => [
    { type: FormService, },
    { type: WidgetVisibilityService, },
    { type: EcmModelService, },
    { type: NodeService, },
];
FormComponent.propDecorators = {
    'form': [{ type: Input },],
    'taskId': [{ type: Input },],
    'nodeId': [{ type: Input },],
    'formId': [{ type: Input },],
    'formName': [{ type: Input },],
    'saveMetadata': [{ type: Input },],
    'data': [{ type: Input },],
    'path': [{ type: Input },],
    'nameNode': [{ type: Input },],
    'showTitle': [{ type: Input },],
    'showCompleteButton': [{ type: Input },],
    'disableCompleteButton': [{ type: Input },],
    'disableStartProcessButton': [{ type: Input },],
    'showSaveButton': [{ type: Input },],
    'showDebugButton': [{ type: Input },],
    'readOnly': [{ type: Input },],
    'showRefreshButton': [{ type: Input },],
    'showValidationIcon': [{ type: Input },],
    'fieldValidators': [{ type: Input },],
    'formSaved': [{ type: Output },],
    'formCompleted': [{ type: Output },],
    'formContentClicked': [{ type: Output },],
    'formLoaded': [{ type: Output },],
    'formDataRefreshed': [{ type: Output },],
    'executeOutcome': [{ type: Output },],
    'onError': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Displays the start form for a named process definition, which can be used to retrieve values to start a new process.
 *
 * After the form has been completed the form values are available from the attribute component.form.values and
 * component.form.isValid (boolean) can be used to check the if the form is valid or not. Both of these properties are
 * updated as the user types into the form.
 *
 * \@Input
 * {processDefinitionId} string: The process definition ID
 * {showOutcomeButtons} boolean: Whether form outcome buttons should be shown, this is now always active to show form outcomes
 *  \@Output
 *  {formLoaded} EventEmitter - This event is fired when the form is loaded, it pass all the value in the form.
 *  {formSaved} EventEmitter - This event is fired when the form is saved, it pass all the value in the form.
 *  {formCompleted} EventEmitter - This event is fired when the form is completed, it pass all the value in the form.
 *
 */
class StartFormComponent extends FormComponent {
    /**
     * @param {?} formService
     * @param {?} visibilityService
     * @param {?} logService
     */
    constructor(formService, visibilityService, logService) {
        super(formService, visibilityService, null, null);
        this.showOutcomeButtons = true;
        this.showRefreshButton = true;
        this.readOnlyForm = false;
        this.outcomeClick = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.outcomesContainer = null;
        this.showTitle = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.formService.formContentClicked.subscribe((content) => {
            this.formContentClicked.emit(content);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ processDefinitionId = changes['processDefinitionId'];
        if (processDefinitionId && processDefinitionId.currentValue) {
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(processDefinitionId.currentValue);
            return;
        }
        let /** @type {?} */ processId = changes['processId'];
        if (processId && processId.currentValue) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(processId.currentValue);
            return;
        }
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    loadStartForm(processId) {
        this.formService.getProcessIntance(processId)
            .subscribe((intance) => {
            this.formService
                .getStartFormInstance(processId)
                .subscribe(form => {
                this.formName = form.name;
                if (intance.variables) {
                    form.processVariables = intance.variables;
                }
                this.form = this.parseForm(form);
                this.form.readOnly = this.readOnlyForm;
                this.onFormLoaded(this.form);
            }, error => this.handleError(error));
        });
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    getStartFormDefinition(processId) {
        this.formService
            .getStartFormDefinition(processId)
            .subscribe(form => {
            this.formName = form.processDefinitionName;
            this.form = this.parseForm(form);
            this.form.readOnly = this.readOnlyForm;
            this.onFormLoaded(this.form);
        }, error => this.handleError(error));
    }
    /**
     * @override
     * @param {?} outcome
     * @param {?} isFormReadOnly
     * @return {?}
     */
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.isSystem && (outcome.name === FormOutcomeModel.SAVE_ACTION ||
            outcome.name === FormOutcomeModel.COMPLETE_ACTION)) {
            return false;
        }
        else if (outcome && outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
            return true;
        }
        return super.isOutcomeButtonVisible(outcome, isFormReadOnly);
    }
    /**
     * @override
     * @return {?}
     */
    saveTaskForm() {
        // do nothing
    }
    /**
     * @override
     * @return {?}
     */
    onRefreshClicked() {
        if (this.processDefinitionId) {
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(this.processDefinitionId);
        }
        else if (this.processId) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(this.processId);
        }
    }
    /**
     * @param {?=} outcome
     * @return {?}
     */
    completeTaskForm(outcome) {
        this.outcomeClick.emit(outcome);
    }
}
StartFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-form',
                template: `
      <div class="adf-start-form-container" *ngIf="hasForm()">
          <mat-card>
              <mat-card-header>
                  <mat-card-title>
                      <h2 *ngIf="isTitleEnabled()" class="mdl-card__title-text">{{form.taskName}}</h2>
                  </mat-card-title>
              </mat-card-header>
              <mat-card-content>
                  <div *ngIf="form.hasTabs()">
                      <tabs-widget [tabs]="form.tabs" (formTabChanged)="checkVisibility($event);"></tabs-widget>
                  </div>

                  <div *ngIf="!form.hasTabs() && form.hasFields()">
                      <div *ngFor="let field of form.fields">
                          <form-field [field]="field.field"></form-field>
                      </div>
                  </div>
              </mat-card-content>
              <mat-card-content class="adf-start-form-actions" *ngIf="showOutcomeButtons && form.hasOutcomes()" #outcomesContainer>
                   <ng-content select="[form-custom-button]"></ng-content>
                  <button *ngFor="let outcome of form.outcomes"
                          mat-button
                          [disabled]="!isOutcomeButtonEnabled(outcome)"
                          [class.mdl-button--colored]="!outcome.isSystem"
                          [class.adf-form-hide-button]="!isOutcomeButtonVisible(outcome, form.readOnly)"
                          (click)="onOutcomeClicked(outcome, $event)">
                      {{outcome.name}}
                  </button>
              </mat-card-content>
              <mat-card-actions *ngIf="showRefreshButton">
                  <button mat-button
                          (click)="onRefreshClicked()">
                      <mat-icon>refresh</mat-icon>
                  </button>
              </mat-card-actions>
          </mat-card>
      </div>
    `,
                styles: [`
      .adf-form-container {
        width: 100%;
        min-height: 100px;
        overflow: visible; }

      .adf-form-debug-container {
        padding: 10px; }

      .adf-form-debug-container .debug-toggle-text {
        padding-left: 15px;
        cursor: pointer; }

      .adf-form-debug-container .debug-toggle-text:hover {
        font-weight: bold; }

      .adf-form-reload-button {
        position: absolute;
        right: 0;
        top: 0; }

      .adf-form-hide-button {
        display: none; }

      .adf-task-title {
        text-align: center; }

      form-field {
        width: 100%; }
        form-field .mat-input-element {
          font-size: 14px;
          padding-top: 8px;
          line-height: normal; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
StartFormComponent.ctorParameters = () => [
    { type: FormService, },
    { type: WidgetVisibilityService, },
    { type: LogService, },
];
StartFormComponent.propDecorators = {
    'processDefinitionId': [{ type: Input },],
    'processId': [{ type: Input },],
    'showOutcomeButtons': [{ type: Input },],
    'showRefreshButton': [{ type: Input },],
    'readOnlyForm': [{ type: Input },],
    'outcomeClick': [{ type: Output },],
    'formContentClicked': [{ type: Output },],
    'outcomesContainer': [{ type: ViewChild, args: ['outcomesContainer', {},] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentWidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     * @param {?} contentService
     * @param {?} processContentService
     */
    constructor(formService, logService, contentService, processContentService) {
        this.formService = formService;
        this.logService = logService;
        this.contentService = contentService;
        this.processContentService = processContentService;
        this.showDocumentContent = true;
        this.contentClick = new EventEmitter();
        this.thumbnailLoaded = new EventEmitter();
        this.contentLoaded = new EventEmitter();
        this.error = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ contentId = changes['id'];
        if (contentId && contentId.currentValue) {
            this.loadContent(contentId.currentValue);
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    loadContent(id) {
        this.processContentService
            .getFileContent(id)
            .subscribe((response) => {
            this.content = new ContentLinkModel(response);
            this.contentLoaded.emit(this.content);
            this.loadThumbnailUrl(this.content);
        }, (error) => {
            this.error.emit(error);
        });
    }
    /**
     * @param {?} content
     * @return {?}
     */
    loadThumbnailUrl(content) {
        if (this.content.isThumbnailSupported()) {
            let /** @type {?} */ observable;
            if (this.content.isTypeImage()) {
                observable = this.processContentService.getFileRawContent(content.id);
            }
            else {
                observable = this.processContentService.getContentThumbnail(content.id);
            }
            if (observable) {
                observable.subscribe((response) => {
                    this.content.thumbnailUrl = this.contentService.createTrustedUrl(response);
                    this.thumbnailLoaded.emit(this.content.thumbnailUrl);
                }, (error) => {
                    this.error.emit(error);
                });
            }
        }
    }
    /**
     * @param {?} content
     * @return {?}
     */
    openViewer(content) {
        let /** @type {?} */ fetch = this.processContentService.getContentPreview(content.id);
        if (content.isTypeImage() || content.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(content.id);
        }
        fetch.subscribe((blob) => {
            content.contentBlob = blob;
            this.contentClick.emit(content);
            this.logService.info('Content clicked' + content.id);
            this.formService.formContentClicked.next(content);
        }, (error) => {
            this.error.emit(error);
        });
    }
    /**
     * Invoke content download.
     * @param {?} content
     * @return {?}
     */
    download(content) {
        this.processContentService.getFileRawContent(content.id).subscribe((blob) => this.contentService.downloadBlob(blob, content.name), (error) => {
            this.error.emit(error);
        });
    }
}
ContentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content',
                template: `
      <mat-card class="adf-content-container" *ngIf="content">
          <mat-card-content *ngIf="showDocumentContent">
              <div *ngIf="content.isThumbnailSupported()" >
                  <img id="thumbnailPreview" class="adf-img-upload-widget" [src]="content.thumbnailUrl" alt="{{content.name}}">
              </div>
              <div *ngIf="!content.isThumbnailSupported()">
                  <mat-icon>image</mat-icon>
                  <div id="unsupported-thumbnail" class="adf-content-widget-preview-text">{{ 'FORM.PREVIEW.IMAGE_NOT_AVAILABLE' | translate }}
                  </div>
              </div>
              <div class="mdl-card__supporting-text upload-widget__content-text">{{content.name}}</div>
          </mat-card-content>

          <mat-card-actions>
              <button mat-icon-button id="view" (click)="openViewer(content)">
                  <mat-icon class="mat-24">zoom_in</mat-icon>
              </button>
              <button mat-icon-button id="download" (click)="download(content)">
                  <mat-icon class="mat-24">file_download</mat-icon>
              </button>
          </mat-card-actions>
      </mat-card>
    `,
                styles: [`
      .adf-img-upload-widget {
        width: 100%;
        height: 100%;
        border: 1px solid rgba(117, 117, 117, 0.57);
        -webkit-box-shadow: 1px 1px 2px #dddddd;
                box-shadow: 1px 1px 2px #dddddd;
        background-color: #ffffff; }

      .adf-content-widget-preview-text {
        word-wrap: break-word;
        word-break: break-all;
        text-align: center; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
ContentWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
    { type: ContentService, },
    { type: ProcessContentService, },
];
ContentWidgetComponent.propDecorators = {
    'id': [{ type: Input },],
    'showDocumentContent': [{ type: Input },],
    'contentClick': [{ type: Output },],
    'thumbnailLoaded': [{ type: Output },],
    'contentLoaded': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormModule {
}
FormModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    DataTableModule,
                    HttpModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DataColumnModule,
                    PipeModule
                ],
                declarations: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormComponent,
                    FormListComponent,
                    StartFormComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES,
                    ...MASK_DIRECTIVE,
                    WidgetComponent
                ],
                entryComponents: [
                    ...WIDGET_DIRECTIVES
                ],
                providers: [
                    ActivitiContentService,
                    EcmModelService,
                    FormRenderingService,
                    FormService,
                    NodeService,
                    ProcessContentService,
                    WidgetVisibilityService
                ],
                exports: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormComponent,
                    FormListComponent,
                    StartFormComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES
                ]
            },] },
];
/**
 * @nocollapse
 */
FormModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppsProcessService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @return {?}
     */
    getDeployedApplications() {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .map((response) => {
            return response.data;
        })
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} name
     * @return {?}
     */
    getDeployedApplicationsByName(name) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .map((response) => {
            return response.data.find(app => app.name === name);
        })
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} appId
     * @return {?}
     */
    getApplicationDetailsById(appId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .map((response) => {
            return response.data.find(app => app.id === appId);
        })
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
AppsProcessService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AppsProcessService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthGuardBpm {
    /**
     * @param {?} authService
     * @param {?} router
     */
    constructor(authService, router$$1) {
        this.authService = authService;
        this.router = router$$1;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state$$1) {
        return this.checkLogin(state$$1.url);
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivateChild(route, state$$1) {
        return this.canActivate(route, state$$1);
    }
    /**
     * @param {?} redirectUrl
     * @return {?}
     */
    checkLogin(redirectUrl) {
        if (this.authService.isBpmLoggedIn()) {
            return true;
        }
        this.authService.setRedirectUrl(redirectUrl);
        this.router.navigate(['/login']);
        return false;
    }
}
AuthGuardBpm.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AuthGuardBpm.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: Router, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthGuardEcm {
    /**
     * @param {?} authService
     * @param {?} apiService
     * @param {?} router
     */
    constructor(authService, apiService, router$$1) {
        this.authService = authService;
        this.apiService = apiService;
        this.router = router$$1;
    }
    /**
     * @return {?}
     */
    get authApi() {
        return this.apiService.getInstance().ecmAuth;
    }
    /**
     * @return {?}
     */
    isLoggedIn() {
        if (!this.authApi.isLoggedIn()) {
            return Promise.resolve(false);
        }
        return this.authApi
            .validateTicket()
            .then(() => true, () => false)
            .catch(() => false);
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivateChild(route, state$$1) {
        return this.canActivate(route, state$$1);
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state$$1) {
        return this.isLoggedIn().then(isLoggedIn => {
            if (!isLoggedIn) {
                this.authService.setRedirectUrl(state$$1.url);
                this.router.navigate(['/login']);
            }
            return isLoggedIn;
        });
    }
}
AuthGuardEcm.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AuthGuardEcm.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: AlfrescoApiService, },
    { type: Router, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthGuard {
    /**
     * @param {?} authService
     * @param {?} router
     */
    constructor(authService, router$$1) {
        this.authService = authService;
        this.router = router$$1;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state$$1) {
        const /** @type {?} */ redirectUrl = state$$1.url;
        return this.checkLogin(redirectUrl);
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivateChild(route, state$$1) {
        return this.canActivate(route, state$$1);
    }
    /**
     * @param {?} redirectUrl
     * @return {?}
     */
    checkLogin(redirectUrl) {
        if (this.authService.isLoggedIn()) {
            return true;
        }
        this.authService.setRedirectUrl(redirectUrl);
        this.router.navigate(['/login']);
        return false;
    }
}
AuthGuard.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AuthGuard.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: Router, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentProcessModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id;
            this.message = obj.message;
            this.created = obj.created;
            this.createdBy = obj.createdBy;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserProcessModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.pictureId = null;
        if (obj) {
            this.id = obj.id;
            this.email = obj.email || null;
            this.firstName = obj.firstName || null;
            this.lastName = obj.lastName || null;
            this.pictureId = obj.pictureId || null;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentProcessService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @param {?} taskId
     * @param {?} message
     * @return {?}
     */
    addTaskComment(taskId, message) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.addTaskComment({ message: message }, taskId))
            .map(res => res)
            .map((response) => {
            return new CommentProcessModel({ id: response.id, message: response.message, created: response.created, createdBy: response.createdBy });
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getTaskComments(taskId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.getTaskComments(taskId))
            .map(res => res)
            .map((response) => {
            let /** @type {?} */ comments = [];
            response.data.forEach((comment) => {
                let /** @type {?} */ user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentProcessModel({ id: comment.id, message: comment.message, created: comment.created, createdBy: user }));
            });
            return comments;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getProcessInstanceComments(processInstanceId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.commentsApi.getProcessInstanceComments(processInstanceId))
            .map(res => res)
            .map((response) => {
            let /** @type {?} */ comments = [];
            response.data.forEach((comment) => {
                let /** @type {?} */ user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentProcessModel({ id: comment.id, message: comment.message, created: comment.created, createdBy: user }));
            });
            return comments;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} processInstanceId
     * @param {?} message
     * @return {?}
     */
    addProcessInstanceComment(processInstanceId, message) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.commentsApi.addProcessInstanceComment({ message: message }, processInstanceId))
            .map((response) => {
            return new CommentProcessModel({ id: response.id, message: response.message, created: response.created, createdBy: response.createdBy });
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
CommentProcessService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
CommentProcessService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DeletedNodesApiService {
    /**
     * @param {?} apiService
     * @param {?} preferences
     */
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    /**
     * @return {?}
     */
    get nodesApi() {
        return this.apiService.getInstance().core.nodesApi;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    getDeletedNodes(options) {
        const { nodesApi, handleError } = this;
        const /** @type {?} */ defaultOptions = {
            include: ['path', 'properties'],
            maxItems: this.preferences.paginationSize,
            skipCount: 0
        };
        const /** @type {?} */ queryOptions = Object.assign(defaultOptions, options);
        const /** @type {?} */ promise = nodesApi.getDeletedNodes(queryOptions);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.of(error);
    }
}
DeletedNodesApiService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DeletedNodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

class BpmProductVersionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.edition = obj.edition || null;
            this.majorVersion = obj.majorVersion || null;
            this.revisionVersion = obj.revisionVersion || null;
            this.minorVersion = obj.minorVersion || null;
            this.type = obj.type || null;
        }
    }
}
class EcmProductVersionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.modules = [];
        if (obj && obj.entry && obj.entry.repository) {
            this.edition = obj.entry.repository.edition || null;
            this.version = new VersionModel(obj.entry.repository.version);
            this.license = new LicenseModel(obj.entry.repository.license);
            this.status = new VersionStatusModel(obj.entry.repository.status);
            if (obj.entry.repository.modules) {
                obj.entry.repository.modules.forEach((module) => {
                    this.modules.push(new VersionModuleModel(module));
                });
            }
        }
    }
}
class VersionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.major = obj.major || null;
            this.minor = obj.minor || null;
            this.patch = obj.patch || null;
            this.hotfix = obj.hotfix || null;
            this.schema = obj.schema || null;
            this.label = obj.label || null;
            this.display = obj.display || null;
        }
    }
}
class LicenseModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.issuedAt = obj.issuedAt || null;
            this.expiresAt = obj.expiresAt || null;
            this.remainingDays = obj.remainingDays || null;
            this.holder = obj.holder || null;
            this.mode = obj.mode || null;
            this.isClusterEnabled = obj.isClusterEnabled ? true : false;
            this.isCryptodocEnabled = obj.isCryptodocEnabled ? true : false;
        }
    }
}
class VersionStatusModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.isReadOnly = obj.isReadOnly ? true : false;
            this.isAuditEnabled = obj.isAuditEnabled ? true : false;
            this.isQuickShareEnabled = obj.isQuickShareEnabled ? true : false;
            this.isThumbnailGenerationEnabled = obj.isThumbnailGenerationEnabled ? true : false;
        }
    }
}
class VersionModuleModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.title = obj.title || null;
            this.description = obj.description || null;
            this.version = obj.version || null;
            this.installDate = obj.installDate || null;
            this.installState = obj.installState || null;
            this.versionMin = obj.versionMin || null;
            this.versionMax = obj.versionMax || null;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiscoveryApiService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * @return {?}
     */
    getEcmProductInfo() {
        return Observable$1.fromPromise(this.apiService.getInstance().discovery.discoveryApi.getRepositoryInformation())
            .map(res => new EcmProductVersionModel(res))
            .catch(this.handleError);
    }
    /**
     * @return {?}
     */
    getBpmProductInfo() {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.aboutApi.getAppVersion())
            .map(res => new BpmProductVersionModel(res))
            .catch(this.handleError);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.throw(error);
    }
}
DiscoveryApiService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DiscoveryApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FavoritesApiService {
    /**
     * @param {?} apiService
     * @param {?} preferences
     */
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    static remapFavoritesData(data = {}) {
        const /** @type {?} */ list = (data.list || {});
        const /** @type {?} */ pagination = (list.pagination || {});
        const /** @type {?} */ entries = FavoritesApiService
            .remapFavoriteEntries(list.entries || []);
        return /** @type {?} */ ({
            list: { entries, pagination }
        });
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    static remapEntry({ entry }) {
        entry.properties = {
            'cm:title': entry.title,
            'cm:description': entry.description
        };
        return { entry };
    }
    /**
     * @param {?} entries
     * @return {?}
     */
    static remapFavoriteEntries(entries) {
        return entries
            .map(({ entry: { target } }) => ({
            entry: target.file || target.folder
        }))
            .filter(({ entry }) => (!!entry))
            .map(FavoritesApiService.remapEntry);
    }
    /**
     * @return {?}
     */
    get favoritesApi() {
        return this.apiService.getInstance().core.favoritesApi;
    }
    /**
     * @param {?} personId
     * @param {?=} options
     * @return {?}
     */
    getFavorites(personId, options) {
        const { favoritesApi, handleError } = this;
        const /** @type {?} */ defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: ['properties', 'allowableOperations']
        };
        const /** @type {?} */ queryOptions = Object.assign(defaultOptions, options);
        const /** @type {?} */ promise = favoritesApi
            .getFavorites(personId, queryOptions)
            .then(FavoritesApiService.remapFavoritesData);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.of(error);
    }
}
FavoritesApiService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
FavoritesApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodesApiService {
    /**
     * @param {?} api
     * @param {?} preferences
     */
    constructor(api, preferences) {
        this.api = api;
        this.preferences = preferences;
    }
    /**
     * @return {?}
     */
    get nodesApi() {
        return this.api.getInstance().core.nodesApi;
    }
    /**
     * @param {?} entity
     * @return {?}
     */
    getEntryFromEntity(entity) {
        return entity.entry;
    }
    /**
     * @param {?} nodeId
     * @param {?=} options
     * @return {?}
     */
    getNode(nodeId, options = {}) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const /** @type {?} */ defaults = {
            include: ['path', 'properties', 'allowableOperations']
        };
        const /** @type {?} */ queryOptions = Object.assign(defaults, options);
        const /** @type {?} */ promise = nodesApi
            .getNode(nodeId, queryOptions)
            .then(getEntryFromEntity);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @param {?} nodeId
     * @param {?=} options
     * @return {?}
     */
    getNodeChildren(nodeId, options = {}) {
        const { nodesApi, handleError } = this;
        const /** @type {?} */ defaults = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['path', 'properties', 'allowableOperations']
        };
        const /** @type {?} */ queryOptions = Object.assign(defaults, options);
        const /** @type {?} */ promise = nodesApi
            .getNodeChildren(nodeId, queryOptions);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @param {?} parentNodeId
     * @param {?} nodeBody
     * @param {?=} options
     * @return {?}
     */
    createNode(parentNodeId, nodeBody, options = {}) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const /** @type {?} */ promise = nodesApi
            .addNode(parentNodeId, nodeBody, options)
            .then(getEntryFromEntity);
        return Observable$1.fromPromise(promise).catch(handleError);
    }
    /**
     * @param {?} parentNodeId
     * @param {?} nodeBody
     * @param {?=} options
     * @return {?}
     */
    createFolder(parentNodeId, nodeBody, options = {}) {
        const /** @type {?} */ body = Object.assign({ nodeType: 'cm:folder' }, nodeBody);
        return this.createNode(parentNodeId, body, options);
    }
    /**
     * @param {?} nodeId
     * @param {?} nodeBody
     * @param {?=} options
     * @return {?}
     */
    updateNode(nodeId, nodeBody, options = {}) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const /** @type {?} */ promise = nodesApi
            .updateNode(nodeId, nodeBody, options)
            .then(getEntryFromEntity);
        return Observable$1.fromPromise(promise).catch(handleError);
    }
    /**
     * @param {?} nodeId
     * @param {?=} options
     * @return {?}
     */
    deleteNode(nodeId, options = {}) {
        const { nodesApi, handleError } = this;
        const /** @type {?} */ promise = nodesApi
            .deleteNode(nodeId, options);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    restoreNode(nodeId) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const /** @type {?} */ promise = nodesApi
            .restoreNode(nodeId)
            .then(getEntryFromEntity);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.throw(error);
    }
}
NodesApiService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PageTitleService {
    /**
     * @param {?} titleService
     * @param {?} appConfig
     */
    constructor(titleService, appConfig) {
        this.titleService = titleService;
        this.appConfig = appConfig;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    setTitle(value = '') {
        const /** @type {?} */ name = this.appConfig.get('application.name') || 'Alfresco ADF Application';
        const /** @type {?} */ title = value ? `${value} - ${name}` : `${name}`;
        this.titleService.setTitle(title);
    }
}
PageTitleService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
PageTitleService.ctorParameters = () => [
    { type: Title, },
    { type: AppConfigService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleContentService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * @return {?}
     */
    get peopleApi() {
        return this.apiService.getInstance().core.peopleApi;
    }
    /**
     * @param {?} personId
     * @return {?}
     */
    getPerson(personId) {
        const { peopleApi, handleError } = this;
        const /** @type {?} */ promise = peopleApi.getPerson(personId);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @return {?}
     */
    getCurrentPerson() {
        return this.getPerson('-me-');
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.of(error);
    }
}
PeopleContentService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
PeopleContentService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal service used by Document List component.
 */
class SearchService {
    /**
     * @param {?} authService
     * @param {?} apiService
     */
    constructor(authService, apiService) {
        this.authService = authService;
        this.apiService = apiService;
    }
    /**
     * @param {?} term
     * @param {?=} options
     * @return {?}
     */
    getNodeQueryResults(term, options) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.queriesApi.findNodes(term, options))
            .map(res => /** @type {?} */ (res))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} query
     * @return {?}
     */
    search(query) {
        const /** @type {?} */ searchQuery = Object.assign(query);
        const /** @type {?} */ promise = this.apiService.getInstance().search.searchApi.search(searchQuery);
        return Observable$1
            .fromPromise(promise)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.throw(error || 'Server error');
    }
}
SearchService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SearchService.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SharedLinksApiService {
    /**
     * @param {?} apiService
     * @param {?} preferences
     */
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    /**
     * @return {?}
     */
    get sharedLinksApi() {
        return this.apiService.getInstance().core.sharedlinksApi;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    getSharedLinks(options = {}) {
        const { sharedLinksApi, handleError } = this;
        const /** @type {?} */ defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['properties', 'allowableOperations']
        };
        const /** @type {?} */ queryOptions = Object.assign({}, defaultOptions, options);
        const /** @type {?} */ promise = sharedLinksApi
            .findSharedLinks(queryOptions);
        return Observable$1
            .fromPromise(promise)
            .catch(handleError);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.of(error);
    }
}
SharedLinksApiService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SharedLinksApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SiteContentsModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.folderId = obj.folderId || null;
        }
    }
}
class SiteMembersModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.emailNotificationsEnabled = false;
        this.enable = false;
        if (obj) {
            this.role = obj.role;
            this.firstName = obj.firstName || null;
            this.emailNotificationsEnabled = obj.emailNotificationsEnabled;
            this.company = obj.company || null;
            this.id = obj.id || null;
            this.enable = obj.enable;
            this.email = obj.email;
        }
    }
}
class SiteModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.contents = [];
        this.members = [];
        if (obj && obj.entry) {
            this.role = obj.entry.role || null;
            this.visibility = obj.entry.visibility || null;
            this.guid = obj.entry.guid || null;
            this.description = obj.entry.description || null;
            this.id = obj.entry.id || null;
            this.preset = obj.entry.preset;
            this.title = obj.entry.title;
            this.pagination = obj.pagination || null;
            if (obj.relations && obj.relations.containers) {
                obj.relations.containers.list.entries.forEach((content) => {
                    this.contents.push(new SiteContentsModel(content.entry));
                });
            }
            if (obj.relations && obj.relations.members) {
                obj.relations.members.list.entries.forEach((member) => {
                    this.members.push(new SiteMembersModel(member.entry));
                });
            }
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SitesService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * @param {?=} opts
     * @return {?}
     */
    getSites(opts = {}) {
        const /** @type {?} */ defaultOptions = {
            skipCount: 0,
            include: ['properties']
        };
        const /** @type {?} */ queryOptions = Object.assign({}, defaultOptions, opts);
        return Observable$1.fromPromise(this.apiService.getInstance().core.sitesApi.getSites(queryOptions))
            .map((res) => this.convertToModel(res))
            .catch(this.handleError);
    }
    /**
     * @param {?} siteId
     * @param {?=} opts
     * @return {?}
     */
    getSite(siteId, opts) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.sitesApi.getSite(siteId, opts))
            .map((res) => new SiteModel(res))
            .catch(this.handleError);
    }
    /**
     * @param {?} siteId
     * @param {?=} permanentFlag
     * @return {?}
     */
    deleteSite(siteId, permanentFlag = true) {
        let /** @type {?} */ options = {};
        options.permanent = permanentFlag;
        return Observable$1.fromPromise(this.apiService.getInstance().core.sitesApi.deleteSite(siteId, options)
            .catch(this.handleError));
    }
    /**
     * @param {?} siteId
     * @return {?}
     */
    getSiteContent(siteId) {
        return this.getSite(siteId, { relations: ['containers'] });
    }
    /**
     * @param {?} siteId
     * @return {?}
     */
    getSiteMembers(siteId) {
        return this.getSite(siteId, { relations: ['members'] });
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error(error);
        return Observable$1.throw(error || 'Server error');
    }
    /**
     * @param {?} response
     * @return {?}
     */
    convertToModel(response) {
        let /** @type {?} */ convertedList = [];
        if (response &&
            response.list &&
            response.list.entries &&
            response.list.entries.length > 0) {
            response.list.entries.forEach((element) => {
                element.pagination = response.list.pagination;
                convertedList.push(new SiteModel(element));
            });
        }
        return convertedList;
    }
}
SitesService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SitesService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class ComponentTranslationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.name = obj && obj.name;
        this.path = obj && obj.path;
        this.json = obj && obj.json || [];
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TranslateLoaderService {
    /**
     * @param {?} http
     * @param {?} logService
     */
    constructor(http$$1, logService) {
        this.http = http$$1;
        this.logService = logService;
        this.prefix = 'i18n';
        this.suffix = '.json';
        this.providers = [];
        this.queue = [];
    }
    /**
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    registerProvider(name, path) {
        let /** @type {?} */ registered = this.providers.find(provider => provider.name === name);
        if (registered) {
            registered.path = path;
        }
        else {
            this.providers.push(new ComponentTranslationModel({ name: name, path: path }));
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    providerRegistered(name) {
        return this.providers.find(x => x.name === name) ? true : false;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getComponentToFetch(lang) {
        let /** @type {?} */ observableBatch = [];
        if (!this.queue[lang]) {
            this.queue[lang] = [];
        }
        this.providers.forEach((component) => {
            if (!this.isComponentInQueue(lang, component.name)) {
                this.queue[lang].push(component.name);
                let /** @type {?} */ currentObserv = Observable$1.create(observer => {
                    this.http.get(`${component.path}/${this.prefix}/${lang}${this.suffix}`)
                        .map((res) => {
                        component.json[lang] = res;
                    }).subscribe((result) => {
                        observer.next(result);
                        observer.complete();
                    }, () => {
                        observer.next('');
                        observer.complete();
                    });
                });
                observableBatch.push(currentObserv);
            }
        });
        return observableBatch;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    init(lang) {
        if (this.queue[lang] === undefined) {
            this.queue[lang] = [];
        }
    }
    /**
     * @param {?} lang
     * @param {?} name
     * @return {?}
     */
    isComponentInQueue(lang, name) {
        return (this.queue[lang] || []).find(x => x === name) ? true : false;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getFullTranslationJSON(lang) {
        let /** @type {?} */ result = {};
        this.providers
            .slice(0)
            .sort((a, b) => {
            if (a.name === 'app') {
                return 1;
            }
            if (b.name === 'app') {
                return -1;
            }
            return a.name.localeCompare(b.name);
        })
            .forEach(model => {
            if (model.json && model.json[lang]) {
                result = ObjectUtils.merge(result, model.json[lang]);
            }
        });
        return result;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getTranslation(lang) {
        let /** @type {?} */ observableBatch = this.getComponentToFetch(lang);
        return Observable$1.create(observer => {
            if (observableBatch.length > 0) {
                Observable$1.forkJoin(observableBatch).subscribe(() => {
                    let /** @type {?} */ fullTranslation = this.getFullTranslationJSON(lang);
                    if (fullTranslation) {
                        observer.next(fullTranslation);
                    }
                    observer.complete();
                }, (err) => {
                    this.logService.error(err);
                });
            }
            else {
                let /** @type {?} */ fullTranslation = this.getFullTranslationJSON(lang);
                if (fullTranslation) {
                    observer.next(fullTranslation);
                }
            }
        });
    }
}
TranslateLoaderService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
TranslateLoaderService.ctorParameters = () => [
    { type: HttpClient, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let minimatch = minimatch___default || minimatch_;
class UploadService {
    /**
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(apiService, appConfigService) {
        this.apiService = apiService;
        this.appConfigService = appConfigService;
        this.queue = [];
        this.cache = {};
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
        this.activeTask = null;
        this.excludedFileList = [];
        this.queueChanged = new Subject$1();
        this.fileUpload = new Subject$1();
        this.fileUploadStarting = new Subject$1();
        this.fileUploadCancelled = new Subject$1();
        this.fileUploadProgress = new Subject$1();
        this.fileUploadAborted = new Subject$1();
        this.fileUploadError = new Subject$1();
        this.fileUploadComplete = new Subject$1();
        this.fileUploadDeleted = new Subject$1();
        this.fileDeleted = new Subject$1();
        this.excludedFileList = this.appConfigService.get('files.excluded');
    }
    /**
     * Checks whether the service is uploading a file.
     *
     *
     * \@memberof UploadService
     * @return {?}
     */
    isUploading() {
        return this.activeTask ? true : false;
    }
    /**
     * Returns the file Queue
     *
     * @return {?}
     */
    getQueue() {
        return this.queue;
    }
    /**
     * Add files to the uploading queue to be uploaded.
     *
     * Examples:
     *  addToQueue(file); // pass one file
     *  addToQueue(file1, file2, file3); // pass multiple files
     *  addToQueue(...[file1, file2, file3]); // pass an array of files
     * @param {...?} files
     * @return {?}
     */
    addToQueue(...files) {
        const /** @type {?} */ allowedFiles = files.filter(f => this.filterElement(f));
        this.queue = this.queue.concat(allowedFiles);
        this.queueChanged.next(this.queue);
        return allowedFiles;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    filterElement(file) {
        let /** @type {?} */ isAllowed = true;
        if (this.excludedFileList) {
            isAllowed = this.excludedFileList.filter(expr => minimatch(file.name, expr)).length === 0;
        }
        return isAllowed;
    }
    /**
     * Pick all the files in the queue that are not been uploaded yet and upload it into the directory folder.
     *
     *
     * \@memberof UploadService
     * @param {?} emitter
     * @return {?}
     */
    uploadFilesInTheQueue(emitter) {
        if (!this.activeTask) {
            let /** @type {?} */ file = this.queue.find(f => f.status === FileUploadStatus.Pending);
            if (file) {
                this.onUploadStarting(file);
                const /** @type {?} */ promise = this.beginUpload(file, emitter);
                this.activeTask = promise;
                this.cache[file.id] = promise;
                let /** @type {?} */ next = () => {
                    this.activeTask = null;
                    setTimeout(() => this.uploadFilesInTheQueue(emitter), 100);
                };
                promise.next = next;
                promise.then(() => next(), () => next());
            }
        }
    }
    /**
     * @param {...?} files
     * @return {?}
     */
    cancelUpload(...files) {
        files.forEach(file => {
            const /** @type {?} */ promise = this.cache[file.id];
            if (promise) {
                promise.abort();
                delete this.cache[file.id];
            }
            else {
                const /** @type {?} */ performAction = this.getAction(file);
                performAction();
            }
        });
    }
    /**
     * @return {?}
     */
    clearQueue() {
        this.queue = [];
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    getUploadPromise(file) {
        let /** @type {?} */ opts = {
            renditions: 'doclib'
        };
        if (file.options.newVersion === true) {
            opts.overwrite = true;
            opts.majorVersion = true;
        }
        else {
            opts.autoRename = true;
        }
        return this.apiService.getInstance().upload.uploadFile(file.file, file.options.path, file.options.parentId, null, opts);
    }
    /**
     * @param {?} file
     * @param {?} emitter
     * @return {?}
     */
    beginUpload(file, /* @deprecated */ emitter) {
        let /** @type {?} */ promise = this.getUploadPromise(file);
        promise.on('progress', (progress) => {
            this.onUploadProgress(file, progress);
        })
            .on('abort', () => {
            this.onUploadAborted(file);
            emitter.emit({ value: 'File aborted' });
        })
            .on('error', err => {
            this.onUploadError(file, err);
            emitter.emit({ value: 'Error file uploaded' });
        })
            .on('success', data => {
            this.onUploadComplete(file, data);
            emitter.emit({ value: data });
        })
            .catch(err => {
            throw err;
        });
        return promise;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onUploadStarting(file) {
        if (file) {
            file.status = FileUploadStatus.Starting;
            const /** @type {?} */ event = new FileUploadEvent(file, FileUploadStatus.Starting);
            this.fileUpload.next(event);
            this.fileUploadStarting.next(event);
        }
    }
    /**
     * @param {?} file
     * @param {?} progress
     * @return {?}
     */
    onUploadProgress(file, progress) {
        if (file) {
            file.progress = progress;
            file.status = FileUploadStatus.Progress;
            const /** @type {?} */ event = new FileUploadEvent(file, FileUploadStatus.Progress);
            this.fileUpload.next(event);
            this.fileUploadProgress.next(event);
        }
    }
    /**
     * @param {?} file
     * @param {?} error
     * @return {?}
     */
    onUploadError(file, error) {
        if (file) {
            file.status = FileUploadStatus.Error;
            this.totalError++;
            const /** @type {?} */ promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            const /** @type {?} */ event = new FileUploadErrorEvent(file, error, this.totalError);
            this.fileUpload.next(event);
            this.fileUploadError.next(event);
        }
    }
    /**
     * @param {?} file
     * @param {?} data
     * @return {?}
     */
    onUploadComplete(file, data) {
        if (file) {
            file.status = FileUploadStatus.Complete;
            file.data = data;
            this.totalComplete++;
            const /** @type {?} */ promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            const /** @type {?} */ event = new FileUploadCompleteEvent(file, this.totalComplete, data, this.totalAborted);
            this.fileUpload.next(event);
            this.fileUploadComplete.next(event);
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onUploadAborted(file) {
        if (file) {
            file.status = FileUploadStatus.Aborted;
            this.totalAborted++;
            const /** @type {?} */ promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            const /** @type {?} */ event = new FileUploadEvent(file, FileUploadStatus.Aborted);
            this.fileUpload.next(event);
            this.fileUploadAborted.next(event);
            promise.next();
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onUploadCancelled(file) {
        if (file) {
            file.status = FileUploadStatus.Cancelled;
            const /** @type {?} */ event = new FileUploadEvent(file, FileUploadStatus.Cancelled);
            this.fileUpload.next(event);
            this.fileUploadCancelled.next(event);
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onUploadDeleted(file) {
        if (file) {
            file.status = FileUploadStatus.Deleted;
            this.totalComplete--;
            const /** @type {?} */ event = new FileUploadDeleteEvent(file, this.totalComplete);
            this.fileUpload.next(event);
            this.fileUploadDeleted.next(event);
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    getAction(file) {
        const /** @type {?} */ actions = {
            [FileUploadStatus.Pending]: () => this.onUploadCancelled(file),
            [FileUploadStatus.Deleted]: () => this.onUploadDeleted(file),
            [FileUploadStatus.Error]: () => this.onUploadError(file, null)
        };
        return actions[file.status];
    }
}
UploadService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
UploadService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: AppConfigService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ServiceModule {
}
ServiceModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [],
                providers: [
                    AuthenticationService,
                    AlfrescoApiService,
                    SettingsService,
                    ContentService,
                    AuthGuard,
                    AuthGuardEcm,
                    AuthGuardBpm,
                    AppsProcessService,
                    PageTitleService,
                    StorageService,
                    CookieService,
                    RenditionsService,
                    NotificationService,
                    LogService,
                    TranslationService,
                    TranslateLoaderService,
                    ThumbnailService,
                    UploadService,
                    CardItemTypeService,
                    CardViewUpdateService,
                    UserPreferencesService,
                    HighlightTransformService,
                    DeletedNodesApiService,
                    FavoritesApiService,
                    NodesApiService,
                    PeopleContentService,
                    PeopleProcessService,
                    SearchService,
                    SharedLinksApiService,
                    SitesService,
                    DiscoveryApiService,
                    CommentProcessService
                ],
                exports: []
            },] },
];
/**
 * @nocollapse
 */
ServiceModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} http
 * @param {?} logService
 * @return {?}
 */
function createTranslateLoader(http$$1, logService) {
    return new TranslateLoaderService(http$$1, logService);
}
class CoreModule {
}
CoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ViewerModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    BrowserAnimationsModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    CollapsableModule,
                    ServiceModule,
                    FormModule,
                    TranslateModule.forRoot({
                        loader: {
                            provide: TranslateLoader,
                            useFactory: (createTranslateLoader),
                            deps: [HttpClient, LogService]
                        }
                    })
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: {
                            name: 'adf-core',
                            source: 'assets/adf-core'
                        }
                    },
                    TranslationService
                ],
                exports: [
                    AppConfigModule,
                    BrowserAnimationsModule,
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    TranslateModule,
                    ContextMenuModule,
                    CardViewModule,
                    CollapsableModule,
                    PaginationModule,
                    ToolbarModule,
                    LoginModule,
                    UserInfoModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    HostSettingsModule,
                    ServiceModule,
                    ViewerModule,
                    PipeModule,
                    DirectiveModule,
                    FormModule,
                    MaterialModule
                ]
            },] },
];
/**
 * @nocollapse
 */
CoreModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @abstract
 */
class CardViewBaseItemModel {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        this.label = obj.label || '';
        this.value = obj.value;
        this.key = obj.key;
        this.default = obj.default;
        this.editable = !!obj.editable;
        this.clickable = !!obj.clickable;
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.value === undefined || this.value === null || this.value === '';
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewTextItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        super(obj);
        this.type = 'text';
        this.multiline = !!obj.multiline;
        this.pipes = obj.pipes || [];
    }
    /**
     * @return {?}
     */
    get displayValue() {
        return this.applyPipes(this.value);
    }
    /**
     * @param {?} displayValue
     * @return {?}
     */
    applyPipes(displayValue) {
        if (this.pipes.length) {
            displayValue = this.pipes.reduce((accumulator, { pipe, params }) => {
                return pipe.transform(accumulator, ...params);
            }, displayValue);
        }
        return displayValue;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewMapItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        super(obj);
        this.type = 'map';
    }
    /**
     * @return {?}
     */
    get displayValue() {
        if (this.value && this.value.size > 0) {
            return this.value.values().next().value;
        }
        else {
            return this.default;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * This object represent the basic structure of a card view.
 *
 *
 * @returns {CardViewDateItemModel} .
 */
class CardViewDateItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        super(obj);
        this.type = 'date';
        this.format = obj.format || 'MMM DD YYYY';
    }
    /**
     * @return {?}
     */
    get displayValue() {
        if (!this.value) {
            return this.default;
        }
        else {
            return moment(this.value).format(this.format);
        }
    }
}

class PermissionsEnum extends String {
}
PermissionsEnum.DELETE = 'delete';
PermissionsEnum.UPDATE = 'update';
PermissionsEnum.CREATE = 'create';
PermissionsEnum.UPDATEPERMISSIONS = 'updatePermissions';
PermissionsEnum.NOT_DELETE = '!delete';
PermissionsEnum.NOT_UPDATE = '!update';
PermissionsEnum.NOT_CREATE = '!create';
PermissionsEnum.NOT_UPDATEPERMISSIONS = '!updatePermissions';

class EcmCompanyModel {
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AlfrescoApiMock {
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    login(username, password) {
        return new Promise((resolve) => {
            resolve('TICKET_4479f4d3bb155195879bfbb8d5206f433488a1b1');
        });
    }
    /**
     * @return {?}
     */
    logout() {
        return new Promise((resolve) => {
            resolve('logout');
        });
    }
    /**
     * @return {?}
     */
    changeConfig() {
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppConfigServiceMock extends AppConfigService {
    /**
     * @param {?} http
     */
    constructor(http$$1) {
        super(http$$1);
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent'
        };
    }
    /**
     * @return {?}
     */
    load() {
        return new Promise(resolve => {
            resolve(this.config);
        });
    }
}
AppConfigServiceMock.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AppConfigServiceMock.ctorParameters = () => [
    { type: HttpClient, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeApps = {
    size: 2, total: 2, start: 0,
    data: [
        {
            id: 1, defaultAppId: null, name: 'Sales-Fakes-App', description: 'desc-fake1', modelId: 22,
            theme: 'theme-1-fake', icon: 'glyphicon-asterisk', 'deploymentId': '111', 'tenantId': null
        },
        {
            id: 2, defaultAppId: null, name: 'health-care-Fake', description: 'desc-fake2', modelId: 33,
            theme: 'theme-2-fake', icon: 'glyphicon-asterisk', 'deploymentId': '444', 'tenantId': null
        }
    ]
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthenticationMock /*extends AuthenticationService*/ {
    constructor() {
        this.redirectUrl = '';
    }
    /**
     * @param {?} url
     * @return {?}
     */
    setRedirectUrl(url) {
        this.redirectUrl = url;
    }
    /**
     * @return {?}
     */
    getRedirectUrl() {
        return this.redirectUrl;
    }
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    login(username, password) {
        if (username === 'fake-username' && password === 'fake-password') {
            return Observable$1.of({ type: 'type', ticket: 'ticket' });
        }
        if (username === 'fake-username-CORS-error' && password === 'fake-password') {
            return Observable$1.throw({
                error: {
                    crossDomain: true,
                    message: 'ERROR: the network is offline, Origin is not allowed by Access-Control-Allow-Origin'
                }
            });
        }
        if (username === 'fake-username-CSRF-error' && password === 'fake-password') {
            return Observable$1.throw({ message: 'ERROR: Invalid CSRF-token', status: 403 });
        }
        if (username === 'fake-username-ECM-access-error' && password === 'fake-password') {
            return Observable$1.throw({ message: 'ERROR: 00170728 Access Denied.  The system is currently in read-only mode', status: 403 });
        }
        return Observable$1.throw('Fake server error');
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeBpmUserNoImage = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    fullname: 'fake-full-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: undefined,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};
let fakeBpmUser = {
    apps: [],
    capabilities: null,
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-bpm-first-name',
    lastName: 'fake-bpm-last-name',
    fullname: 'fake-bpm-full-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 12,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};
let fakeBpmEditedUser = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    fullname: 'fake-full-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 'src/assets/images/bpmImg.gif',
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeUser1 = { id: 1, email: 'fake-email@dom.com', firstName: 'firstName', lastName: 'lastName' };
let fakeUser2 = { id: 1001, email: 'some-one@somegroup.com', firstName: 'some', lastName: 'one' };
let fakeTasksComment = {
    size: 2, total: 2, start: 0,
    data: [
        {
            id: 1, message: 'fake-message-1', created: '', createdBy: fakeUser1
        },
        {
            id: 2, message: 'fake-message-2', created: '', createdBy: fakeUser1
        }
    ]
};
let fakeProcessComment = new CommentProcessModel({ id: 1, message: 'Test', created: new Date('2016-11-10T03:37:30.010+0000'), createdBy: new UserProcessModel({
        id: 13,
        firstName: 'Wilbur',
        lastName: 'Adams',
        email: 'wilbur@app.com'
    }) });

class CookieServiceMock {
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        return this[key] && this[key].data || null;
    }
    /**
     * @param {?} key
     * @param {?} data
     * @param {?} expiration
     * @param {?} path
     * @return {?}
     */
    setItem(key, data, expiration, path) {
        this[key] = { data, expiration, path };
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeEcmCompany = {
    organization: 'company-fake-name',
    address1: 'fake-address-1',
    address2: 'fake-address-2',
    address3: 'fake-address-3',
    postcode: 'fAk1',
    telephone: '00000000',
    fax: '11111111',
    email: 'fakeCompany@fake.com'
};
let fakeEcmUser = {
    id: 'fake-id',
    firstName: 'fake-ecm-first-name',
    lastName: 'fake-ecm-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'job-ecm-test',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
let fakeEcmUserNoImage = {
    id: 'fake-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: null,
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: null,
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
let fakeEcmEditedUser = {
    id: 'fake-id',
    firstName: null,
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'test job',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};

class EventMock {
    /**
     * @param {?} key
     * @return {?}
     */
    static keyDown(key) {
        let /** @type {?} */ event = document.createEvent('Event');
        event.keyCode = key;
        event.initEvent('keydown');
        document.dispatchEvent(event);
    }
    /**
     * @return {?}
     */
    static resizeMobileView() {
        // todo: no longer compiles with TS 2.0.2 as innerWidth/innerHeight are readonly fields
        /*
        window.innerWidth = 320;
        window.innerHeight = 568;
        */
        window.dispatchEvent(new Event('resize'));
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeRedition = {
    'entry': {
        'id': 'pdf',
        'content': { 'mimeType': 'application/pdf', 'mimeTypeName': 'Adobe PDF Document' },
        'status': 'NOT_CREATED'
    }
};
let fakeReditionCreated = {
    'entry': {
        'id': 'pdf',
        'content': { 'mimeType': 'application/pdf', 'mimeTypeName': 'Adobe PDF Document' },
        'status': 'CREATED'
    }
};
let fakeReditionsList = {
    'list': {
        'pagination': {
            'count': 6,
            'hasMoreItems': false,
            'totalItems': 6,
            'skipCount': 0,
            'maxItems': 100
        },
        'entries': [{
                'entry': {
                    'id': 'avatar',
                    'content': { 'mimeType': 'image/png', 'mimeTypeName': 'PNG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'avatar32',
                    'content': { 'mimeType': 'image/png', 'mimeTypeName': 'PNG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'doclib',
                    'content': { 'mimeType': 'image/png', 'mimeTypeName': 'PNG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'imgpreview',
                    'content': { 'mimeType': 'image/jpeg', 'mimeTypeName': 'JPEG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'medium',
                    'content': { 'mimeType': 'image/jpeg', 'mimeTypeName': 'JPEG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'pdf',
                    'content': { 'mimeType': 'application/pdf', 'mimeTypeName': 'Adobe PDF Document' },
                    'status': 'NOT_CREATED'
                }
            }]
    }
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeSearch = {
    list: {
        pagination: {
            count: 1,
            hasMoreItems: false,
            totalItems: 1,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: '123',
                    name: 'MyDoc',
                    content: {
                        mimetype: 'text/plain'
                    },
                    createdByUser: {
                        displayName: 'John Doe'
                    },
                    modifiedByUser: {
                        displayName: 'John Doe'
                    }
                }
            }
        ]
    }
};
let mockError = {
    error: {
        errorKey: 'Search failed',
        statusCode: 400,
        briefSummary: '08220082 search failed',
        stackTrace: 'For security reasons the stack trace is no longer displayed, but the property is kept for previous versions.',
        descriptionURL: 'https://api-explorer.alfresco.com'
    }
};
let searchMockApi = {
    core: {
        queriesApi: {
            findNodes: (term, opts) => Promise.resolve(fakeSearch)
        }
    }
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TranslationMock {
    constructor() {
        this.onLangChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    addTranslationFolder() {
    }
    /**
     * @param {?} key
     * @param {?=} interpolateParams
     * @return {?}
     */
    get(key, interpolateParams) {
        return Observable$1.of(key);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeForm = {
    id: 1001,
    name: 'ISSUE_FORM',
    processDefinitionId: 'ISSUE_APP:1:2504',
    processDefinitionName: 'ISSUE_APP',
    processDefinitionKey: 'ISSUE_APP',
    taskId: '7506',
    taskDefinitionKey: 'sid-F67A2996-1684-4774-855A-4591490081FD',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212398417',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'label',
                        name: 'Label',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'test1'
                            },
                            {
                                id: 'option_2',
                                name: 'test2'
                            },
                            {
                                id: 'option_3',
                                name: 'test3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'raduio',
                        name: 'raduio',
                        type: 'radio-buttons',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: [
                            {
                                id: 'option_1',
                                name: 'Option 1'
                            },
                            {
                                id: 'option_2',
                                name: 'Option 2'
                            },
                            {
                                id: 'option_3',
                                name: 'Option 3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 2,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212413062',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let formDefinitionTwoTextFields = {
    id: 20,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:1:153',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '159',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
let formDefinitionDropdownField = {
    id: 21,
    name: 'dropdownDefinition',
    processDefinitionId: 'textDefinition:2:163',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '169',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507046026940',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'united kingdom'
                            },
                            {
                                id: 'option_2',
                                name: 'italy'
                            },
                            {
                                id: 'option_3',
                                name: 'france'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let formReadonlyTwoTextFields = {
    id: 22,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:3:182',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '188',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'readonly',
                        value: 'fakeFirstName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2,
                            field: {
                                id: 'firstname',
                                name: 'firstName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'readonly',
                        value: 'fakeLastName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1,
                            field: {
                                id: 'lastname',
                                name: 'lastName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let formDefVisibilitiFieldDependsOnNextOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftFormFieldId: 'name',
                            leftRestResponseId: null,
                            operator: '==',
                            rightValue: 'italy',
                            rightType: null,
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
let formDefVisibilitiFieldDependsOnPreviousOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftFormFieldId: 'name',
                            leftRestResponseId: null,
                            operator: '==',
                            rightValue: 'italy',
                            rightType: null,
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let startFormDateWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null
                    }]
            }
        }
    ]
};
let startFormNumberWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'number',
                        name: 'number widget',
                        type: 'integer',
                        value: null
                    }]
            }
        }
    ]
};
let startFormAmountWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'amount',
                        name: 'amount widget',
                        type: 'amount',
                        value: null
                    }]
            }
        }
    ]
};
let startFormRadioButtonWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'radio-but',
                        name: 'radio-buttons',
                        type: 'radio-buttons',
                        value: null
                    }]
            }
        }
    ]
};
let startFormTextDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'mocktext',
                        name: 'mockText',
                        type: 'text',
                        value: null
                    }]
            }
        }
    ]
};
let startFormDropdownDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'mockTypeDropDown',
                        name: 'mock DropDown',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'opt1',
                                name: 'Option-1'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-2'
                            },
                            {
                                id: 'opt3',
                                name: 'Option-3'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-3'
                            }
                        ]
                    }]
            }
        }
    ]
};
let startMockForm = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billamount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalname',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        },
        {
            id: 'start_process',
            name: 'Start Process'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};
let startMockFormWithTab = {
    id: 4,
    taskName: 'Mock Title',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [
        {
            id: 'form1',
            name: 'Tab 1'
        },
        {
            id: 'form2',
            name: 'Tab 2'
        }
    ],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billamount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalname',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let formModelTabs = {
    id: 16,
    name: 'start event',
    description: '',
    version: 2,
    lastUpdatedBy: 4,
    lastUpdatedByFullName: 'User Test',
    lastUpdated: '2017-10-04T13:00:03.030+0000',
    stencilSetId: null,
    referenceId: null,
    formDefinition: {
        tabs: [],
        fields: [
            {
                fieldType: 'ContainerRepresentation',
                id: '1507037668653',
                name: 'Label',
                type: 'container',
                value: null,
                required: false,
                readOnly: false,
                overrideId: false,
                colspan: 1,
                placeholder: null,
                minLength: 0,
                maxLength: 0,
                minValue: null,
                maxValue: null,
                regexPattern: null,
                optionType: null,
                hasEmptyValue: null,
                options: null,
                restUrl: null,
                restResponsePath: null,
                restIdProperty: null,
                restLabelProperty: null,
                tab: null,
                className: null,
                dateDisplayFormat: null,
                layout: null,
                sizeX: 2,
                sizeY: 1,
                row: -1,
                col: -1,
                visibilityCondition: null,
                numberOfColumns: 2,
                fields: {
                    '1': [
                        {
                            fieldType: 'AmountFieldRepresentation',
                            id: 'label',
                            name: 'Label',
                            type: 'amount',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 2
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null,
                            enableFractions: false,
                            currency: null
                        }
                    ],
                    '2': [
                        {
                            fieldType: 'FormFieldRepresentation',
                            id: 'label1',
                            name: 'Label1',
                            type: 'date',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 1
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null
                        }
                    ]
                }
            },
            {
                fieldType: 'ContainerRepresentation',
                id: '1507037670167',
                name: 'Label',
                type: 'container',
                value: null,
                required: false,
                readOnly: false,
                overrideId: false,
                colspan: 1,
                placeholder: null,
                minLength: 0,
                maxLength: 0,
                minValue: null,
                maxValue: null,
                regexPattern: null,
                optionType: null,
                hasEmptyValue: null,
                options: null,
                restUrl: null,
                restResponsePath: null,
                restIdProperty: null,
                restLabelProperty: null,
                tab: null,
                className: null,
                dateDisplayFormat: null,
                layout: null,
                sizeX: 2,
                sizeY: 1,
                row: -1,
                col: -1,
                visibilityCondition: null,
                numberOfColumns: 2,
                fields: {
                    '1': [
                        {
                            fieldType: 'FormFieldRepresentation',
                            id: 'label2',
                            name: 'Label2',
                            type: 'boolean',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 2
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null
                        }
                    ],
                    '2': []
                }
            }
        ],
        outcomes: [],
        javascriptEvents: [],
        className: '',
        style: '',
        customFieldTemplates: {},
        metadata: {},
        variables: [],
        customFieldsValueInfo: {},
        gridsterForm: false
    }
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let formTest = new FormModel({});
let fakeTaskProcessVariableModels = [
    { id: 'TEST_VAR_1', type: 'string', value: 'test_value_1' },
    { id: 'TEST_VAR_2', type: 'string', value: 'test_value_2' },
    { id: 'TEST_VAR_3', type: 'string', value: 'test_value_3' }
];
let formValues = {
    'test_1': 'value_1',
    'test_2': 'value_2',
    'test_3': 'value_1',
    'test_4': 'dropdown_id',
    'test_5': 'dropdown_label',
    'dropdown': { 'id': 'dropdown_id', 'name': 'dropdown_label' }
};
let fakeFormJson = {
    id: '9999',
    name: 'FORM_VISIBILITY',
    processDefinitionId: 'PROCESS_TEST:9:9999',
    processDefinitionName: 'PROCESS_TEST',
    processDefinitionKey: 'PROCESS_TEST',
    taskId: '999',
    taskName: 'TEST',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '000000000000000000',
            name: 'Label',
            type: 'container',
            value: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_TEST',
                        name: 'FIELD_TEST',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_WITH_CONDITION',
                        name: 'FIELD_WITH_CONDITION',
                        type: 'text',
                        value: 'field_with_condition_value',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'LEFT_FORM_FIELD_ID',
                        name: 'LEFT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'LEFT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'RIGHT_FORM_FIELD_ID',
                        name: 'RIGHT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ]
            }
        }
    ]
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { createTranslateLoader, CoreModule, ViewerModule, UserInfoModule, ToolbarModule, HostSettingsModule, PaginationModule, LoginModule, LanguageMenuModule, InfoDrawerModule, DataColumnModule, DataTableModule, ContextMenuModule, CollapsableModule, CardViewModule, startupServiceFactory, AppConfigModule, FormModule, PipeModule, ServiceModule, DirectiveModule, ViewerComponent, ImgViewerComponent, MediaPlayerComponent, PdfViewerComponent, TxtViewerComponent, UnknownFormatComponent, ViewerMoreActionsComponent, ViewerOpenWithComponent, ViewerSidebarComponent, ViewerToolbarComponent, ViewerExtensionDirective, UserInfoComponent, BpmUserService, EcmUserService, ToolbarDividerComponent, ToolbarTitleComponent, ToolbarComponent, HostSettingsComponent, PaginationComponent, InfinitePaginationComponent, LoginHeaderDirective, LoginFooterDirective, LoginComponent, LoginErrorEvent, LoginSubmitEvent, LoginSuccessEvent, LanguageMenuComponent, InfoDrawerLayoutComponent, InfoDrawerTitleDirective, InfoDrawerButtonsDirective, InfoDrawerContentDirective, InfoDrawerTabComponent, InfoDrawerComponent, DataColumnListComponent, DataColumnComponent, DataRowEvent, DataSorting, ObjectDataRow, ObjectDataTableAdapter, ObjectDataColumn, DataCellEventModel, DataCellEvent, DataRowActionEvent, DataRowActionModel, DataTableCellComponent, DataTableComponent, DateCellComponent, EmptyListComponent, EmptyListHeaderDirective, EmptyListBodyDirective, EmptyListFooterDirective, FileSizeCellComponent, LocationCellComponent, LoadingContentTemplateDirective, NoContentTemplateDirective, NoPermissionTemplateDirective, ContextMenuHolderComponent, ContextMenuDirective, ContextMenuService, AccordionGroupComponent, AccordionComponent, CardViewContentProxyDirective, CardViewDateItemComponent, CardViewItemDispatcherComponent, CardViewMapItemComponent, CardViewTextItemComponent, CardViewComponent, AppConfigService, FormComponent, FormListComponent, ContentWidgetComponent, StartFormComponent, DocumentWidgetComponent, WIDGET_DIRECTIVES, MASK_DIRECTIVE, baseHost, WidgetComponent, FormFieldTypes, FormWidgetModel, FormFieldModel, FormModel, ContainerModel, ContainerColumnModel, TabModel, FormOutcomeModel, FormOutcomeEvent, RequiredFieldValidator, NumberFieldValidator, DateFieldValidator, MinDateFieldValidator, MaxDateFieldValidator, MinLengthFieldValidator, MaxLengthFieldValidator, MinValueFieldValidator, MaxValueFieldValidator, RegExFieldValidator, FixedValueFieldValidator, FORM_FIELD_VALIDATORS, ContentLinkModel, ErrorMessageModel, TabsWidgetComponent, ContainerWidgetComponent, UnknownWidgetComponent, TextWidgetComponent, NumberWidgetComponent, CheckboxWidgetComponent, MultilineTextWidgetComponentComponent, DropdownWidgetComponent, HyperlinkWidgetComponent, RadioButtonsWidgetComponent, DisplayTextWidgetComponentComponent, UploadWidgetComponent, AttachWidgetComponent, TypeaheadWidgetComponent, FunctionalGroupWidgetComponent, PeopleWidgetComponent, DateWidgetComponent, AmountWidgetComponent, DynamicTableWidgetComponent, ErrorWidgetComponent, DynamicTableModel, RowEditorComponent, DateEditorComponent, DropdownEditorComponent, BooleanEditorComponent, TextEditorComponent, CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR, InputMaskDirective, FormService, EcmModelService, NodeService, FormRenderingService, ProcessContentService, FormEvent, FormErrorEvent, FormFieldEvent, ValidateFormFieldEvent, ValidateFormEvent, ValidateDynamicTableRowEvent, FileSizePipe, MimeTypeIconPipe, NodeNameTooltipPipe, HighlightPipe, TimeAgoPipe, InitialUsernamePipe, AuthenticationService, AlfrescoApiService, SettingsService, ContentService, AuthGuard, AuthGuardEcm, AuthGuardBpm, AppsProcessService, PageTitleService, StorageService, CookieService, RenditionsService, NotificationService, LogService, TRANSLATION_PROVIDER, TranslationService, TranslateLoaderService, ThumbnailService, UploadService, DynamicComponentResolver, DynamicComponentMapper, CardItemTypeService, transformKeyToObject, CardViewUpdateService, UserPreferencesService, HighlightTransformService, DeletedNodesApiService, FavoritesApiService, NodesApiService, PeopleContentService, PeopleProcessService, SearchService, SharedLinksApiService, SitesService, DiscoveryApiService, CommentProcessService, HighlightDirective, LogoutDirective, NodeDeleteDirective, NodeFavoriteDirective, NodePermissionDirective, NodeRestoreDirective, UploadDirective, ObjectUtils, FileUtils, MOMENT_DATE_FORMATS, MomentDateAdapter, EXTENDIBLE_COMPONENT, CardViewBaseItemModel, CardViewTextItemModel, CardViewMapItemModel, CardViewDateItemModel, FileUploadStatus, FileModel, PermissionsEnum, SiteContentsModel, SiteMembersModel, SiteModel, BpmProductVersionModel, EcmProductVersionModel, VersionModel, LicenseModel, VersionStatusModel, VersionModuleModel, UserProcessModel, CommentProcessModel, EcmCompanyModel, BaseEvent, BaseUIEvent, FileUploadEvent, FileUploadCompleteEvent, FileUploadDeleteEvent, FileUploadErrorEvent, AlfrescoApiMock, AppConfigServiceMock, fakeApps, AuthenticationMock, fakeBpmUserNoImage, fakeBpmUser, fakeBpmEditedUser, fakeUser1, fakeUser2, fakeTasksComment, fakeProcessComment, CookieServiceMock, fakeEcmCompany, fakeEcmUser, fakeEcmUserNoImage, fakeEcmEditedUser, EventMock, fakeRedition, fakeReditionCreated, fakeReditionsList, fakeSearch, mockError, searchMockApi, TranslationMock, fakeForm, formDefinitionTwoTextFields, formDefinitionDropdownField, formReadonlyTwoTextFields, formDefVisibilitiFieldDependsOnNextOne, formDefVisibilitiFieldDependsOnPreviousOne, startFormDateWidgetMock, startFormNumberWidgetMock, startFormAmountWidgetMock, startFormRadioButtonWidgetMock, startFormTextDefinitionMock, startFormDropdownDefinitionMock, startMockForm, startMockFormWithTab, formModelTabs, formTest, fakeTaskProcessVariableModels, formValues, fakeFormJson, AppConfigService as ɵc, CardViewContentProxyDirective as ɵcg, CardViewDateItemComponent as ɵcm, CardViewItemDispatcherComponent as ɵcf, CardViewMapItemComponent as ɵcl, CardViewTextItemComponent as ɵcj, CardViewComponent as ɵce, AccordionGroupComponent as ɵcq, AccordionComponent as ɵcp, ContextMenuHolderComponent as ɵcb, ContextMenuDirective as ɵcd, ContextMenuService as ɵcc, DataColumnListComponent as ɵdi, DataColumnComponent as ɵdj, DataTableCellComponent as ɵdo, DataTableComponent as ɵdh, DateCellComponent as ɵdp, EmptyListBodyDirective as ɵdm, EmptyListComponent as ɵdk, EmptyListFooterDirective as ɵdn, EmptyListHeaderDirective as ɵdl, FileSizeCellComponent as ɵdq, LocationCellComponent as ɵdr, LoadingContentTemplateDirective as ɵdu, NoContentTemplateDirective as ɵds, NoPermissionTemplateDirective as ɵdt, HighlightDirective as ɵbj, LogoutDirective as ɵbk, NodeDeleteDirective as ɵbl, NodeFavoriteDirective as ɵbp, NodePermissionDirective as ɵbq, NodeRestoreDirective as ɵbs, UploadDirective as ɵbt, StartFormCustomButtonDirective as ɵeg, FormFieldComponent as ɵdz, FormListComponent as ɵee, FormComponent as ɵec, StartFormComponent as ɵef, AmountWidgetComponent as ɵfc, AttachWidgetComponent as ɵex, CheckboxWidgetComponent as ɵeq, ContainerWidgetComponent as ɵem, ContentWidgetComponent as ɵdv, DateWidgetComponent as ɵfb, DisplayTextWidgetComponentComponent as ɵev, DocumentWidgetComponent as ɵff, DropdownWidgetComponent as ɵes, DynamicTableWidgetComponent as ɵfd, BooleanEditorComponent as ɵfj, DateEditorComponent as ɵfh, DropdownEditorComponent as ɵfi, RowEditorComponent as ɵfg, TextEditorComponent as ɵfk, ErrorWidgetComponent as ɵfe, FunctionalGroupWidgetComponent as ɵez, HyperlinkWidgetComponent as ɵet, MASK_DIRECTIVE as ɵei, WIDGET_DIRECTIVES as ɵeh, MultilineTextWidgetComponentComponent as ɵer, NumberWidgetComponent as ɵep, PeopleWidgetComponent as ɵfa, RadioButtonsWidgetComponent as ɵeu, TabsWidgetComponent as ɵel, CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR as ɵfl, InputMaskDirective as ɵfm, TextWidgetComponent as ɵeo, TypeaheadWidgetComponent as ɵey, UnknownWidgetComponent as ɵen, UploadWidgetComponent as ɵew, WidgetComponent as ɵek, baseHost as ɵej, ActivitiContentService as ɵfn, EcmModelService as ɵdx, FormRenderingService as ɵea, FormService as ɵdw, NodeService as ɵed, ProcessContentService as ɵdy, WidgetVisibilityService as ɵeb, InfoDrawerLayoutComponent as ɵfs, InfoDrawerComponent as ɵfu, InfoDrawerTabComponent as ɵft, EXTENDIBLE_COMPONENT as ɵbr, LanguageMenuComponent as ɵfr, LoginComponent as ɵfo, LoginFooterDirective as ɵfp, LoginHeaderDirective as ɵfq, MaterialModule as ɵe, modules as ɵd, InfinitePaginationComponent as ɵbz, PaginationComponent as ɵca, FileSizePipe as ɵi, MimeTypeIconPipe as ɵm, NodeNameTooltipPipe as ɵv, HighlightPipe as ɵj, TimeAgoPipe as ɵl, InitialUsernamePipe as ɵu, AlfrescoApiService as ɵs, AppsProcessService as ɵcu, AuthGuardBpm as ɵct, AuthGuardEcm as ɵcs, AuthGuard as ɵcr, AuthenticationService as ɵp, CardItemTypeService as ɵch, CardViewUpdateService as ɵck, CommentProcessService as ɵdg, ContentService as ɵo, CookieService as ɵt, DeletedNodesApiService as ɵcx, DiscoveryApiService as ɵdf, DynamicComponentMapper as ɵci, FavoritesApiService as ɵcy, HighlightTransformService as ɵk, LogService as ɵb, NodesApiService as ɵcz, NotificationService as ɵbm, PageTitleService as ɵcv, PeopleContentService as ɵda, PeopleProcessService as ɵdb, RenditionsService as ɵbb, SearchService as ɵdc, SettingsService as ɵbv, SharedLinksApiService as ɵdd, SitesService as ɵde, StorageService as ɵr, ThumbnailService as ɵn, TranslateLoaderService as ɵa, TRANSLATION_PROVIDER as ɵbn, TranslationService as ɵbo, UploadService as ɵcw, UserPreferencesService as ɵq, HostSettingsComponent as ɵbu, ToolbarDividerComponent as ɵh, ToolbarTitleComponent as ɵg, ToolbarComponent as ɵf, UserInfoComponent as ɵbw, BpmUserService as ɵby, EcmUserService as ɵbx, MOMENT_DATE_FORMATS as ɵco, MomentDateAdapter as ɵcn, ImgViewerComponent as ɵbc, MediaPlayerComponent as ɵbe, PdfViewerComponent as ɵbf, TxtViewerComponent as ɵbd, UnknownFormatComponent as ɵbi, ViewerMoreActionsComponent as ɵba, ViewerOpenWithComponent as ɵz, ViewerSidebarComponent as ɵy, ViewerToolbarComponent as ɵx, ViewerComponent as ɵw, ViewerExtensionDirective as ɵbh, RenderingQueueServices as ɵbg };
//# sourceMappingURL=adf-core.js.map
