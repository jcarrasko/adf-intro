import { CommonModule, DatePipe } from '@angular/common';
import { Component, ContentChild, Directive, EventEmitter, Injectable, Input, NgModule, NgZone, Output, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';
import { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { AlfrescoApiService, AppConfigService, AppsProcessService, AuthenticationService, BpmUserService, CardViewDateItemModel, CardViewMapItemModel, CardViewModule, CardViewTextItemModel, CardViewUpdateService, CommentProcessService, ContentService, CoreModule, DataColumnListComponent, DataColumnModule, DataSorting, DataTableComponent, DataTableModule, DirectiveModule, EmptyListComponent, FormModule, InfoDrawerModule, LogService, MOMENT_DATE_FORMATS, MomentDateAdapter, ObjectDataColumn, ObjectDataRow, ObjectDataTableAdapter, PeopleProcessService, PipeModule, ProcessContentService, StartFormComponent, TRANSLATION_PROVIDER, ThumbnailService, TranslationService, UploadService, UserPreferencesService, UserProcessModel } from '@alfresco/adf-core';
import { MAT_PLACEHOLDER_GLOBAL_OPTIONS, MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatDialog, MatDialogModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule, MatTooltipModule } from '@angular/material';
import { FlexLayoutModule } from '@angular/flex-layout';
import { TranslateModule } from '@ngx-translate/core';
import { Observable as Observable$1 } from 'rxjs/Observable';
import 'rxjs/add/observable/throw';
import { Subject as Subject$1 } from 'rxjs/Subject';
import 'rxjs/add/observable/forkJoin';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/operator/switchMap';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material/core';
import moment$1 from 'moment-es6';

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatAutocompleteModule, MatButtonModule, MatCardModule, MatDialogModule,
        MatCheckboxModule, MatDatepickerModule, MatGridListModule, MatIconModule, MatInputModule,
        MatListModule, MatOptionModule, MatRadioModule, MatSelectModule, MatSlideToggleModule, MatTableModule,
        MatTabsModule, MatProgressSpinnerModule, MatNativeDateModule, MatRippleModule, MatTooltipModule,
        MatChipsModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: MAT_PLACEHOLDER_GLOBAL_OPTIONS, useValue: { float: 'never' } }
                ],
                imports: modules(),
                exports: modules()
            },] },
];
/**
 * @nocollapse
 */
MaterialModule.ctorParameters = () => [];

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

// typeof any so that it we don't have to cast when comparing a result to the error object
var errorObject_1 = { e: {} };


var errorObject = {
	errorObject: errorObject_1
};

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject.errorObject.e = e;
        return errorObject.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
var tryCatch_2 = tryCatch;



var tryCatch_1 = {
	tryCatch: tryCatch_2
};

function isFunction(x) {
    return typeof x === 'function';
}
var isFunction_2 = isFunction;


var isFunction_1 = {
	isFunction: isFunction_2
};

var isArray_1 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });


var isArray = {
	isArray: isArray_1
};

function isObject(x) {
    return x != null && typeof x === 'object';
}
var isObject_2 = isObject;


var isObject_1 = {
	isObject: isObject_2
};

var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends$3(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
var UnsubscriptionError_2 = UnsubscriptionError;


var UnsubscriptionError_1 = {
	UnsubscriptionError: UnsubscriptionError_2
};

/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject.errorObject.e.errors) : [errorObject.errorObject.e]);
            }
        }
        if (isArray.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
var Subscription_2 = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}


var Subscription_1 = {
	Subscription: Subscription_2
};

var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};


var Observer = {
	empty: empty
};

// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof commonjsGlobal !== 'undefined' && commonjsGlobal;
var _root = __window || __global || __self;
var root_1 = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();


var root = {
	root: root_1
};

var rxSubscriber = createCommonjsModule(function (module, exports) {
var Symbol = root.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;

});

var rxSubscriber_1 = rxSubscriber.rxSubscriber;
var rxSubscriber_2 = rxSubscriber.$$rxSubscriber;

var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends$2(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
var Subscriber_2 = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends$2(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));


var Subscriber_1 = {
	Subscriber: Subscriber_2
};

var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends$1(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
var OuterSubscriber_2 = OuterSubscriber;


var OuterSubscriber_1 = {
	OuterSubscriber: OuterSubscriber_2
};

var isArrayLike_1 = (function (x) { return x && typeof x.length === 'number'; });


var isArrayLike = {
	isArrayLike: isArrayLike_1
};

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
var isPromise_2 = isPromise;


var isPromise_1 = {
	isPromise: isPromise_2
};

function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber.rxSubscriber]) {
            return nextOrObserver[rxSubscriber.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
var toSubscriber_2 = toSubscriber;


var toSubscriber_1 = {
	toSubscriber: toSubscriber_2
};

var observable = createCommonjsModule(function (module, exports) {
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;

});

var observable_1 = observable.getSymbolObservable;
var observable_2 = observable.observable;
var observable_3 = observable.$$observable;

/* tslint:disable:no-empty */
function noop() { }
var noop_2 = noop;


var noop_1 = {
	noop: noop_2
};

/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
var pipe_2 = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
var pipeFromArray_1 = pipeFromArray;


var pipe_1 = {
	pipe: pipe_2,
	pipeFromArray: pipeFromArray_1
};

/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable$2 = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable$$1(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable$$1.prototype.lift = function (operator) {
        var observable$$1 = new Observable$$1();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable$$1.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable$$1.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable$$1.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                PromiseCtor = root.root.Rx.config.Promise;
            }
            else if (root.root.Promise) {
                PromiseCtor = root.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable$$1.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable$$1.prototype[observable.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable$$1.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable$$1.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                PromiseCtor = root.root.Rx.config.Promise;
            }
            else if (root.root.Promise) {
                PromiseCtor = root.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable$$1.create = function (subscribe) {
        return new Observable$$1(subscribe);
    };
    return Observable$$1;
}());
var Observable_2 = Observable$2;


var Observable_1 = {
	Observable: Observable_2
};

var iterator = createCommonjsModule(function (module, exports) {
function symbolIteratorPonyfill(root$$2) {
    var Symbol = root$$2.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root$$2.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root$$2.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;

});

var iterator_1 = iterator.symbolIteratorPonyfill;
var iterator_2 = iterator.iterator;
var iterator_3 = iterator.$$iterator;

var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends$4(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
var InnerSubscriber_2 = InnerSubscriber;


var InnerSubscriber_1 = {
	InnerSubscriber: InnerSubscriber_2
};

function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator.iterator] === 'function') {
        var iterator$$1 = result[iterator.iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable.observable] === 'function') {
        var obs = result[observable.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
var subscribeToResult_2 = subscribeToResult;


var subscribeToResult_1 = {
	subscribeToResult: subscribeToResult_2
};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
            if (duration === errorObject.errorObject) {
                this.destination.error(errorObject.errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);
                if (innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$6 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends$6(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
var Action_2 = Action;


var Action_1 = {
	Action: Action_2
};

var __extends$5 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends$5(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
var AsyncAction_2 = AsyncAction;


var AsyncAction_1 = {
	AsyncAction: AsyncAction_2
};

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
var Scheduler_2 = Scheduler;


var Scheduler_1 = {
	Scheduler: Scheduler_2
};

var __extends$7 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var AsyncScheduler = (function (_super) {
    __extends$7(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
var AsyncScheduler_2 = AsyncScheduler;


var AsyncScheduler_1 = {
	AsyncScheduler: AsyncScheduler_2
};

/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
var async_1 = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


var async = {
	async: async_1
};

function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
var isNumeric_2 = isNumeric;



var isNumeric_1 = {
	isNumeric: isNumeric_2
};

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
var isScheduler_2 = isScheduler;


var isScheduler_1 = {
	isScheduler: isScheduler_2
};

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
var isDate_2 = isDate;


var isDate_1 = {
	isDate: isDate_2
};

var __extends$8 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends$8(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));

var __extends$9 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = (function (_super) {
    __extends$9(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        _super.call(this, destination);
        this.buffer = [];
        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$10 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = (function (_super) {
    __extends$10(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.buffer = [];
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSkipCountSubscriber = (function (_super) {
    __extends$10(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$11 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferTimeSubscriber = (function (_super) {
    __extends$11(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        _super.call(this, destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        var context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context = contexts[i];
            var buffer = context.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context = contexts.shift();
            destination.next(context.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

var __extends$12 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferToggleSubscriber = (function (_super) {
    __extends$12(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(subscribeToResult_1.subscribeToResult(this, openings));
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            this.destination.next(context.buffer);
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$13 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = (function (_super) {
    __extends$13(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject.errorObject) {
            this.error(errorObject.errorObject.e);
        }
        else {
            closingSubscription = new Subscription_1.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$14 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = (function (_super) {
    __extends$14(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$17 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends$17(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
var ScalarObservable_2 = ScalarObservable;


var ScalarObservable_1 = {
	ScalarObservable: ScalarObservable_2
};

var __extends$18 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends$18(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
var EmptyObservable_2 = EmptyObservable;


var EmptyObservable_1 = {
	EmptyObservable: EmptyObservable_2
};

var __extends$16 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends$16(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
var ArrayObservable_2 = ArrayObservable;


var ArrayObservable_1 = {
	ArrayObservable: ArrayObservable_2
};

var __extends$15 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var none = {};
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends$15(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$20 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends$20(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
var PromiseObservable_2 = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}


var PromiseObservable_1 = {
	PromiseObservable: PromiseObservable_2
};

var __extends$21 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends$21(IteratorObservable, _super);
    function IteratorObservable(iterator$$2, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator$$2 == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator$$2);
    }
    IteratorObservable.create = function (iterator$$2, scheduler) {
        return new IteratorObservable(iterator$$2, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index, hasError = state.hasError, iterator$$2 = state.iterator, subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator$$2.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator$$2.return === 'function') {
                iterator$$2.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator$$2 = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator$$2, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator$$2.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator$$2.return === 'function') {
                        iterator$$2.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
var IteratorObservable_2 = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator.iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator.iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}


var IteratorObservable_1 = {
	IteratorObservable: IteratorObservable_2
};

var __extends$22 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends$22(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
var ArrayLikeObservable_2 = ArrayLikeObservable;


var ArrayLikeObservable_1 = {
	ArrayLikeObservable: ArrayLikeObservable_2
};

/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
var Notification_2 = Notification;


var Notification_1 = {
	Notification: Notification_2
};

var __extends$23 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn$1(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var observeOn_2 = observeOn$1;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
var ObserveOnOperator_1 = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends$23(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
var ObserveOnSubscriber_1 = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
var ObserveOnMessage_1 = ObserveOnMessage;


var observeOn_1 = {
	observeOn: observeOn_2,
	ObserveOnOperator: ObserveOnOperator_1,
	ObserveOnSubscriber: ObserveOnSubscriber_1,
	ObserveOnMessage: ObserveOnMessage_1
};

var __extends$19 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};











/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends$19(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable.observable]().subscribe(subscriber);
        }
        else {
            return ish[observable.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));

var __extends$24 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = (function (_super) {
    __extends$24(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$25 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CountSubscriber = (function (_super) {
    __extends$25(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$26 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceSubscriber = (function (_super) {
    __extends$26(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
        this.durationSubscription = null;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult_1.subscribeToResult(this, duration);
        if (!subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$27 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime$1(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var debounceTime_2 = debounceTime$1;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends$27(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext$1(subscriber) {
    subscriber.debouncedNext();
}


var debounceTime_1 = {
	debounceTime: debounceTime_2
};

var __extends$28 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DefaultIfEmptySubscriber = (function (_super) {
    __extends$28(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        _super.call(this, destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));

var __extends$29 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends$29(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

var __extends$30 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelayWhenSubscriber = (function (_super) {
    __extends$30(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        _super.call(this, destination);
        this.delayDurationSelector = delayDurationSelector;
        this.completed = false;
        this.delayNotifierSubscriptions = [];
        this.values = [];
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        var value = null;
        if (subscriptionIdx !== -1) {
            value = this.values[subscriptionIdx];
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            this.values.splice(subscriptionIdx, 1);
        }
        return value;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            this.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
        this.values.push(value);
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelayObservable = (function (_super) {
    __extends$30(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        _super.call(this);
        this.source = source;
        this.subscriptionDelay = subscriptionDelay;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelaySubscriber = (function (_super) {
    __extends$30(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        _super.call(this);
        this.parent = parent;
        this.source = source;
        this.sourceSubscribed = false;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));

var __extends$31 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DeMaterializeSubscriber = (function (_super) {
    __extends$31(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));

function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return (function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }());
}
var minimalSetImpl_1 = minimalSetImpl;
var Set = root.root.Set || minimalSetImpl();


var _Set = {
	minimalSetImpl: minimalSetImpl_1,
	Set: Set
};

var __extends$32 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = (function (_super) {
    __extends$32(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new _Set.Set();
        if (flushes) {
            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$33 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends$33(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject.errorObject) {
                return this.destination.error(errorObject.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject.errorObject) {
                return this.destination.error(errorObject.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

var __extends$35 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = (function (_super) {
    __extends$35(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error));
var ArgumentOutOfRangeError_2 = ArgumentOutOfRangeError;


var ArgumentOutOfRangeError_1 = {
	ArgumentOutOfRangeError: ArgumentOutOfRangeError_2
};

var __extends$34 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ElementAtSubscriber = (function (_super) {
    __extends$34(ElementAtSubscriber, _super);
    function ElementAtSubscriber(destination, index, defaultValue) {
        _super.call(this, destination);
        this.index = index;
        this.defaultValue = defaultValue;
    }
    ElementAtSubscriber.prototype._next = function (x) {
        if (this.index-- === 0) {
            this.destination.next(x);
            this.destination.complete();
        }
    };
    ElementAtSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index >= 0) {
            if (typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
            }
            else {
                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
            }
        }
        destination.complete();
    };
    return ElementAtSubscriber;
}(Subscriber_1.Subscriber));

var __extends$36 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var EverySubscriber = (function (_super) {
    __extends$36(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
        this.index = 0;
        this.thisArg = thisArg || this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));

var __extends$37 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstSubscriber = (function (_super) {
    __extends$37(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        _super.call(this, destination);
        this.hasCompleted = false;
        this.hasSubscription = false;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$38 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = (function (_super) {
    __extends$38(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$39 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = (function (_super) {
    __extends$39(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        _super.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch_1.tryCatch(this.project)(value, index);
            if (result === errorObject.errorObject) {
                destination.error(errorObject.errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$40 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends$40(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

var __extends$41 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends$41(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));

var __extends$42 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FindValueSubscriber = (function (_super) {
    __extends$42(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
        this.index = 0;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));

var __extends$44 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = (function (_super) {
    __extends$44(EmptyError, _super);
    function EmptyError() {
        var err = _super.call(this, 'no elements in sequence');
        this.name = err.name = 'EmptyError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return EmptyError;
}(Error));
var EmptyError_2 = EmptyError;


var EmptyError_1 = {
	EmptyError: EmptyError_2
};

var __extends$43 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FirstSubscriber = (function (_super) {
    __extends$43(FirstSubscriber, _super);
    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.index = 0;
        this.hasCompleted = false;
        this._emitted = false;
    }
    FirstSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._emit = function (value, index) {
        if (this.resultSelector) {
            this._tryResultSelector(value, index);
            return;
        }
        this._emitFinal(value);
    };
    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this._emitFinal(result);
    };
    FirstSubscriber.prototype._emitFinal = function (value) {
        var destination = this.destination;
        if (!this._emitted) {
            this._emitted = true;
            destination.next(value);
            destination.complete();
            this.hasCompleted = true;
        }
    };
    FirstSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
            destination.next(this.defaultValue);
            destination.complete();
        }
        else if (!this.hasCompleted) {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return FirstSubscriber;
}(Subscriber_1.Subscriber));

var __extends$47 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends$47(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
var ObjectUnsubscribedError_2 = ObjectUnsubscribedError;


var ObjectUnsubscribedError_1 = {
	ObjectUnsubscribedError: ObjectUnsubscribedError_2
};

var __extends$48 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends$48(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
var SubjectSubscription_2 = SubjectSubscription;


var SubjectSubscription_1 = {
	SubjectSubscription: SubjectSubscription_2
};

var __extends$46 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends$46(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
var SubjectSubscriber_1 = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject$2 = (function (_super) {
    __extends$46(Subject$$1, _super);
    function Subject$$1() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject$$1.prototype[rxSubscriber.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject$$1.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject$$1.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject$$1.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject$$1.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject$$1.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject$$1.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject$$1.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject$$1.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject$$1.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject$$1;
}(Observable_1.Observable));
var Subject_2 = Subject$2;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends$46(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject$2));
var AnonymousSubject_1 = AnonymousSubject;


var Subject_1 = {
	SubjectSubscriber: SubjectSubscriber_1,
	Subject: Subject_2,
	AnonymousSubject: AnonymousSubject_1
};

var MapPolyfill = (function () {
    function MapPolyfill() {
        this.size = 0;
        this._values = [];
        this._keys = [];
    }
    MapPolyfill.prototype.get = function (key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
    };
    MapPolyfill.prototype.set = function (key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.size++;
        }
        else {
            this._values[i] = value;
        }
        return this;
    };
    MapPolyfill.prototype.delete = function (key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
    };
    MapPolyfill.prototype.clear = function () {
        this._keys.length = 0;
        this._values.length = 0;
        this.size = 0;
    };
    MapPolyfill.prototype.forEach = function (cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
            cb.call(thisArg, this._values[i], this._keys[i]);
        }
    };
    return MapPolyfill;
}());
var MapPolyfill_2 = MapPolyfill;


var MapPolyfill_1 = {
	MapPolyfill: MapPolyfill_2
};

var Map$1 = root.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();


var _Map = {
	Map: Map$1
};

var FastMap = (function () {
    function FastMap() {
        this.values = {};
    }
    FastMap.prototype.delete = function (key) {
        this.values[key] = null;
        return true;
    };
    FastMap.prototype.set = function (key, value) {
        this.values[key] = value;
        return this;
    };
    FastMap.prototype.get = function (key) {
        return this.values[key];
    };
    FastMap.prototype.forEach = function (cb, thisArg) {
        var values = this.values;
        for (var key in values) {
            if (values.hasOwnProperty(key) && values[key] !== null) {
                cb.call(thisArg, values[key], key);
            }
        }
    };
    FastMap.prototype.clear = function () {
        this.values = {};
    };
    return FastMap;
}());
var FastMap_2 = FastMap;


var FastMap_1 = {
	FastMap: FastMap_2
};

var __extends$45 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = (function (_super) {
    __extends$45(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
        this.groups = null;
        this.attemptedToUnsubscribe = false;
        this.count = 0;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new _Map.Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = (function (_super) {
    __extends$45(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        _super.call(this, group);
        this.key = key;
        this.group = group;
        this.parent = parent;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = (function (_super) {
    __extends$45(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        _super.call(this);
        this.key = key;
        this.groupSubject = groupSubject;
        this.refCountSubscription = refCountSubscription;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = (function (_super) {
    __extends$45(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        _super.call(this);
        this.parent = parent;
        parent.count++;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

var __extends$49 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = (function (_super) {
    __extends$49(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));

var __extends$50 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IsEmptySubscriber = (function (_super) {
    __extends$50(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        _super.call(this, destination);
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));

var __extends$51 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var LastSubscriber = (function (_super) {
    __extends$51(LastSubscriber, _super);
    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.hasValue = false;
        this.index = 0;
        if (typeof defaultValue !== 'undefined') {
            this.lastValue = defaultValue;
            this.hasValue = true;
        }
    }
    LastSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.lastValue = result;
        this.hasValue = true;
    };
    LastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.hasValue) {
            destination.next(this.lastValue);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return LastSubscriber;
}(Subscriber_1.Subscriber));

var __extends$52 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends$52(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

var __extends$53 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = (function (_super) {
    __extends$53(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));

var __extends$54 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MaterializeSubscriber = (function (_super) {
    __extends$54(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));

var __extends$55 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends$55(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

var __extends$56 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = (function (_super) {
    __extends$56(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));

var __extends$57 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapToSubscriber = (function (_super) {
    __extends$57(MergeMapToSubscriber, _super);
    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapToSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            this.active++;
            this._innerSub(ish, destination, resultSelector, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapToSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    MergeMapToSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$58 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeScanSubscriber = (function (_super) {
    __extends$58(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this.acc = acc;
        this.concurrent = concurrent;
        this.hasValue = false;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject.errorObject) {
                destination.error(errorObject.errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$60 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

function refCount$1() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator$1(source));
    };
}
var refCount_2 = refCount$1;
var RefCountOperator$1 = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber$1(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber$1 = (function (_super) {
    __extends$60(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));


var refCount_1 = {
	refCount: refCount_2
};

var __extends$59 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = (function (_super) {
    __extends$59(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
var ConnectableSubscriber = (function (_super) {
    __extends$59(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountSubscriber = (function (_super) {
    __extends$59(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$61 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var OnErrorResumeNextSubscriber = (function (_super) {
    __extends$61(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        _super.call(this, destination);
        this.destination = destination;
        this.nextSources = nextSources;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult_1.subscribeToResult(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$62 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends$62(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));

var __extends$63 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = (function (_super) {
    __extends$63(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));

var __extends$64 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * @class AsyncSubject<T>
 */
var AsyncSubject = (function (_super) {
    __extends$64(AsyncSubject, _super);
    function AsyncSubject() {
        _super.apply(this, arguments);
        this.value = null;
        this.hasNext = false;
        this.hasCompleted = false;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));

var __extends$66 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends$66(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
var QueueAction_2 = QueueAction;


var QueueAction_1 = {
	QueueAction: QueueAction_2
};

var __extends$67 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var QueueScheduler = (function (_super) {
    __extends$67(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
var QueueScheduler_2 = QueueScheduler;


var QueueScheduler_1 = {
	QueueScheduler: QueueScheduler_2
};

/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
var queue_1 = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);


var queue = {
	queue: queue_1
};

var __extends$65 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends$65(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

var __extends$68 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = (function (_super) {
    __extends$68(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        _super.call(this, destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$69 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatSubscriber = (function (_super) {
    __extends$69(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));

var __extends$70 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatWhenSubscriber = (function (_super) {
    __extends$70(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
        this.sourceIsBeingSubscribedTo = true;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            else if (this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.notifications = null;
        this.retries = null;
        this.retriesSubscription = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this.notifications = notifications;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject.errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$71 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = (function (_super) {
    __extends$71(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));

var __extends$72 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = (function (_super) {
    __extends$72(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject.errorObject) {
                    return _super.prototype.error.call(this, errorObject.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$73 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = (function (_super) {
    __extends$73(SampleSubscriber, _super);
    function SampleSubscriber() {
        _super.apply(this, arguments);
        this.hasValue = false;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$74 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleTimeSubscriber = (function (_super) {
    __extends$74(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        _super.call(this, destination);
        this.period = period;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

var __extends$75 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SequenceEqualSubscriber = (function (_super) {
    __extends$75(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        _super.call(this, destination);
        this.compareTo = compareTo;
        this.comparor = comparor;
        this._a = [];
        this._b = [];
        this._oneComplete = false;
        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch_1.tryCatch(comparor)(a, b);
                if (areEqual === errorObject.errorObject) {
                    this.destination.error(errorObject.errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends$75(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        _super.call(this, destination);
        this.parent = parent;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));

var __extends$76 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SingleSubscriber = (function (_super) {
    __extends$76(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));

var __extends$77 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends$77(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));

var __extends$78 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipLastSubscriber = (function (_super) {
    __extends$78(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        _super.call(this, destination);
        this._skipCount = _skipCount;
        this._count = 0;
        this._ring = new Array(_skipCount);
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));

var __extends$79 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends$79(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$80 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = (function (_super) {
    __extends$80(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));

var __extends$81 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends$81(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$82 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = (function (_super) {
    __extends$82(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$83 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends$83(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));

var __extends$84 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends$84(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$85 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = (function (_super) {
    __extends$85(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.index = 0;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));

var __extends$86 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends$86(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));

var throttle_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
 * to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasTrailingValue = false;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this._trailing) {
                this._hasTrailingValue = true;
                this._trailingValue = value;
            }
        }
        else {
            var duration = this.tryDurationSelector(value);
            if (duration) {
                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
            }
            if (this._leading) {
                this.destination.next(value);
                if (this._trailing) {
                    this._hasTrailingValue = true;
                    this._trailingValue = value;
                }
            }
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype._unsubscribe = function () {
        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
        this._trailingValue = null;
        this._hasTrailingValue = false;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype._sendTrailing = function () {
        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
        if (throttled && _trailing && _hasTrailingValue) {
            destination.next(_trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._sendTrailing();
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._sendTrailing();
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

});

var throttle_2 = throttle_1.defaultThrottleConfig;
var throttle_3 = throttle_1.throttle;

var __extends$87 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = (function (_super) {
    __extends$87(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$2, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext$2(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

var __extends$88 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeIntervalSubscriber = (function (_super) {
    __extends$88(TimeIntervalSubscriber, _super);
    function TimeIntervalSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.lastTime = 0;
        this.lastTime = scheduler.now();
    }
    TimeIntervalSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        var span = now - this.lastTime;
        this.lastTime = now;
        this.destination.next(new TimeInterval(value, span));
    };
    return TimeIntervalSubscriber;
}(Subscriber_1.Subscriber));

var __extends$90 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends$90(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));

var __extends$89 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends$89(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));

var __extends$91 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutWithSubscriber = (function (_super) {
    __extends$91(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$92 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends$92(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        _super.call(this, destination);
        this.window = new Subject_1.Subject();
        destination.next(this.window);
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$93 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowCountSubscriber = (function (_super) {
    __extends$93(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [new Subject_1.Subject()];
        this.count = 0;
        destination.next(this.windows[0]);
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$94 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var CountedSubject = (function (_super) {
    __extends$94(CountedSubject, _super);
    function CountedSubject() {
        _super.apply(this, arguments);
        this._numberOfNextedValues = 0;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = (function (_super) {
    __extends$94(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        var window = this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

var __extends$95 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowToggleSubscriber = (function (_super) {
    __extends$95(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.error(err);
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.complete();
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.unsubscribe();
                context.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject.errorObject) {
                return this.error(errorObject.errorObject.e);
            }
            else {
                var window_1 = new Subject_1.Subject();
                var subscription = new Subscription_1.Subscription();
                var context = { window: window_1, subscription: subscription };
                this.contexts.push(context);
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$96 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber$1 = (function (_super) {
    __extends$96(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.closingSelector = closingSelector;
        this.openWindow();
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject.errorObject) {
            var err = errorObject.errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$97 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = (function (_super) {
    __extends$97(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$98 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = (function (_super) {
    __extends$98(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) { values = Object.create(null); }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = (typeof project === 'function') ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$2 = iterators[i];
            if (iterator$$2.stillUnsubscribed) {
                this.add(iterator$$2.subscribe(iterator$$2, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator$$2 = iterators[i];
            if (typeof iterator$$2.hasValue === 'function' && !iterator$$2.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$2 = iterators[i];
            var result = iterator$$2.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator$$2.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
var StaticIterator = (function () {
    function StaticIterator(iterator$$2) {
        this.iterator = iterator$$2;
        this.nextResult = iterator$$2.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = (function (_super) {
    __extends$98(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));

var debounceTime = debounceTime_1.debounceTime;

var throttle = throttle_1.throttle;

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleSearchComponent {
    /**
     * @param {?} peopleProcessService
     */
    constructor(peopleProcessService) {
        this.peopleProcessService = peopleProcessService;
        this.searchPeople = new EventEmitter();
        this.success = new EventEmitter();
        this.closeSearch = new EventEmitter();
        this.searchUser = new FormControl();
        this.users = [];
        this.searchUser.valueChanges
            .pipe(debounceTime(200))
            .subscribe((event) => {
            if (event && event.trim()) {
                this.searchPeople.emit(event);
            }
            else {
                this.users = [];
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.results.subscribe((list) => {
            this.users = list;
        });
    }
    /**
     * @param {?} user
     * @return {?}
     */
    onRowClick(user) {
        this.selectedUser = user;
    }
    /**
     * @return {?}
     */
    closeSearchList() {
        this.closeSearch.emit();
    }
    /**
     * @return {?}
     */
    involveUserAndClose() {
        this.involveUser();
        this.closeSearchList();
    }
    /**
     * @return {?}
     */
    involveUser() {
        if (this.selectedUser === undefined) {
            return;
        }
        this.success.emit(this.selectedUser);
        this.users = this.users.filter((user) => {
            this.searchUser.reset();
            return user.id !== this.selectedUser.id;
        });
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?=} delimiter
     * @return {?}
     */
    getDisplayUser(firstName, lastName, delimiter = '-') {
        firstName = (firstName !== null ? firstName : '');
        lastName = (lastName !== null ? lastName : '');
        return firstName + delimiter + lastName;
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @return {?}
     */
    getInitialUserName(firstName, lastName) {
        firstName = (firstName !== null && firstName !== '' ? firstName[0] : '');
        lastName = (lastName !== null && lastName !== '' ? lastName[0] : '');
        return this.getDisplayUser(firstName, lastName, '');
    }
    /**
     * @return {?}
     */
    hasUsers() {
        return (this.users && this.users.length > 0);
    }
}
PeopleSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-search',
                template: `
      <div class="search-text-header">
          <ng-content select="[people-search-title]"></ng-content>
      </div>
      <mat-form-field class="search-text-container">
      	<input matInput placeholder="{{'ADF_TASK_LIST.PEOPLE.SEARCH_USER'|translate}}" type="text" id="userSearchText" [value]="" [formControl]="searchUser">
      </mat-form-field>
      <div class="search-list-container" id="search-people-list" *ngIf="hasUsers()">
          <adf-people-list
          [users]="users"
          (clickRow)="onRowClick($event)">
              <data-columns>
                  <data-column key="firstName">
                      <ng-template let-entry="$implicit">
                              <div *ngIf="!entry.row.obj.pictureId" class="people-pic">
                                  {{getInitialUserName(entry.row.obj.firstName, entry.row.obj.lastName)}}</div>
                              <div>
                                  <img *ngIf="entry.row.obj.pictureId" class="people-img"
                                      [src]="peopleProcessService.getUserImage(entry.row.obj)"/>
                              </div>
                      </ng-template>
                  </data-column>
                  <data-column key="email" class="full-width">
                      <ng-template let-entry="$implicit">
                          <div class="people-full-name">{{ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ') }}</div>
                      </ng-template>
                  </data-column>
              </data-columns>
          </adf-people-list>
      </div>
      <div class="search-list-action-container">
          <button mat-button type="button" id="close-people-search" (click)="closeSearchList()">
              {{'ADF_TASK_LIST.PEOPLE.DIALOG_CLOSE' | translate }}
          </button>
          <button mat-button type="button" id="add-people" (click)="involveUserAndClose()">
              <ng-content select="[people-search-action-label]"></ng-content>
          </button>
      </div>
    `,
                styles: [`

    `],
                host: {
                    'class': 'adf-people-search'
                },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
PeopleSearchComponent.ctorParameters = () => [
    { type: PeopleProcessService, },
];
PeopleSearchComponent.propDecorators = {
    'results': [{ type: Input },],
    'searchPeople': [{ type: Output },],
    'success': [{ type: Output },],
    'closeSearch': [{ type: Output },],
};
class PeopleSearchTitleDirective {
}
PeopleSearchTitleDirective.decorators = [
    { type: Directive, args: [{ selector: 'people-search-title' },] },
];
/**
 * @nocollapse
 */
PeopleSearchTitleDirective.ctorParameters = () => [];
class PeopleSearchActionLabelDirective {
}
PeopleSearchActionLabelDirective.decorators = [
    { type: Directive, args: [{ selector: 'people-search-action-label' },] },
];
/**
 * @nocollapse
 */
PeopleSearchActionLabelDirective.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleComponent {
    /**
     * @param {?} logService
     * @param {?} peopleProcessService
     */
    constructor(logService, peopleProcessService) {
        this.logService = logService;
        this.peopleProcessService = peopleProcessService;
        this.people = [];
        this.taskId = '';
        this.readOnly = false;
        this.showAssignment = false;
        this.peopleSearch$ = new Observable$1(observer => this.peopleSearchObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    involveUserAndCloseSearch() {
        if (this.peopleSearch) {
            this.peopleSearch.involveUserAndClose();
        }
    }
    /**
     * @return {?}
     */
    involveUserWithoutCloseSearch() {
        if (this.peopleSearch) {
            this.peopleSearch.involveUser();
        }
    }
    /**
     * @param {?} searchedWord
     * @return {?}
     */
    searchUser(searchedWord) {
        this.peopleProcessService.getWorkflowUsers(this.taskId, searchedWord)
            .subscribe((users) => {
            this.peopleSearchObserver.next(users);
        }, error => this.logService.error(error));
    }
    /**
     * @param {?} user
     * @return {?}
     */
    involveUser(user) {
        this.peopleProcessService.involveUserWithTask(this.taskId, user.id.toString())
            .subscribe(() => {
            this.people = [...this.people, user];
        }, error => this.logService.error('Impossible to involve user with task'));
    }
    /**
     * @param {?} user
     * @return {?}
     */
    removeInvolvedUser(user) {
        this.peopleProcessService.removeInvolvedUser(this.taskId, user.id.toString())
            .subscribe(() => {
            this.people = this.people.filter((involvedUser) => {
                return involvedUser.id !== user.id;
            });
        }, error => this.logService.error('Impossible to remove involved user from task'));
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?=} delimiter
     * @return {?}
     */
    getDisplayUser(firstName, lastName, delimiter = '-') {
        firstName = (firstName !== null ? firstName : '');
        lastName = (lastName !== null ? lastName : '');
        return firstName + delimiter + lastName;
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @return {?}
     */
    getInitialUserName(firstName, lastName) {
        firstName = (firstName !== null && firstName !== '' ? firstName[0] : '');
        lastName = (lastName !== null && lastName !== '' ? lastName[0] : '');
        return this.getDisplayUser(firstName, lastName, '');
    }
    /**
     * @return {?}
     */
    onAddAssignement() {
        this.showAssignment = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClickAction(event) {
        if (event.type === 'remove') {
            this.removeInvolvedUser(event.value);
        }
    }
    /**
     * @return {?}
     */
    hasPeople() {
        return this.people && this.people.length > 0;
    }
    /**
     * @return {?}
     */
    isEditMode() {
        return !this.readOnly;
    }
    /**
     * @return {?}
     */
    onCloseSearch() {
        this.showAssignment = false;
    }
}
PeopleComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people',
                template: `
      <mat-card class="assignment-top-container">
          <div mat-card-content class="assignment-top-container-content">
              <div class="assignment-header">
                      <div *ngIf="hasPeople()" class="assigment-count" id="people-title">
                          {{ 'ADF_TASK_LIST.DETAILS.LABELS.PEOPLE' | translate }} {{ ' (' + people.length + ')' }}
                      </div>
                      <div *ngIf="!hasPeople()" class="assigment-count" id="no-people-label">
                          {{ 'ADF_TASK_LIST.DETAILS.PEOPLE.NONE' | translate }}
                      </div>
                      <div *ngIf="isEditMode()" class="add-people" (click)="onAddAssignement()">
                          <mat-icon class="adf-add-person-icon">person_add</mat-icon>
                      </div>
                  </div>
                  <div class="assignment-container" *ngIf="showAssignment">
                      <adf-people-search
                      (searchPeople)="searchUser($event)"
                      (success)="involveUser($event)"
                      (closeSearch)="onCloseSearch()"
                      [results]="peopleSearch$">
                          <ng-container people-search-title>{{ 'ADF_TASK_LIST.DETAILS.LABELS.ADD_PEOPLE' | translate }}</ng-container>
                          <ng-container people-search-action-label>{{ 'ADF_TASK_LIST.PEOPLE.ADD_USER' | translate }}</ng-container>
                      </adf-people-search>
                  </div>
                  <div class="assignment-list-container" id="assignment-people-list" *ngIf="hasPeople()">
                      <adf-people-list
                      [users]="people"
                      [actions]="isEditMode()"
                      (clickAction)="onClickAction($event)">
                          <data-columns>
                              <data-column key="firstName">
                                  <ng-template let-entry="$implicit">
                                      <div *ngIf="!entry.row.obj.pictureId" class="adf-people-search-people-pic">
                                          {{getInitialUserName(entry.row.obj.firstName, entry.row.obj.lastName)}}</div>
                                      <div>
                                          <img *ngIf="entry.row.obj.pictureId" class="people-img"
                                              [src]="peopleProcessService.getUserImage(entry.row.obj)"/>
                                      </div>
                                  </ng-template>
                              </data-column>
                              <data-column key="email" class="full-width">
                                  <ng-template let-entry="$implicit">
                                      <div class="people-full-name">{{ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ') }}</div>
                                      <div class="people-email">{{ entry.row.obj.email }}</div>
                                      <div class="people-edit-label">can edit</div>
                                  </ng-template>
                              </data-column>
                          </data-columns>
                      </adf-people-list>
                  </div>
          </div>
      </mat-card>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
PeopleComponent.ctorParameters = () => [
    { type: LogService, },
    { type: PeopleProcessService, },
];
PeopleComponent.propDecorators = {
    'people': [{ type: Input },],
    'taskId': [{ type: Input },],
    'readOnly': [{ type: Input },],
    'peopleSearch': [{ type: ViewChild, args: [PeopleSearchComponent,] },],
};

/**
 *
 * This object represent the User Event.
 *
 *
 */
class UserEventModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.type = '';
        this.value = {};
        this.type = obj && obj.type;
        this.value = obj && obj.value || {};
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleListComponent {
    constructor() {
        this.actions = false;
        this.clickRow = new EventEmitter();
        this.clickAction = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.peopleDataTable.columnList = this.columnList;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    selectUser(event) {
        this.user = event.value.obj;
        this.clickRow.emit(this.user);
    }
    /**
     * @return {?}
     */
    hasActions() {
        return this.actions;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        let /** @type {?} */ removeAction = {
            title: 'Remove',
            name: 'remove'
        };
        event.value.actions = [
            removeAction
        ];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        let /** @type {?} */ args = event.value;
        let /** @type {?} */ action = args.action;
        this.clickAction.emit(new UserEventModel({ type: action.name, value: args.row.obj }));
    }
}
PeopleListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-list',
                template: `
      <adf-datatable
          [rows]="users"
          [actions]="hasActions()"
          (rowClick)="selectUser($event)"
          (rowDblClick)="selectUser($event)"
          (showRowActionsMenu)="onShowRowActionsMenu($event)"
          (executeRowAction)="onExecuteRowAction($event)">
      </adf-datatable>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
PeopleListComponent.ctorParameters = () => [];
PeopleListComponent.propDecorators = {
    'columnList': [{ type: ContentChild, args: [DataColumnListComponent,] },],
    'peopleDataTable': [{ type: ViewChild, args: [DataTableComponent,] },],
    'users': [{ type: Input },],
    'actions': [{ type: Input },],
    'clickRow': [{ type: Output },],
    'clickAction': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleModule {
}
PeopleModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    DataColumnModule,
                    DataTableModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    PeopleComponent,
                    PeopleSearchComponent,
                    PeopleSearchTitleDirective,
                    PeopleSearchActionLabelDirective,
                    PeopleListComponent
                ],
                exports: [
                    PeopleComponent,
                    PeopleSearchComponent,
                    PeopleSearchTitleDirective,
                    PeopleSearchActionLabelDirective,
                    PeopleListComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
PeopleModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessCommentsComponent {
    /**
     * @param {?} commentProcessService
     */
    constructor(commentProcessService) {
        this.commentProcessService = commentProcessService;
        this.readOnly = true;
        this.error = new EventEmitter();
        this.comments = [];
        this.beingAdded = false;
        this.comment$ = new Observable$1(observer => this.commentObserver = observer).share();
        this.comment$.subscribe((comment) => {
            this.comments.push(comment);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ processInstanceId = changes['processInstanceId'];
        if (processInstanceId) {
            if (processInstanceId.currentValue) {
                this.getProcessInstanceComments(processInstanceId.currentValue);
            }
            else {
                this.resetComments();
            }
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getProcessInstanceComments(processInstanceId) {
        this.resetComments();
        if (processInstanceId) {
            this.commentProcessService.getProcessInstanceComments(processInstanceId).subscribe((res) => {
                res = res.sort((comment1, comment2) => {
                    let /** @type {?} */ date1 = new Date(comment1.created);
                    let /** @type {?} */ date2 = new Date(comment2.created);
                    return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                });
                res.forEach((comment) => {
                    this.commentObserver.next(comment);
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    /**
     * @return {?}
     */
    resetComments() {
        this.comments = [];
    }
    /**
     * @return {?}
     */
    add() {
        if (this.message && this.message.trim() && !this.beingAdded) {
            this.beingAdded = true;
            this.commentProcessService.addProcessInstanceComment(this.processInstanceId, this.message)
                .subscribe((res) => {
                this.comments.unshift(res);
                this.message = '';
                this.beingAdded = false;
            }, (err) => {
                this.error.emit(err);
                this.beingAdded = false;
            });
        }
    }
    /**
     * @return {?}
     */
    clear() {
        this.message = '';
    }
    /**
     * @return {?}
     */
    isReadOnly() {
        return this.readOnly;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    onError(error) {
        this.error.emit(error);
    }
}
ProcessCommentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-comments',
                template: `
      <div class="adf-comments-container">
          <div id="comment-header" class="adf-comments-header">
              {{'ADF_PROCESS_LIST.DETAILS.COMMENTS.HEADER' | translate: { count: comments?.length} }}
          </div>
          <div class="adf-comments-input-container" *ngIf="!isReadOnly()">
              <mat-form-field class="adf-full-width">
                  <input matInput id="comment-input" placeholder="{{'ADF_PROCESS_LIST.DETAILS.COMMENTS.ADD' | translate}}" [(ngModel)]="message" (keyup.enter)="add()" (keyup.esc)="clear()">
              </mat-form-field>
          </div>

          <div *ngIf="comments.length > 0">
              <adf-comment-list [comments]="comments">
              </adf-comment-list>
          </div>
      </div>
    `,
                styles: [`
      :host {
          width: 100%;
      }

      .activiti-label {
          font-weight: bolder;
          vertical-align: top;
      }

      .activiti-label + .icon {
          position: relative;
          top: -2px;
      }

      .list-wrap {
          word-wrap: break-word;
          word-break: break-all;
          -webkit-hyphens:auto;
          -o-hyphens:auto;
          -ms-hyphens:auto;
              hyphens:auto;
      }

      .hide-long-names {
          overflow: auto;
      }

      .adf-comments-container {
          height: 100%;
          width: 100%;
          overflow: auto;
      }

      .adf-comments-header {
          padding: 10px 20px;
          font-size: 14px;
          font-weight: 600;
          border-bottom: 1px solid #e1e1e1;
          color: #a1a1a1;
      }

      .adf-comments-input-container {
          padding: 0 15px;
          width: calc(100% - 30px);
          padding-top: 8px;
          border-bottom: 1px solid #e1e1e1;
      }

      .adf-full-width {
          width: 100%;
      }

      adf-comment-list {
          float: left;
          overflow: auto;
          height: calc(100% - 101px);
          width: 100%;
      }
    `]
            },] },
];
/**
 * @nocollapse
 */
ProcessCommentsComponent.ctorParameters = () => [
    { type: CommentProcessService, },
];
ProcessCommentsComponent.propDecorators = {
    'processInstanceId': [{ type: Input },],
    'readOnly': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentListComponent {
    /**
     * @param {?} datePipe
     * @param {?} peopleProcessService
     */
    constructor(datePipe, peopleProcessService) {
        this.datePipe = datePipe;
        this.peopleProcessService = peopleProcessService;
        this.clickRow = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    selectComment(event) {
        this.selectedComment = event.value.obj;
        this.clickRow.emit(this.selectedComment);
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getUserShortName(user) {
        let /** @type {?} */ shortName = '';
        if (user) {
            if (user.firstName) {
                shortName = user.firstName[0].toUpperCase();
            }
            if (user.lastName) {
                shortName += user.lastName[0].toUpperCase();
            }
        }
        return shortName;
    }
    /**
     * @param {?} aDate
     * @return {?}
     */
    transformDate(aDate) {
        let /** @type {?} */ formattedDate;
        let /** @type {?} */ givenDate = Number.parseInt(this.datePipe.transform(aDate, 'yMMdd'));
        let /** @type {?} */ today = Number.parseInt(this.datePipe.transform(Date.now(), 'yMMdd'));
        if (givenDate === today) {
            formattedDate = 'Today, ' + this.datePipe.transform(aDate, 'hh:mm a');
        }
        else {
            let /** @type {?} */ yesterday = Number.parseInt(this.datePipe.transform(Date.now() - 24 * 3600 * 1000, 'yMMdd'));
            if (givenDate === yesterday) {
                formattedDate = 'Yesterday, ' + this.datePipe.transform(aDate, 'hh:mm a');
            }
            else {
                formattedDate = this.datePipe.transform(aDate, 'MMM dd y, hh:mm a');
            }
        }
        return formattedDate;
    }
    /**
     * @return {?}
     */
    hasComments() {
        return this.comments && this.comments.length && true;
    }
}
CommentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comment-list',
                template: `
      <adf-datatable
          [rows]="comments"
          (rowClick)="selectComment($event)" *ngIf="hasComments()">

          <data-columns>
              <data-column key="createdBy" title="{{'ADF_TASK_LIST.DETAILS.COMMENTS.CREATED_BY_HEADER' | translate }}">
                  <ng-template let-entry="$implicit">
                      <div id="comment-user-icon"
                      class="adf-comment-img-container">
                          <div
                              *ngIf="!entry.row.obj.createdBy.pictureId" class="adf-comment-user-icon">
                                  {{getUserShortName(entry.row.obj.createdBy)}}</div>
                          <div>
                              <img *ngIf="entry.row.obj.createdBy.pictureId" class="adf-people-img"
                                  [src]="peopleProcessService.getUserImage(entry.row.obj.createdBy)"/>
                          </div>
                      </div>
                  </ng-template>
              </data-column>
              <data-column key="message" title="{{'ADF_TASK_LIST.DETAILS.COMMENTS.MESSAGE_HEADER' | translate }}">
                  <ng-template let-entry="$implicit">
                      <div class="adf-comment-contents">
                          <div id="comment-user" class="adf-comment-user-name">
                              {{entry.row.obj.createdBy?.firstName}} {{entry.row.obj.createdBy?.lastName}}
                          </div>
                          <div id="comment-message" class="adf-comment-message">
                              {{entry.row.obj.message}}
                          </div>
                          <div id="comment-time" class="adf-comment-message-time">
                              {{transformDate(entry.row.obj.created)}}
                          </div>
                      </div>
                  </ng-template>
              </data-column>
          </data-columns>

      </adf-datatable>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
CommentListComponent.ctorParameters = () => [
    { type: DatePipe, },
    { type: PeopleProcessService, },
];
CommentListComponent.propDecorators = {
    'comments': [{ type: Input },],
    'clickRow': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentsComponent {
    /**
     * @param {?} commentProcessService
     */
    constructor(commentProcessService) {
        this.commentProcessService = commentProcessService;
        this.readOnly = false;
        this.error = new EventEmitter();
        this.comments = [];
        this.beingAdded = false;
        this.comment$ = new Observable$1(observer => this.commentObserver = observer).share();
        this.comment$.subscribe((comment) => {
            this.comments.push(comment);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ taskId = changes['taskId'];
        if (taskId) {
            if (taskId.currentValue) {
                this.getTaskComments(taskId.currentValue);
            }
            else {
                this.resetComments();
            }
        }
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getTaskComments(taskId) {
        this.resetComments();
        if (taskId) {
            this.commentProcessService.getTaskComments(taskId).subscribe((res) => {
                res = res.sort((comment1, comment2) => {
                    let /** @type {?} */ date1 = new Date(comment1.created);
                    let /** @type {?} */ date2 = new Date(comment2.created);
                    return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                });
                res.forEach((comment) => {
                    this.commentObserver.next(comment);
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    /**
     * @return {?}
     */
    resetComments() {
        this.comments = [];
    }
    /**
     * @return {?}
     */
    add() {
        if (this.message && this.message.trim() && !this.beingAdded) {
            this.beingAdded = true;
            this.commentProcessService.addTaskComment(this.taskId, this.message)
                .subscribe((res) => {
                this.comments.unshift(res);
                this.message = '';
                this.beingAdded = false;
            }, (err) => {
                this.error.emit(err);
                this.beingAdded = false;
            });
        }
    }
    /**
     * @return {?}
     */
    clear() {
        this.message = '';
    }
    /**
     * @return {?}
     */
    isReadOnly() {
        return this.readOnly;
    }
}
CommentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comments',
                template: `
      <div class="adf-comments-container">
          <div id="comment-header" class="adf-comments-header">
              {{'ADF_TASK_LIST.DETAILS.COMMENTS.HEADER' | translate: { count: comments?.length} }}
          </div>
          <div class="adf-comments-input-container" *ngIf="!isReadOnly()">
                  <mat-form-field class="adf-full-width">
                      <input matInput id="comment-input" placeholder="{{'ADF_TASK_LIST.DETAILS.COMMENTS.ADD' | translate}}" [(ngModel)]="message" (keyup.enter)="add()" (keyup.esc)="clear()">
                  </mat-form-field>
          </div>

          <div *ngIf="comments.length > 0">
              <adf-comment-list [comments]="comments">
              </adf-comment-list>
          </div>
      </div>
    `,
                styles: [`
      .adf-comments-container {
          height: 100%;
          width: 100%;
          overflow: auto;
      }

      .adf-comments-header {
          padding: 10px 20px;
          font-size: 14px;
          font-weight: 600;
          border-bottom: 1px solid #e1e1e1;
          color: #a1a1a1;
      }

      .adf-comments-input-container {
          padding: 0 15px;
          width: calc(100% - 30px);
          padding-top: 8px;
          border-bottom: 1px solid #e1e1e1;
      }

      .adf-full-width {
          width: 100%;
      }

      adf-comment-list {
          float: left;
          overflow: auto;
          height: calc(100% - 101px);
          width: 100%;
      }
    `]
            },] },
];
/**
 * @nocollapse
 */
CommentsComponent.ctorParameters = () => [
    { type: CommentProcessService, },
];
CommentsComponent.propDecorators = {
    'taskId': [{ type: Input },],
    'readOnly': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentsModule {
}
CommentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    DataColumnModule,
                    DataTableModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    ProcessCommentsComponent,
                    CommentListComponent,
                    CommentsComponent
                ],
                exports: [
                    ProcessCommentsComponent,
                    CommentListComponent,
                    CommentsComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
CommentsModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskUploadService extends UploadService {
    /**
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
        this.instanceApi = apiService;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    getUploadPromise(file) {
        let /** @type {?} */ opts = {
            isRelatedContent: true
        };
        let /** @type {?} */ taskId = file.options.parentId;
        let /** @type {?} */ promise = this.instanceApi.getInstance().activiti.contentApi.createRelatedContentOnTask(taskId, file.file, opts);
        promise.catch(err => this.handleError(err));
        return promise;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.throw(error || 'Server error');
    }
}
TaskUploadService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
TaskUploadService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: AppConfigService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessUploadService extends UploadService {
    /**
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
        this.instanceApi = apiService;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    getUploadPromise(file) {
        let /** @type {?} */ opts = {
            isRelatedContent: true
        };
        let /** @type {?} */ processInstanceId = file.options.parentId;
        let /** @type {?} */ promise = this.instanceApi.getInstance().activiti.contentApi.createRelatedContentOnProcessInstance(processInstanceId, file.file, opts);
        promise.catch(err => this.handleError(err));
        return promise;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Observable$1.throw(error || 'Server error');
    }
}
ProcessUploadService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ProcessUploadService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: AppConfigService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppDefinitionRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.defaultAppId = obj.defaultAppId ? obj.defaultAppId : null;
            this.deploymentId = obj.deploymentId ? obj.deploymentId : null;
            this.name = obj.name ? obj.name : null;
            this.description = obj.description ? obj.description : null;
            this.theme = obj.theme ? obj.theme : null;
            this.icon = obj.icon ? obj.icon : null;
            this.id = obj.id ? obj.id : null;
            this.modelId = obj.modelId ? obj.modelId : null;
            this.tenantId = obj.tenantId ? obj.tenantId : null;
        }
    }
}
class FilterParamsModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
            this.index = obj.index;
        }
    }
}
class FilterRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.appId = obj.appId || null;
            this.name = obj.name || null;
            this.recent = !!obj.recent;
            this.icon = obj.icon || null;
            this.filter = new FilterParamRepresentationModel(obj.filter);
            this.index = obj.index;
        }
    }
    /**
     * @return {?}
     */
    hasFilter() {
        return this.filter ? true : false;
    }
}
class FilterParamRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.processDefinitionId = obj.processDefinitionId || null;
            this.processDefinitionKey = obj.processDefinitionKey || null;
            this.name = obj.name || null;
            this.state = obj.state || null;
            this.sort = obj.sort || null;
            this.assignment = obj.assignment || null;
            this.dueAfter = obj.dueAfter || null;
            this.dueBefore = obj.dueBefore || null;
        }
    }
}
class TaskQueryRequestRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.appDefinitionId = obj.appDefinitionId || null;
            this.processInstanceId = obj.processInstanceId || null;
            this.processDefinitionId = obj.processDefinitionId || null;
            this.text = obj.text || null;
            this.assignment = obj.assignment || null;
            this.state = obj.state || null;
            this.start = obj.start || null;
            this.sort = obj.sort || null;
            this.page = obj.page || 0;
            this.size = obj.size || 25;
        }
    }
}

/**
 *
 * This object represent of the Form.
 *
 *
 */
class Form {
    /**
     * @param {?} id
     * @param {?} name
     */
    constructor(id, name) {
        this.name = name;
        this.id = id;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * This object represent the details of a task.
 *
 *
 * @returns {TaskDetailsModel} .
 */
class TaskDetailsModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.processDefinitionVersion = 0;
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
            this.priority = obj.priority;
            this.assignee = obj.assignee ? new UserProcessModel(obj.assignee) : null;
            this.adhocTaskCanBeReassigned = obj.adhocTaskCanBeReassigned;
            this.category = obj.category || null;
            this.created = obj.created || null;
            this.description = obj.description || null;
            this.dueDate = obj.dueDate || null;
            this.duration = obj.duration || null;
            this.endDate = obj.endDate || null;
            this.executionId = obj.executionId || null;
            this.formKey = obj.formKey || null;
            this.initiatorCanCompleteTask = !!obj.initiatorCanCompleteTask;
            this.managerOfCandidateGroup = !!obj.managerOfCandidateGroup;
            this.memberOfCandidateGroup = !!obj.memberOfCandidateGroup;
            this.memberOfCandidateUsers = !!obj.memberOfCandidateUsers;
            this.involvedGroups = obj.involvedGroups;
            this.involvedPeople = obj.involvedPeople;
            this.parentTaskId = obj.parentTaskId || null;
            this.parentTaskName = obj.parentTaskName || null;
            this.processDefinitionCategory = obj.processDefinitionCategory || null;
            this.processDefinitionDeploymentId = obj.processDefinitionDeploymentId || null;
            this.processDefinitionDescription = obj.processDefinitionDescription || null;
            this.processDefinitionId = obj.processDefinitionId || null;
            this.processDefinitionKey = obj.processDefinitionKey || null;
            this.processDefinitionName = obj.processDefinitionName || null;
            this.processDefinitionVersion = obj.processDefinitionVersion || 0;
            this.processInstanceId = obj.processInstanceId || null;
            this.processInstanceName = obj.processInstanceName || null;
            this.processInstanceStartUserId = obj.processInstanceStartUserId || null;
            this.taskDefinitionKey = obj.taskDefinitionKey || null;
        }
    }
    /**
     * @return {?}
     */
    getFullName() {
        let /** @type {?} */ fullName = '';
        if (this.assignee) {
            let /** @type {?} */ firstName = this.assignee.firstName ? this.assignee.firstName : '';
            let /** @type {?} */ lastName = this.assignee.lastName ? this.assignee.lastName : '';
            fullName = `${firstName} ${lastName}`;
        }
        return fullName.trim();
    }
    /**
     * @return {?}
     */
    isCompleted() {
        return !!this.endDate;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.tasksListSubject = new Subject$1();
        this.tasksList$ = this.tasksListSubject.asObservable();
    }
    /**
     * Return all the filters in the list where the task id belong
     * @param {?} taskId - string
     * @param {?} filterList
     * @return {?}
     */
    getFilterForTaskById(taskId, filterList) {
        return Observable$1.from(filterList)
            .flatMap((filter) => this.isTaskRelatedToFilter(taskId, filter))
            .filter((filter) => filter != null);
    }
    /**
     * Return the search node for query task based on the given filter
     * @param {?} filter - FilterRepresentationModel
     * @return {?}
     */
    generateTaskRequestNodeFromFilter(filter) {
        let /** @type {?} */ requestNode = {
            appDefinitionId: filter.appId,
            assignment: filter.filter.assignment,
            state: filter.filter.state,
            sort: filter.filter.sort
        };
        return new TaskQueryRequestRepresentationModel(requestNode);
    }
    /**
     * Check if a taskId is filtered with the given filter
     * @param {?} taskId - string
     * @param {?} filter - FilterRepresentationModel
     * @return {?}
     */
    isTaskRelatedToFilter(taskId, filter) {
        let /** @type {?} */ requestNodeForFilter = this.generateTaskRequestNodeFromFilter(filter);
        return Observable$1.fromPromise(this.callApiTasksFiltered(requestNodeForFilter))
            .map((res) => {
            return res.data.find(element => element.id === taskId) ? filter : null;
        }).catch(err => this.handleError(err));
    }
    /**
     * Retrieve all the tasks filtered by filterModel
     * @param {?} requestNode
     * @return {?}
     */
    getTasks(requestNode) {
        return Observable$1.fromPromise(this.callApiTasksFiltered(requestNode))
            .map((res) => {
            this.tasksListSubject.next(res);
            return res;
        }).catch(err => this.handleError(err));
    }
    /**
     * Retrieve tasks filtered by filterModel and state
     * @param {?} requestNode
     * @param {?=} state
     * @return {?}
     */
    findTasksByState(requestNode, state) {
        if (state) {
            requestNode.state = state;
        }
        return this.getTasks(requestNode);
    }
    /**
     * Retrieve all tasks filtered by filterModel and state
     * @param {?} requestNode
     * @param {?=} state
     * @return {?}
     */
    findAllTaskByState(requestNode, state) {
        if (state) {
            requestNode.state = state;
        }
        return this.getTotalTasks(requestNode).switchMap((res) => {
            requestNode.size = res.total;
            return this.getTasks(requestNode);
        });
    }
    /**
     * Retrieve all tasks filtered by filterModel irrespective of state
     * @param {?} requestNode
     * @return {?}
     */
    findAllTasksWithoutState(requestNode) {
        return Observable$1.forkJoin(this.findTasksByState(requestNode, 'open'), this.findAllTaskByState(requestNode, 'completed'), (activeTasks, completedTasks) => {
            const /** @type {?} */ tasks = Object.assign({}, activeTasks);
            tasks.total += completedTasks.total;
            tasks.data = tasks.data.concat(completedTasks.data);
            this.tasksListSubject.next(tasks);
            return tasks;
        });
    }
    /**
     * Retrieve all the task details
     * @param {?} taskId
     * @return {?}
     */
    getTaskDetails(taskId) {
        return Observable$1.fromPromise(this.callApiTaskDetails(taskId))
            .map(res => res)
            .map((details) => {
            return new TaskDetailsModel(details);
        }).catch(err => this.handleError(err));
    }
    /**
     * Retrieve all the task's checklist
     * @param {?} id - taskId
     * @return {?}
     */
    getTaskChecklist(id) {
        return Observable$1.fromPromise(this.callApiTaskChecklist(id))
            .map(res => res)
            .map((response) => {
            let /** @type {?} */ checklists = [];
            response.data.forEach((checklist) => {
                checklists.push(new TaskDetailsModel(checklist));
            });
            return checklists;
        }).catch(err => this.handleError(err));
    }
    /**
     * Retrieve all the form shared with this user
     * @return {?}
     */
    getFormList() {
        let /** @type {?} */ opts = {
            'filter': 'myReusableForms',
            'sort': 'modifiedDesc',
            'modelType': 2 // Integer | modelType
        };
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.modelsApi.getModels(opts)).map(res => res)
            .map((response) => {
            let /** @type {?} */ forms$$1 = [];
            response.data.forEach((form) => {
                forms$$1.push(new Form(form.id, form.name));
            });
            return forms$$1;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @param {?} formId
     * @return {?}
     */
    attachFormToATask(taskId, formId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.attachForm(taskId, { 'formId': formId })).catch(err => this.handleError(err));
    }
    /**
     * Add a task
     * @param {?} task - TaskDetailsModel
     * @return {?}
     */
    addTask(task) {
        return Observable$1.fromPromise(this.callApiAddTask(task))
            .map(res => res)
            .map((response) => {
            return new TaskDetailsModel(response);
        }).catch(err => this.handleError(err));
    }
    /**
     * Delete a task
     * @param {?} taskId - string
     * @return {?}
     */
    deleteTask(taskId) {
        return Observable$1.fromPromise(this.callApiDeleteTask(taskId))
            .catch(err => this.handleError(err));
    }
    /**
     * Make the task completed
     * @param {?} taskId
     * @return {?}
     */
    completeTask(taskId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.completeTask(taskId))
            .map(res => res)
            .catch(err => this.handleError(err));
    }
    /**
     * Return the total number of the tasks by filter
     * @param {?} requestNode - TaskFilterRepresentationModel
     * @return {?}
     */
    getTotalTasks(requestNode) {
        requestNode.size = 0;
        return Observable$1.fromPromise(this.callApiTasksFiltered(requestNode))
            .map((res) => {
            return res;
        }).catch(err => this.handleError(err));
    }
    /**
     * Create a new standalone task
     * @param {?} task - TaskDetailsModel
     * @return {?}
     */
    createNewTask(task) {
        return Observable$1.fromPromise(this.callApiCreateTask(task))
            .map(res => res)
            .map((response) => {
            return new TaskDetailsModel(response);
        }).catch(err => this.handleError(err));
    }
    /**
     * Assign task to user/group
     * @param {?} taskId - string
     * @param {?} requestNode - any
     * @return {?}
     */
    assignTask(taskId, requestNode) {
        let /** @type {?} */ assignee = { assignee: requestNode.id };
        return Observable$1.fromPromise(this.callApiAssignTask(taskId, assignee))
            .map(res => res)
            .map((response) => {
            return new TaskDetailsModel(response);
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} taskId
     * @param {?} userId
     * @return {?}
     */
    assignTaskByUserId(taskId, userId) {
        let /** @type {?} */ assignee = { assignee: userId };
        return Observable$1.fromPromise(this.callApiAssignTask(taskId, assignee))
            .map(res => res)
            .map((response) => {
            return new TaskDetailsModel(response);
        }).catch(err => this.handleError(err));
    }
    /**
     * Claim a task
     * @param {?} taskId
     * @return {?}
     */
    claimTask(taskId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.claimTask(taskId))
            .catch(err => this.handleError(err));
    }
    /**
     * Unclaim a task
     * @param {?} taskId
     * @return {?}
     */
    unclaimTask(taskId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.unclaimTask(taskId))
            .catch(err => this.handleError(err));
    }
    /**
     * Update due date
     * @param {?} taskId
     * @param {?} updated
     * @return {?}
     */
    updateTask(taskId, updated) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.updateTask(taskId, updated))
            .catch(err => this.handleError(err));
    }
    /**
     * fetch the Task Audit information as a pdf
     * @param {?} taskId - the task id
     * @return {?}
     */
    fetchTaskAuditPdfById(taskId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.getTaskAuditPdf(taskId))
            .catch(err => this.handleError(err));
    }
    /**
     * fetch the Task Audit information in a json format
     * @param {?} taskId - the task id
     * @return {?}
     */
    fetchTaskAuditJsonById(taskId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.taskApi.getTaskAuditJson(taskId))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} requestNode
     * @return {?}
     */
    callApiTasksFiltered(requestNode) {
        return this.apiService.getInstance().activiti.taskApi.listTasks(requestNode);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    callApiTaskDetails(taskId) {
        return this.apiService.getInstance().activiti.taskApi.getTask(taskId);
    }
    /**
     * @param {?} task
     * @return {?}
     */
    callApiAddTask(task) {
        return this.apiService.getInstance().activiti.taskApi.addSubtask(task.parentTaskId, task);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    callApiDeleteTask(taskId) {
        return this.apiService.getInstance().activiti.taskApi.deleteTask(taskId);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    callApiTaskChecklist(taskId) {
        return this.apiService.getInstance().activiti.taskApi.getChecklist(taskId);
    }
    /**
     * @param {?} task
     * @return {?}
     */
    callApiCreateTask(task) {
        return this.apiService.getInstance().activiti.taskApi.createNewTask(task);
    }
    /**
     * @param {?} taskId
     * @param {?} requestNode
     * @return {?}
     */
    callApiAssignTask(taskId, requestNode) {
        return this.apiService.getInstance().activiti.taskApi.assignTask(taskId, requestNode);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        this.tasksListSubject.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
TaskListService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
TaskListService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFilterService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.tasksListSubject = new Subject$1();
        this.tasksList$ = this.tasksListSubject.asObservable();
    }
    /**
     * Create and return the default filters
     * @param {?} appId
     * @return {?}
     */
    createDefaultFilters(appId) {
        let /** @type {?} */ involvedTasksFilter = this.getInvolvedTasksFilterInstance(appId);
        let /** @type {?} */ involvedObservable = this.addFilter(involvedTasksFilter);
        let /** @type {?} */ myTasksFilter = this.getMyTasksFilterInstance(appId);
        let /** @type {?} */ myTaskObservable = this.addFilter(myTasksFilter);
        let /** @type {?} */ queuedTasksFilter = this.getQueuedTasksFilterInstance(appId);
        let /** @type {?} */ queuedObservable = this.addFilter(queuedTasksFilter);
        let /** @type {?} */ completedTasksFilter = this.getCompletedTasksFilterInstance(appId);
        let /** @type {?} */ completeObservable = this.addFilter(completedTasksFilter);
        return Observable$1.create(observer => {
            Observable$1.forkJoin(involvedObservable, myTaskObservable, queuedObservable, completeObservable).subscribe((res) => {
                let /** @type {?} */ filters = [];
                res.forEach((filter) => {
                    if (filter.name === involvedTasksFilter.name) {
                        filters.push(involvedTasksFilter);
                    }
                    else if (filter.name === myTasksFilter.name) {
                        filters.push(myTasksFilter);
                    }
                    else if (filter.name === queuedTasksFilter.name) {
                        filters.push(queuedTasksFilter);
                    }
                    else if (filter.name === completedTasksFilter.name) {
                        filters.push(completedTasksFilter);
                    }
                });
                observer.next(filters);
                observer.complete();
            }, (err) => {
                this.logService.error(err);
            });
        });
    }
    /**
     * Retrieve all the Tasks filters
     * @param {?=} appId
     * @return {?}
     */
    getTaskListFilters(appId) {
        return Observable$1.fromPromise(this.callApiTaskFilters(appId))
            .map((response) => {
            let /** @type {?} */ filters = [];
            response.data.forEach((filter) => {
                let /** @type {?} */ filterModel = new FilterRepresentationModel(filter);
                filters.push(filterModel);
            });
            return filters;
        }).catch(err => this.handleError(err));
    }
    /**
     * Retrieve the Tasks filter by id
     * @param {?} filterId - number - The id of the filter
     * @param {?=} appId - string - optional - The id of app
     * @return {?}
     */
    getTaskFilterById(filterId, appId) {
        return Observable$1.fromPromise(this.callApiTaskFilters(appId))
            .map((response) => {
            return response.data.find(filter => filter.id === filterId);
        }).catch(err => this.handleError(err));
    }
    /**
     * Retrieve the Tasks filter by name
     * @param {?} taskName - string - The name of the filter
     * @param {?=} appId
     * @return {?}
     */
    getTaskFilterByName(taskName, appId) {
        return Observable$1.fromPromise(this.callApiTaskFilters(appId))
            .map((response) => {
            return response.data.find(filter => filter.name === taskName);
        }).catch(err => this.handleError(err));
    }
    /**
     * Add a filter
     * @param {?} filter - FilterRepresentationModel
     * @return {?}
     */
    addFilter(filter) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.userFiltersApi.createUserTaskFilter(filter))
            .map(res => res)
            .map((response) => {
            return response;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?=} appId
     * @return {?}
     */
    callApiTaskFilters(appId) {
        if (appId) {
            return this.apiService.getInstance().activiti.userFiltersApi.getUserTaskFilters({ appId: appId });
        }
        else {
            return this.apiService.getInstance().activiti.userFiltersApi.getUserTaskFilters();
        }
    }
    /**
     * Return a static Involved filter instance
     * @param {?} appId
     * @return {?}
     */
    getInvolvedTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'Involved Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-align-left',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'involved' }
        });
    }
    /**
     * Return a static My task filter instance
     * @param {?} appId
     * @return {?}
     */
    getMyTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'My Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-inbox',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'assignee' }
        });
    }
    /**
     * Return a static Queued filter instance
     * @param {?} appId
     * @return {?}
     */
    getQueuedTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'Queued Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-record',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'candidate' }
        });
    }
    /**
     * Return a static Completed filter instance
     * @param {?} appId
     * @return {?}
     */
    getCompletedTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'Completed Tasks',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-ok-sign',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'completed', 'assignment': 'involved' }
        });
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        this.tasksListSubject.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
TaskFilterService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
TaskFilterService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChecklistComponent {
    /**
     * Constructor
     * @param {?} activitiTaskList
     * @param {?} dialog
     */
    constructor(activitiTaskList, dialog) {
        this.activitiTaskList = activitiTaskList;
        this.dialog = dialog;
        this.readOnly = false;
        this.checklistTaskCreated = new EventEmitter();
        this.checklistTaskDeleted = new EventEmitter();
        this.error = new EventEmitter();
        this.checklist = [];
        this.task$ = new Observable$1(observer => this.taskObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.task$.subscribe((task) => {
            this.checklist.push(task);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.getTaskChecklist(taskId.currentValue);
            return;
        }
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getTaskChecklist(taskId) {
        this.checklist = [];
        if (this.taskId) {
            this.activitiTaskList.getTaskChecklist(this.taskId).subscribe((res) => {
                res.forEach((task) => {
                    this.taskObserver.next(task);
                });
            }, (error) => {
                this.error.emit(error);
            });
        }
        else {
            this.checklist = [];
        }
    }
    /**
     * @return {?}
     */
    showDialog() {
        this.dialog.open(this.addNewDialog, { width: '350px' });
    }
    /**
     * @return {?}
     */
    add() {
        let /** @type {?} */ newTask = new TaskDetailsModel({
            name: this.taskName,
            parentTaskId: this.taskId,
            assignee: { id: this.assignee }
        });
        this.activitiTaskList.addTask(newTask).subscribe((res) => {
            this.checklist.push(res);
            this.checklistTaskCreated.emit(res);
            this.taskName = '';
        }, (error) => {
            this.error.emit(error);
        });
        this.cancel();
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    delete(taskId) {
        this.activitiTaskList.deleteTask(taskId).subscribe(() => {
            this.checklist = this.checklist.filter(check => check.id !== taskId);
            this.checklistTaskDeleted.emit(taskId);
        }, (error) => {
            this.error.emit(error);
        });
    }
    /**
     * @return {?}
     */
    cancel() {
        this.dialog.closeAll();
        // if (this.addNewDialog) {
        //     this.addNewDialog.nativeElement.close();
        // }
        this.taskName = '';
    }
}
ChecklistComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-checklist',
                template: `
      <div class="adf-checklist-control">
          <mat-chip-list id="checklist-label">
              <span class="activiti-label">{{ 'ADF_TASK_LIST.DETAILS.LABELS.CHECKLIST' | translate }}</span>
              <mat-chip class="adf-process-badge" color="accent" selected="true">{{checklist?.length}}</mat-chip>
          </mat-chip-list>


          <button mat-icon-button *ngIf="!readOnly" matTooltip="Add a checklist" [matTooltipPosition]="'before'" id="add-checklist" class="adf-add-to-checklist-button" (click)="showDialog()">
              <mat-icon>add</mat-icon>
          </button>
      </div>

      <div class="adf-checklist-menu-container" *ngIf="checklist?.length > 0">
          <mat-chip-list class="mat-chip-list-stacked">
              <mat-chip id="check-{{check.id}}" class="adf-checklist-chip" *ngFor="let check of checklist">
                  <span>{{check.name}}</span>
                  <button  *ngIf="!readOnly" mat-icon-button type="button" class="adf-checklist-cancel-button" (click)="delete(check.id)">
                      <mat-icon id="remove-{{check.id}}" matChipRemove>cancel</mat-icon>
                  </button>
              </mat-chip>
          </mat-chip-list>

      </div>
      <div *ngIf="checklist?.length === 0" id="checklist-none-message">
          {{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.NONE' | translate }}
      </div>

      <ng-template #dialog>
          <div class="adf-checklist-dialog" id="checklist-dialog">
              <h4 matDialogTitle id="add-checklist-title">New Check</h4>
              <mat-dialog-content>
                  <mat-form-field>
                      <input matInput placeholder="Name" [(ngModel)]="taskName" id="checklist-name"  data-automation-id="checklist-name">
                  </mat-form-field>
              </mat-dialog-content>
              <mat-dialog-actions class="adf-checklist-dialog-actions">
                  <button mat-button type="button" id="close-check-dialog" (click)="cancel()">Cancel</button>
                  <button mat-button type="button" id="add-check" (click)="add()">Add Checklist</button>
              </mat-dialog-actions>
          </div>
      </ng-template>
    `,
                styles: [`
      :host {
        width: 100%; }

      .activiti-label {
        font-weight: bolder; }

      .mat-form-field {
        width: 100%; }

      .adf-checklist-cancel-button {
        margin-top: -13px;
        margin-right: -13px;
        float: right; }

      .adf-checklist-chip {
        outline: none; }

      .adf-checklist-menu-container {
        margin-top: 10px; }

      #checklist-none-message {
        margin-top: 10px;
        color: rgba(0, 0, 0, 0.5); }

      .adf-checklist-control {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-pack: justify;
            -ms-flex-pack: justify;
                justify-content: space-between; }
        .adf-checklist-control .activiti-label {
          margin-top: 6px;
          margin-right: 10px; }
        .adf-checklist-control .adf-add-to-checklist-button {
          float: right; }

      .adf-checklist-dialog-actions {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-pack: end;
            -ms-flex-pack: end;
                justify-content: flex-end; }
    `],
                providers: [TaskListService]
            },] },
];
/**
 * @nocollapse
 */
ChecklistComponent.ctorParameters = () => [
    { type: TaskListService, },
    { type: MatDialog, },
];
ChecklistComponent.propDecorators = {
    'taskId': [{ type: Input },],
    'readOnly': [{ type: Input },],
    'assignee': [{ type: Input },],
    'checklistTaskCreated': [{ type: Output },],
    'checklistTaskDeleted': [{ type: Output },],
    'error': [{ type: Output },],
    'addNewDialog': [{ type: ViewChild, args: ['dialog',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDetailsComponent {
    /**
     * @param {?} taskListService
     * @param {?} authService
     * @param {?} peopleProcessService
     * @param {?} logService
     * @param {?} cardViewUpdateService
     * @param {?} dialog
     */
    constructor(taskListService, authService, peopleProcessService, logService, cardViewUpdateService, dialog) {
        this.taskListService = taskListService;
        this.authService = authService;
        this.peopleProcessService = peopleProcessService;
        this.logService = logService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.dialog = dialog;
        this.debugMode = false;
        this.showNextTask = true;
        this.showHeader = true;
        this.showHeaderContent = true;
        this.showInvolvePeople = true;
        this.showComments = true;
        this.showChecklist = true;
        this.showFormTitle = true;
        this.showFormCompleteButton = true;
        this.showFormSaveButton = true;
        this.readOnlyForm = false;
        this.showFormRefreshButton = true;
        this.fieldValidators = [];
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.formLoaded = new EventEmitter();
        this.taskCreated = new EventEmitter();
        this.taskDeleted = new EventEmitter();
        this.error = new EventEmitter();
        this.executeOutcome = new EventEmitter();
        this.assignTask = new EventEmitter();
        this.taskFormName = null;
        this.taskPeople = [];
        this.showAssignee = false;
        this.peopleSearch$ = new Observable$1(observer => this.peopleSearchObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.taskId) {
            this.loadDetails(this.taskId);
        }
        this.cardViewUpdateService.itemUpdated$.subscribe(this.updateTaskDetails.bind(this));
        this.cardViewUpdateService.itemClicked$.subscribe(this.clickTaskDetails.bind(this));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ taskId = changes.taskId;
        this.showAssignee = false;
        if (taskId && !taskId.currentValue) {
            this.reset();
        }
        else if (taskId && taskId.currentValue) {
            this.taskFormName = null;
            this.loadDetails(taskId.currentValue);
        }
    }
    /**
     * Reset the task details
     * @return {?}
     */
    reset() {
        this.taskDetails = null;
    }
    /**
     * Check if the task has a form
     * @return {?}
     */
    hasFormKey() {
        return (this.taskDetails
            && this.taskDetails.formKey
            && this.taskDetails.formKey !== 'null');
    }
    /**
     * @return {?}
     */
    isTaskActive() {
        return this.taskDetails && this.taskDetails.duration === null;
    }
    /**
     * Save a task detail and update it after a successful response
     *
     * @param {?} updateNotification
     * @return {?}
     */
    updateTaskDetails(updateNotification) {
        this.taskListService.updateTask(this.taskId, updateNotification.changed)
            .subscribe(() => {
            this.loadDetails(this.taskId);
        });
    }
    /**
     * @param {?} clickNotification
     * @return {?}
     */
    clickTaskDetails(clickNotification) {
        if (clickNotification.target.key === 'assignee') {
            this.showAssignee = true;
        }
    }
    /**
     * Load the activiti task details
     * @param {?} taskId
     * @return {?}
     */
    loadDetails(taskId) {
        this.taskPeople = [];
        this.readOnlyForm = false;
        if (taskId) {
            this.taskListService.getTaskDetails(taskId).subscribe((res) => {
                this.taskDetails = res;
                if (this.taskDetails.name === 'null') {
                    this.taskDetails.name = 'No name';
                }
                let /** @type {?} */ endDate = res.endDate;
                this.readOnlyForm = this.readOnlyForm ? this.readOnlyForm : !!(endDate && !isNaN(endDate.getTime()));
                if (this.taskDetails && this.taskDetails.involvedPeople) {
                    this.taskDetails.involvedPeople.forEach((user) => {
                        this.taskPeople.push(new UserProcessModel(user));
                    });
                }
            });
        }
    }
    /**
     * @return {?}
     */
    isAssigned() {
        return this.taskDetails.assignee ? true : false;
    }
    /**
     * @return {?}
     */
    isAssignedToMe() {
        return this.taskDetails.assignee.email === this.authService.getBpmUsername();
    }
    /**
     * Retrieve the next open task
     * @param {?} processInstanceId
     * @param {?} processDefinitionId
     * @return {?}
     */
    loadNextTask(processInstanceId, processDefinitionId) {
        let /** @type {?} */ requestNode = new TaskQueryRequestRepresentationModel({
            processInstanceId: processInstanceId,
            processDefinitionId: processDefinitionId
        });
        this.taskListService.getTasks(requestNode).subscribe((response) => {
            if (response && response.length > 0) {
                this.taskDetails = new TaskDetailsModel(response[0]);
            }
            else {
                this.reset();
            }
        }, (error) => {
            this.error.emit(error);
        });
    }
    /**
     * Complete button clicked
     * @return {?}
     */
    onComplete() {
        this.taskListService.completeTask(this.taskId).subscribe((res) => this.onFormCompleted(null));
    }
    /**
     * @param {?} content
     * @return {?}
     */
    onFormContentClick(content) {
        this.formContentClicked.emit(content);
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormSaved(form) {
        this.formSaved.emit(form);
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormCompleted(form) {
        this.formCompleted.emit(form);
        if (this.showNextTask && (this.taskDetails.processInstanceId || this.taskDetails.processDefinitionId)) {
            this.loadNextTask(this.taskDetails.processInstanceId, this.taskDetails.processDefinitionId);
        }
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormLoaded(form) {
        this.taskFormName = (form && form.name ? form.name : null);
        this.formLoaded.emit(form);
    }
    /**
     * @param {?} task
     * @return {?}
     */
    onChecklistTaskCreated(task) {
        this.taskCreated.emit(task);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    onChecklistTaskDeleted(taskId) {
        this.taskDeleted.emit(taskId);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    onFormError(error) {
        this.errorDialogRef = this.dialog.open(this.errorDialog, { width: '500px' });
        this.error.emit(error);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFormExecuteOutcome(event) {
        this.executeOutcome.emit(event);
    }
    /**
     * @return {?}
     */
    closeErrorDialog() {
        this.dialog.closeAll();
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    onClaimAction(taskId) {
        this.loadDetails(taskId);
    }
    /**
     * @return {?}
     */
    toggleHeaderContent() {
        this.showHeaderContent = !this.showHeaderContent;
    }
    /**
     * @return {?}
     */
    isCompletedTask() {
        return this.taskDetails && this.taskDetails.endDate ? true : undefined;
    }
    /**
     * @param {?} searchedWord
     * @return {?}
     */
    searchUser(searchedWord) {
        this.peopleProcessService.getWorkflowUsers(null, searchedWord)
            .subscribe((users) => {
            users = users.filter((user) => user.id !== this.taskDetails.assignee.id);
            this.peopleSearchObserver.next(users);
        }, error => this.logService.error('Could not load users'));
    }
    /**
     * @return {?}
     */
    onCloseSearch() {
        this.showAssignee = false;
    }
    /**
     * @param {?} selectedUser
     * @return {?}
     */
    assignTaskToUser(selectedUser) {
        this.taskListService.assignTask(this.taskDetails.id, selectedUser).subscribe((res) => {
            this.logService.info('Task Assigned to ' + selectedUser.email);
            this.assignTask.emit();
        });
        this.showAssignee = false;
    }
    /**
     * @return {?}
     */
    getTaskHeaderViewClass() {
        if (this.showAssignee) {
            return 'assign-edit-view';
        }
        else {
            return 'default-view';
        }
    }
    /**
     * @return {?}
     */
    isReadOnlyComment() {
        return (this.taskDetails && this.taskDetails.isCompleted()) && (this.taskPeople && this.taskPeople.length === 0);
    }
}
TaskDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-details',
                template: `
      <div *ngIf="!taskDetails">
          <ng-template *ngIf="noTaskDetailsTemplateComponent" ngFor [ngForOf]="[data]"
                       [ngForTemplate]="noTaskDetailsTemplateComponent">
              {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.NONE' | translate }}
          </ng-template>
          <div *ngIf="!noTaskDetailsTemplateComponent">
              {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.NONE' | translate }}
          </div>
      </div>
      <div *ngIf="taskDetails" class="adf-task-details">

          <div *ngIf="showHeader" class="adf-task-details-header">
              <h2 class="activiti-task-details__header">
                  <span>{{taskDetails.name || 'No name'}}</span>
              </h2>
          </div>

          <div class="adf-task-details-core"
              fxLayout="column"
              fxLayoutGap="8px"
              fxLayout.lt-lg="column">

              <div class="adf-task-details-core-form">
                  <div *ngIf="isAssigned()">
                      <adf-form *ngIf="hasFormKey()" #activitiForm
                                [showDebugButton]="debugMode"
                                [taskId]="taskDetails.id"
                                [showTitle]="showFormTitle"
                                [showRefreshButton]="showFormRefreshButton"
                                [showCompleteButton]="showFormCompleteButton"
                                [disableCompleteButton]="!isAssignedToMe()"
                                [showSaveButton]="showFormSaveButton"
                                [readOnly]="readOnlyForm"
                                [fieldValidators]="fieldValidators"
                                (formSaved)='onFormSaved($event)'
                                (formCompleted)='onFormCompleted($event)'
                                (formContentClicked)='onFormContentClick($event)'
                                (formLoaded)='onFormLoaded($event)'
                                (error)='onFormError($event)'
                                (executeOutcome)='onFormExecuteOutcome($event)'>
                          <div empty-form><h3 class="adf-task-title">Please select a Task</h3></div>
                      </adf-form>
                  </div>
                  <div *ngIf="!isAssigned()">
                      {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.CLAIM' | translate }}
                  </div>
                  <button mat-raised-button class="activiti-task-details__action-button"
                          *ngIf="!hasFormKey() && isTaskActive()" (click)="onComplete()">
                      {{ 'ADF_TASK_LIST.DETAILS.BUTTON.COMPLETE' | translate }}
                  </button>
              </div>
              <div class="adf-task-details-core-sidebar">
                  <adf-info-drawer *ngIf="showHeaderContent" title="{{ 'ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TITLE' | translate }}" class="adf-task-details-core-sidebar-drawer">
                      <adf-info-drawer-tab label="{{ 'ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TAB_DETAILS_TITLE' | translate }}">
                          <div class="assignment-container" *ngIf="showAssignee">
                              <adf-people-search
                                  (searchPeople)="searchUser($event)"
                                  (success)="assignTaskToUser($event)"
                                  (closeSearch)="onCloseSearch()"
                                  [results]="peopleSearch$">
                                  <ng-container people-search-title>{{ 'ADF_TASK_LIST.DETAILS.LABELS.ADD_ASSIGNEE' | translate }}
                                  </ng-container>
                                  <ng-container people-search-action-label>{{ 'ADF_TASK_LIST.PEOPLE.ADD_ASSIGNEE' | translate }}
                                  </ng-container>
                              </adf-people-search>
                          </div>
                          <adf-task-header
                              [class]="getTaskHeaderViewClass()"
                              [taskDetails]="taskDetails"
                              [formName]="taskFormName"
                              (claim)="onClaimAction($event)"
                              (unclaim)="onClaimAction($event)">
                          </adf-task-header>
                          <adf-people *ngIf="showInvolvePeople" #people
                                      [people]="taskPeople"
                                      [readOnly]="readOnlyForm"
                                      [taskId]="taskDetails.id">
                          </adf-people>
                      </adf-info-drawer-tab>

                      <adf-info-drawer-tab label="{{ 'ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TAB_ACTIVITY_TITLE' | translate }}">
                          <mat-card *ngIf="showComments">
                              <mat-card-content>
                                  <adf-comments #activiticomments
                                                [readOnly]="isReadOnlyComment()"
                                                [taskId]="taskDetails.id">
                                  </adf-comments>
                              </mat-card-content>
                          </mat-card>
                      </adf-info-drawer-tab>

                  </adf-info-drawer>

                  <div *ngIf="showHeaderContent" class="adf-task-details-core-sidebar-checklist">
                      <div *ngIf="showChecklist">
                          <adf-checklist #activitichecklist
                                         [readOnly]="readOnlyForm"
                                         [taskId]="taskDetails.id"
                                         [assignee]="taskDetails?.assignee?.id"
                                         (checklistTaskCreated)="onChecklistTaskCreated($event)"
                                         (checklistTaskDeleted)="onChecklistTaskDeleted($event)">
                          </adf-checklist>
                      </div>
                  </div>
              </div>
          </div>

          <ng-template #errorDialog>
              <h3 matDialogTitle>{{'ADF_TASK_LIST.DETAILS.ERROR.TITLE'|translate}}</h3>
              <mat-dialog-content>
                  <p>{{'ADF_TASK_LIST.DETAILS.ERROR.DESCRIPTION'|translate}}</p>
              </mat-dialog-content>
              <mat-dialog-actions>
                  <button mat-button type="button" (click)="closeErrorDialog()">{{'ADF_TASK_LIST.DETAILS.ERROR.CLOSE'|translate}}
                  </button>
              </mat-dialog-actions>
          </ng-template>

      </div>
    `,
                styles: [`
      :host {
        width: 100%; }

      .error-dialog h3 {
        margin: 16px 0; }

      .activiti-task-details__header {
        -ms-flex-item-align: end;
            align-self: flex-end;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        font-size: 24px;
        font-weight: 300;
        line-height: normal;
        overflow: hidden;
        margin: 8px 0 16px 0;
        cursor: pointer;
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none; }

      .activiti-task-details__action-button {
        text-transform: uppercase; }

      adf-people ::ng-deep .assignment-top-container {
        background-color: #fff; }

      .assignment-container {
        background: #fff;
        border: 1px solid #e1e1e1;
        padding: 10px 20px;
        width: auto; }

      adf-task-header.assign-edit-view ::ng-deep adf-card-view ::ng-deep .adf-property[data-automation-id="header-assignee"] {
        display: none; }

      .adf-task-details-header {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-pack: justify;
            -ms-flex-pack: justify;
                justify-content: space-between; }
        .adf-task-details-header-toggle {
          position: relative;
          top: 10px;
          margin-right: 2px;
          height: 23px;
          cursor: pointer;
          user-select: none;
          -moz-user-select: none;
          -webkit-user-select: none;
          -ms-user-select: none; }

      .adf-task-details-core {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-pack: justify;
            -ms-flex-pack: justify;
                justify-content: space-between; }
        @media screen and (max-width: 1279px) {
          .adf-task-details-core-sidebar-drawer {
            margin-left: 0px; } }
        .adf-task-details-core-sidebar-checklist {
          margin-top: 30px;
          padding-left: 20px;
          padding-right: 20px; }
        .adf-task-details-core-form {
          -webkit-box-flex: 1;
              -ms-flex-positive: 1;
                  flex-grow: 1; }
          .adf-task-details-core-form ::ng-deep .adf-form-debug-container {
            padding: 20px 0 0 0; }
            .adf-task-details-core-form ::ng-deep .adf-form-debug-container .mat-slide-toggle {
              float: right; }
              .adf-task-details-core-form ::ng-deep .adf-form-debug-container .mat-slide-toggle + div {
                background-color: black;
                padding: 20px;
                clear: both;
                margin-top: 30px;
                color: white; }
          .adf-task-details-core-form ::ng-deep .mat-tab-label {
            -webkit-box-flex: 1;
                -ms-flex-positive: 1;
                    flex-grow: 1; }
    `],
                providers: [
                    CardViewUpdateService
                ]
            },] },
];
/**
 * @nocollapse
 */
TaskDetailsComponent.ctorParameters = () => [
    { type: TaskListService, },
    { type: AuthenticationService, },
    { type: PeopleProcessService, },
    { type: LogService, },
    { type: CardViewUpdateService, },
    { type: MatDialog, },
];
TaskDetailsComponent.propDecorators = {
    'activiticomments': [{ type: ViewChild, args: ['activiticomments',] },],
    'activitichecklist': [{ type: ViewChild, args: ['activitichecklist',] },],
    'errorDialog': [{ type: ViewChild, args: ['errorDialog',] },],
    'debugMode': [{ type: Input },],
    'taskId': [{ type: Input },],
    'showNextTask': [{ type: Input },],
    'showHeader': [{ type: Input },],
    'showHeaderContent': [{ type: Input },],
    'showInvolvePeople': [{ type: Input },],
    'showComments': [{ type: Input },],
    'showChecklist': [{ type: Input },],
    'showFormTitle': [{ type: Input },],
    'showFormCompleteButton': [{ type: Input },],
    'showFormSaveButton': [{ type: Input },],
    'readOnlyForm': [{ type: Input },],
    'showFormRefreshButton': [{ type: Input },],
    'fieldValidators': [{ type: Input },],
    'formSaved': [{ type: Output },],
    'formCompleted': [{ type: Output },],
    'formContentClicked': [{ type: Output },],
    'formLoaded': [{ type: Output },],
    'taskCreated': [{ type: Output },],
    'taskDeleted': [{ type: Output },],
    'error': [{ type: Output },],
    'executeOutcome': [{ type: Output },],
    'assignTask': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoTaskDetailsTemplateDirective {
    /**
     * @param {?} activitiTaskDetails
     */
    constructor(activitiTaskDetails) {
        this.activitiTaskDetails = activitiTaskDetails;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.activitiTaskDetails.noTaskDetailsTemplateComponent = this.template;
    }
}
NoTaskDetailsTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-task-details-template'
            },] },
];
/**
 * @nocollapse
 */
NoTaskDetailsTemplateDirective.ctorParameters = () => [
    { type: TaskDetailsComponent, },
];
NoTaskDetailsTemplateDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * This object represent of the StartTaskModel.
 *
 *
 * @returns {StartTaskModel} .
 */
class StartTaskModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.name = obj && obj.name || null;
        this.description = obj && obj.description || null;
        this.assignee = obj && obj.assignee ? new UserProcessModel(obj.assignee) : null;
        this.dueDate = obj && obj.dueDate || null;
        this.formKey = obj && obj.formKey || null;
        this.category = obj && obj.category || null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartTaskComponent {
    /**
     * Constructor
     * @param {?} taskService
     * @param {?} peopleService
     * @param {?} dateAdapter
     * @param {?} preferences
     * @param {?} logService
     */
    constructor(taskService, peopleService, dateAdapter, preferences, logService) {
        this.taskService = taskService;
        this.peopleService = peopleService;
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.logService = logService;
        this.FORMAT_DATE = 'DD/MM/YYYY';
        this.success = new EventEmitter();
        this.cancel = new EventEmitter();
        this.error = new EventEmitter();
        this.people = [];
        this.startTaskmodel = new StartTaskModel();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        this.loadFormsTask();
        this.getUsers();
    }
    /**
     * @return {?}
     */
    start() {
        if (this.startTaskmodel.name) {
            if (this.appId) {
                this.startTaskmodel.category = this.appId.toString();
            }
            this.taskService.createNewTask(new TaskDetailsModel(this.startTaskmodel))
                .switchMap((createRes) => this.attachForm(createRes.id, this.formKey).defaultIfEmpty(createRes)
                .switchMap((attachRes) => this.assignTaskByUserId(createRes.id, this.assigneeId).defaultIfEmpty(attachRes ? attachRes : createRes)))
                .subscribe((res) => {
                this.success.emit(res);
            }, (err) => {
                this.error.emit(err);
                this.logService.error('An error occurred while creating new task');
            });
        }
    }
    /**
     * @param {?} taskId
     * @param {?} formKey
     * @return {?}
     */
    attachForm(taskId, formKey) {
        let /** @type {?} */ response = Observable$1.of();
        if (taskId && formKey) {
            response = this.taskService.attachFormToATask(taskId, formKey);
        }
        return response;
    }
    /**
     * @param {?} taskId
     * @param {?} userId
     * @return {?}
     */
    assignTaskByUserId(taskId, userId) {
        let /** @type {?} */ response = Observable$1.of();
        if (taskId && userId) {
            response = this.taskService.assignTaskByUserId(taskId, userId);
        }
        return response;
    }
    /**
     * @return {?}
     */
    onCancel() {
        this.cancel.emit();
    }
    /**
     * @return {?}
     */
    loadFormsTask() {
        this.taskService.getFormList().subscribe((res) => {
            this.forms = res;
        }, (err) => {
            this.error.emit(err);
            this.logService.error('An error occurred while trying to get the forms');
        });
    }
    /**
     * @return {?}
     */
    getUsers() {
        this.peopleService.getWorkflowUsers().subscribe((users) => {
            this.people = users;
        }, (err) => {
            this.error.emit(err);
            this.logService.error('Could not load users');
        });
    }
    /**
     * @param {?} user
     * @return {?}
     */
    isUserNameEmpty(user) {
        return !user || (this.isEmpty(user.firstName) && this.isEmpty(user.lastName));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    isEmpty(data) {
        return data === undefined || data === null || data.trim().length === 0;
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?=} delimiter
     * @return {?}
     */
    getDisplayUser(firstName, lastName, delimiter = '-') {
        firstName = (firstName !== null ? firstName : '');
        lastName = (lastName !== null ? lastName : '');
        return firstName + delimiter + lastName;
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        this.dateError = false;
        if (newDateValue) {
            let /** @type {?} */ momentDate = moment$1(newDateValue, this.FORMAT_DATE, true);
            if (!momentDate.isValid()) {
                this.dateError = true;
            }
        }
    }
}
StartTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-task',
                template: `
      <mat-card class="adf-new-task-layout-card">
          <mat-grid-list cols="1" rowHeight="60px">
              <mat-grid-tile>
                  <div class="adf-new-task-heading">{{'ADF_TASK_LIST.START_TASK.FORM.TITLE'|translate}}</div>
              </mat-grid-tile>
          </mat-grid-list>
          <mat-card-content>
              <mat-grid-list cols="1" rowHeight="80px">
                  <mat-grid-tile>
                      <mat-form-field class="adf-new-task-text-width">
                          <input matInput placeholder="{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.NAME'|translate}}"
                                 [(ngModel)]="startTaskmodel.name" required id="name_id">
                      </mat-form-field>
                  </mat-grid-tile>
              </mat-grid-list>
              <mat-grid-list cols="1" rowHeight="80px">
                  <mat-grid-tile>
                      <mat-form-field class="adf-new-task-text-width">
                          <textarea matInput placeholder="{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.DESCRIPTION'|translate}}"
                                    [(ngModel)]="startTaskmodel.description" id="description_id"></textarea>
                      </mat-form-field>
                  </mat-grid-tile>
              </mat-grid-list>
              <mat-grid-list cols="2" rowHeight="80px">
                  <mat-grid-tile>
                      <mat-form-field class="adf-start-task-input-container">
                          <input matInput
                                 [matDatepicker]="taskDatePicker"
                                 (keydown)="true"
                                 (focusout)="onDateChanged($event.srcElement.value)"
                                 placeholder="{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.DATE'|translate}}"
                                 [(ngModel)]="startTaskmodel.dueDate" id="date_id">
                          <mat-datepicker-toggle matSuffix [for]="taskDatePicker"></mat-datepicker-toggle>
                      </mat-form-field>
                      <mat-datepicker #taskDatePicker [touchUi]="true"
                                     (dateChanged)="onDateChanged($event)"></mat-datepicker>
                      <div class="adf-error-text-container">
                          <div *ngIf="dateError">
                              <div class="adf-error-text">{{'ADF_TASK_LIST.START_TASK.FORM.DATE.ERROR'|translate}}</div>
                              <mat-icon class="adf-error-icon">warning</mat-icon>
                          </div>
                      </div>
                  </mat-grid-tile>
                  <mat-grid-tile>
                    <mat-form-field class="adf-start-task-input-container">
                      <mat-select placeholder="{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.ASSIGNEE'|translate}}" id="assignee_id"
                                 class="adf-mat-select" [(ngModel)]="assigneeId">
                          <mat-option>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.NONE'|translate}}</mat-option>
                          <span *ngFor="let user of people">
                              <mat-option [value]="user.id" *ngIf="!isUserNameEmpty(user)">{{ getDisplayUser(user.firstName,
                                  user.lastName, ' ')}}
                              </mat-option>
                          </span>
                      </mat-select>
                    </mat-form-field>
                  </mat-grid-tile>
              </mat-grid-list>
              <mat-grid-list cols="2" rowHeight="80px">
                  <mat-grid-tile>
                      <mat-form-field class="adf-start-task-input-container">
                          <mat-select placeholder="{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.FORM'|translate}}" id="form_id" [(ngModel)]="formKey">
                              <mat-option>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.NONE'|translate}}</mat-option>
                              <mat-option *ngFor="let form of forms" [value]="form.id">{{ form.name }}</mat-option>
                          </mat-select>
                      </mat-form-field>
                  </mat-grid-tile>
                  <mat-grid-tile></mat-grid-tile>
              </mat-grid-list>
          </mat-card-content>
          <mat-card-actions>
              <mat-grid-list cols="1" rowHeight="60px">
                  <mat-grid-tile>
                      <div class="adf-new-task-footer">
                          <button mat-button (click)="onCancel()" id="button-cancle">
                              {{'ADF_TASK_LIST.START_TASK.FORM.ACTION.CANCEL'|translate}}
                          </button>
                          <button mat-button [disabled]="!startTaskmodel.name || dateError" (click)="start()" id="button-start">
                              {{'ADF_TASK_LIST.START_TASK.FORM.ACTION.START'|translate}}
                          </button>
                      </div>
                  </mat-grid-tile>
              </mat-grid-list>
          </mat-card-actions>
      </mat-card>
    `,
                styles: [`

    `],
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: MOMENT_DATE_FORMATS }
                ],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
StartTaskComponent.ctorParameters = () => [
    { type: TaskListService, },
    { type: PeopleProcessService, },
    { type: DateAdapter, },
    { type: UserPreferencesService, },
    { type: LogService, },
];
StartTaskComponent.propDecorators = {
    'appId': [{ type: Input },],
    'success': [{ type: Output },],
    'cancel': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JSON_FORMAT = 'json';
const PDF_FORMAT = 'pdf';
class TaskAuditDirective {
    /**
     *
     * @param {?} contentService
     * @param {?} taskListService
     */
    constructor(contentService, taskListService) {
        this.contentService = contentService;
        this.taskListService = taskListService;
        this.fileName = 'Audit';
        this.format = 'pdf';
        this.download = true;
        this.clicked = new EventEmitter();
        this.error = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.isValidType()) {
            this.setDefaultFormatType();
        }
    }
    /**
     * @return {?}
     */
    isValidType() {
        if (this.format && (this.isJsonFormat() || this.isPdfFormat())) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    setDefaultFormatType() {
        this.format = PDF_FORMAT;
    }
    /**
     * fetch the audit information in the requested format
     * @return {?}
     */
    fetchAuditInfo() {
        if (this.isPdfFormat()) {
            this.taskListService.fetchTaskAuditPdfById(this.taskId).subscribe((blob) => {
                this.audit = blob;
                if (this.download) {
                    this.contentService.downloadBlob(this.audit, this.fileName + '.pdf');
                }
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }, (err) => {
                this.error.emit(err);
            });
        }
        else {
            this.taskListService.fetchTaskAuditJsonById(this.taskId).subscribe((res) => {
                this.audit = res;
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    /**
     * @return {?}
     */
    onClickAudit() {
        this.fetchAuditInfo();
    }
    /**
     * @return {?}
     */
    isJsonFormat() {
        return this.format === JSON_FORMAT;
    }
    /**
     * @return {?}
     */
    isPdfFormat() {
        return this.format === PDF_FORMAT;
    }
}
TaskAuditDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-task-audit]',
                host: {
                    'role': 'button',
                    '(click)': 'onClickAudit()'
                }
            },] },
];
/**
 * @nocollapse
 */
TaskAuditDirective.ctorParameters = () => [
    { type: ContentService, },
    { type: TaskListService, },
];
TaskAuditDirective.propDecorators = {
    'taskId': [{ type: Input, args: ['task-id',] },],
    'fileName': [{ type: Input },],
    'format': [{ type: Input },],
    'download': [{ type: Input },],
    'clicked': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFiltersComponent {
    /**
     * @param {?} taskFilterService
     * @param {?} taskListService
     * @param {?} appsProcessService
     */
    constructor(taskFilterService, taskListService, appsProcessService) {
        this.taskFilterService = taskFilterService;
        this.taskListService = taskListService;
        this.appsProcessService = appsProcessService;
        this.filterClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.hasIcon = true;
        this.filters = [];
        this.filter$ = new Observable$1(observer => this.filterObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.filter$.subscribe((filter) => {
            this.filters.push(filter);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ appId = changes['appId'];
        if (appId && (appId.currentValue || appId.currentValue === null)) {
            this.getFiltersByAppId(appId.currentValue);
            return;
        }
        let /** @type {?} */ appName = changes['appName'];
        if (appName && appName !== null && appName.currentValue) {
            this.getFiltersByAppName(appName.currentValue);
            return;
        }
        this.getFiltersByAppId();
    }
    /**
     * Return the task list filtered by appId or by appName
     * @param {?=} appId
     * @param {?=} appName
     * @return {?}
     */
    getFilters(appId, appName) {
        if (appName) {
            this.getFiltersByAppName(appName);
        }
        else {
            this.getFiltersByAppId(appId);
        }
    }
    /**
     * Return the filter list filtered by appId
     * @param {?=} appId - optional
     * @return {?}
     */
    getFiltersByAppId(appId) {
        this.taskFilterService.getTaskListFilters(appId).subscribe((res) => {
            if (res.length === 0 && this.isFilterListEmpty()) {
                this.taskFilterService.createDefaultFilters(appId).subscribe((resDefault) => {
                    this.resetFilter();
                    resDefault.forEach((filter) => {
                        this.filterObserver.next(filter);
                    });
                    this.selectTaskFilter(this.filterParam, this.filters);
                    this.success.emit(resDefault);
                }, (errDefault) => {
                    this.error.emit(errDefault);
                });
            }
            else {
                this.resetFilter();
                res.forEach((filter) => {
                    this.filterObserver.next(filter);
                });
                this.selectTaskFilter(this.filterParam, this.filters);
                this.success.emit(res);
            }
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * Return the filter list filtered by appName
     * @param {?} appName
     * @return {?}
     */
    getFiltersByAppName(appName) {
        this.appsProcessService.getDeployedApplicationsByName(appName).subscribe(application => {
            this.getFiltersByAppId(application.id);
            this.selectTaskFilter(this.filterParam, this.filters);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * Pass the selected filter as next
     * @param {?} filter
     * @return {?}
     */
    selectFilter(filter) {
        this.currentFilter = filter;
        this.filterClick.emit(filter);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    selectFilterWithTask(taskId) {
        let /** @type {?} */ filteredFilterList = [];
        this.taskListService.getFilterForTaskById(taskId, this.filters).subscribe((filter) => {
            filteredFilterList.push(filter);
        }, (err) => {
            this.error.emit(err);
        }, () => {
            if (filteredFilterList.length > 0) {
                this.selectTaskFilter(new FilterParamsModel({ name: 'My Tasks' }), filteredFilterList);
                this.filterClick.emit(this.currentFilter);
            }
        });
    }
    /**
     * Select the first filter of a list if present
     * @param {?} filterParam
     * @param {?} filteredFilterList
     * @return {?}
     */
    selectTaskFilter(filterParam, filteredFilterList) {
        let /** @type {?} */ findTaskFilter;
        if (filterParam) {
            filteredFilterList.filter((taskFilter, index) => {
                if (filterParam.name && filterParam.name.toLowerCase() === taskFilter.name.toLowerCase() ||
                    filterParam.id === taskFilter.id.toString()
                    || filterParam.index === index) {
                    findTaskFilter = taskFilter;
                }
            });
        }
        if (findTaskFilter) {
            this.currentFilter = findTaskFilter;
        }
        else {
            this.selectDefaultTaskFilter(filteredFilterList);
        }
    }
    /**
     * Select as default task filter the first in the list
     * @param {?} filteredFilterList
     * @return {?}
     */
    selectDefaultTaskFilter(filteredFilterList) {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    /**
     * Return the current task
     * @return {?}
     */
    getCurrentFilter() {
        return this.currentFilter;
    }
    /**
     * Check if the filter list is empty
     * @return {?}
     */
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    /**
     * Reset the filters properties
     * @return {?}
     */
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
}
TaskFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-filters, taskListService-filters',
                template: `
      <div class="menu-container">
          <mat-list>
              <mat-list-item (click)="selectFilter(filter)" *ngFor="let filter of filters"
                            class="adf-filters__entry" [class.active]="currentFilter === filter">
                  <mat-icon *ngIf="hasIcon" matListIcon class="adf-filters__entry-icon">assignment</mat-icon>
                  <span matLine [attr.data-automation-id]="filter.name + '_filter'">{{filter.name}}</span>
              </mat-list-item>
          </mat-list>
      </div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
TaskFiltersComponent.ctorParameters = () => [
    { type: TaskFilterService, },
    { type: TaskListService, },
    { type: AppsProcessService, },
];
TaskFiltersComponent.propDecorators = {
    'filterParam': [{ type: Input },],
    'filterClick': [{ type: Output },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'appId': [{ type: Input },],
    'appName': [{ type: Input },],
    'hasIcon': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskHeaderComponent {
    /**
     * @param {?} activitiTaskService
     * @param {?} bpmUserService
     * @param {?} logService
     */
    constructor(activitiTaskService, bpmUserService, logService) {
        this.activitiTaskService = activitiTaskService;
        this.bpmUserService = bpmUserService;
        this.logService = logService;
        this.formName = null;
        this.claim = new EventEmitter();
        this.unclaim = new EventEmitter();
        this.inEdit = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.loadCurrentBpmUserId();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.refreshData();
    }
    /**
     * Refresh the card data
     * @return {?}
     */
    refreshData() {
        if (this.taskDetails) {
            const /** @type {?} */ parentInfoMap = this.getParentInfo();
            this.properties = [
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.ASSIGNEE',
                    value: this.taskDetails.getFullName(),
                    key: 'assignee',
                    default: 'ADF_TASK_LIST.PROPERTIES.ASSIGNEE_DEFAULT',
                    clickable: !this.isCompleted()
                }),
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.STATUS',
                    value: this.getTaskStatus(),
                    key: 'status'
                }),
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.PRIORITY',
                    value: this.taskDetails.priority,
                    key: 'priority'
                }),
                new CardViewDateItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.DUE_DATE',
                    value: this.taskDetails.dueDate,
                    key: 'dueDate',
                    default: 'ADF_TASK_LIST.PROPERTIES.DUE_DATE_DEFAULT',
                    editable: true
                }),
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.CATEGORY',
                    value: this.taskDetails.category,
                    key: 'category',
                    default: 'ADF_TASK_LIST.PROPERTIES.CATEGORY_DEFAULT'
                }),
                new CardViewMapItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.PARENT_NAME',
                    value: parentInfoMap, key: 'parentName',
                    default: 'ADF_TASK_LIST.PROPERTIES.PARENT_NAME_DEFAULT',
                    clickable: true
                }),
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.CREATED_BY',
                    value: this.taskDetails.getFullName(),
                    key: 'created-by'
                }),
                new CardViewDateItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.CREATED',
                    value: this.taskDetails.created,
                    key: 'created'
                }),
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.ID',
                    value: this.taskDetails.id,
                    key: 'id'
                }),
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.DESCRIPTION',
                    value: this.taskDetails.description,
                    key: 'description',
                    default: 'ADF_TASK_LIST.PROPERTIES.DESCRIPTION_DEFAULT',
                    multiline: true,
                    editable: true
                }),
                new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.FORM_NAME',
                    value: this.formName,
                    key: 'formName',
                    default: 'ADF_TASK_LIST.PROPERTIES.FORM_NAME_DEFAULT'
                })
            ];
        }
    }
    /**
     * Loads current bpm userId
     * @return {?}
     */
    loadCurrentBpmUserId() {
        this.bpmUserService.getCurrentUserInfo().subscribe((res) => {
            this.currentUserId = res ? +res.id : null;
        });
    }
    /**
     * Return the process parent information
     * @return {?}
     */
    getParentInfo() {
        if (this.taskDetails.processInstanceId && this.taskDetails.processDefinitionName) {
            return new Map([[this.taskDetails.processInstanceId, this.taskDetails.processDefinitionName]]);
        }
    }
    /**
     * Does the task have an assignee
     * @return {?}
     */
    hasAssignee() {
        return !!this.taskDetails.assignee ? true : false;
    }
    /**
     * Returns true if the task is assigne to logged in user
     * @param {?} userId
     * @return {?}
     */
    isAssignedTo(userId) {
        return this.hasAssignee() ? this.taskDetails.assignee.id === userId : false;
    }
    /**
     * Return true if the task assigned
     * @return {?}
     */
    isAssignedToCurrentUser() {
        return this.hasAssignee() && this.isAssignedTo(this.currentUserId);
    }
    /**
     * Return true if the user is a candidate member
     * @return {?}
     */
    isCandidateMember() {
        return this.taskDetails.managerOfCandidateGroup || this.taskDetails.memberOfCandidateGroup || this.taskDetails.memberOfCandidateUsers;
    }
    /**
     * Return true if the task claimable
     * @return {?}
     */
    isTaskClaimable() {
        return !this.hasAssignee() && this.isCandidateMember();
    }
    /**
     * Return true if the task claimed by candidate member.
     * @return {?}
     */
    isTaskClaimedByCandidateMember() {
        return this.isCandidateMember() && this.isAssignedToCurrentUser() && !this.isCompleted();
    }
    /**
     * Returns task's status
     * @return {?}
     */
    getTaskStatus() {
        return (this.taskDetails && this.taskDetails.isCompleted()) ? 'Completed' : 'Running';
    }
    /**
     * Claim task
     *
     * @param {?} taskId
     * @return {?}
     */
    claimTask(taskId) {
        this.activitiTaskService.claimTask(taskId).subscribe((res) => {
            this.logService.info('Task claimed');
            this.claim.emit(taskId);
        });
    }
    /**
     * Unclaim task
     *
     * @param {?} taskId
     * @return {?}
     */
    unclaimTask(taskId) {
        this.activitiTaskService.unclaimTask(taskId).subscribe((res) => {
            this.logService.info('Task unclaimed');
            this.unclaim.emit(taskId);
        });
    }
    /**
     * Returns true if the task is completed
     * @return {?}
     */
    isCompleted() {
        return this.taskDetails && !!this.taskDetails.endDate;
    }
}
TaskHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-header',
                template: `
      <mat-card *ngIf="taskDetails" class="adf-card-container">
          <mat-card-content>
              <adf-card-view [properties]="properties" [editable]="!isCompleted()"></adf-card-view>
          </mat-card-content>

          <mat-card-actions class="adf-controls">
              <button *ngIf="isTaskClaimedByCandidateMember()" mat-button data-automation-id="header-unclaim-button" id="unclaim-task" (click)="unclaimTask(taskDetails.id)" class="adf-claim-controls">{{ 'ADF_TASK_LIST.DETAILS.BUTTON.UNCLAIM' | translate }}
              </button>
              <button *ngIf="isTaskClaimable()" mat-button data-automation-id="header-claim-button" id="claim-task" (click)="claimTask(taskDetails.id)" class="adf-claim-controls">{{ 'ADF_TASK_LIST.DETAILS.BUTTON.CLAIM' | translate }}
              </button>
          </mat-card-actions>
      </mat-card>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
TaskHeaderComponent.ctorParameters = () => [
    { type: TaskListService, },
    { type: BpmUserService, },
    { type: LogService, },
];
TaskHeaderComponent.propDecorators = {
    'formName': [{ type: Input },],
    'taskDetails': [{ type: Input },],
    'claim': [{ type: Output },],
    'unclaim': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let taskPresetsDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'created',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.CREATED',
            'cssClass': 'hidden',
            'sortable': true
        },
        {
            'key': 'assignee',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.ASSIGNEE',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_SIZE = 5;
class TaskListComponent {
    /**
     * @param {?} taskListService
     * @param {?} appConfig
     */
    constructor(taskListService, appConfig) {
        this.taskListService = taskListService;
        this.appConfig = appConfig;
        this.selectionMode = 'single'; // none|single|multiple
        this.multiselect = false;
        this.rowClick = new EventEmitter();
        this.rowsSelected = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.layoutPresets = {};
        this.page = 0;
        this.size = DEFAULT_SIZE;
        this.isLoading = true;
        /**
         * Toggles custom data source mode.
         * When enabled the component reloads data from it's current source instead of the server side.
         * This allows generating and displaying custom data sets (i.e. filtered out content).
         *
         * \@memberOf TaskListComponent
         */
        this.hasCustomDataSource = false;
        this.isStreamLoaded = false;
    }
    /**
     * @return {?}
     */
    initStream() {
        if (!this.isStreamLoaded) {
            this.isStreamLoaded = true;
            this.taskListService.tasksList$.subscribe((tasks) => {
                let /** @type {?} */ instancesRow = this.createDataRow(tasks.data);
                this.renderInstances(instancesRow);
                this.selectTask(this.landingTaskId);
                this.success.emit(tasks);
                this.isLoading = false;
            }, (error) => {
                this.error.emit(error);
                this.isLoading = false;
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.data === undefined) {
            this.data = new ObjectDataTableAdapter();
        }
        this.initStream();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.loadLayoutPresets();
        this.setupSchema();
    }
    /**
     * Setup html-based (html definitions) or code behind (data adapter) schema.
     * If component is assigned with an empty data adater the default schema settings applied.
     * @return {?}
     */
    setupSchema() {
        let /** @type {?} */ schema = [];
        if (this.columnList && this.columnList.columns && this.columnList.columns.length > 0) {
            schema = this.columnList.columns.map(c => /** @type {?} */ (c));
        }
        if (!this.data) {
            this.data = new ObjectDataTableAdapter([], schema.length > 0 ? schema : this.presetColumn ? this.getLayoutPreset(this.presetColumn) : this.getLayoutPreset());
        }
        else {
            if (schema && schema.length > 0) {
                this.data.setColumns(schema);
            }
            else if (this.data.getColumns().length === 0) {
                this.presetColumn ? this.setupDefaultColumns(this.presetColumn) : this.setupDefaultColumns();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.initStream();
        if (this.isPropertyChanged(changes)) {
            this.reload();
        }
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    setCustomDataSource(rows) {
        if (this.data) {
            this.data.setRows(rows);
            this.hasCustomDataSource = true;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    isPropertyChanged(changes) {
        let /** @type {?} */ changed = true;
        let /** @type {?} */ landingTaskId = changes['landingTaskId'];
        if (landingTaskId && landingTaskId.currentValue && this.isEqualToCurrentId(landingTaskId.currentValue)) {
            changed = false;
        }
        return changed;
    }
    /**
     * @return {?}
     */
    reload() {
        if (!this.hasCustomDataSource) {
            this.requestNode = this.createRequestNode();
            this.load(this.requestNode);
        }
    }
    /**
     * @param {?} requestNode
     * @return {?}
     */
    load(requestNode) {
        this.isLoading = true;
        this.loadTasksByState().subscribe();
    }
    /**
     * @return {?}
     */
    loadTasksByState() {
        return this.requestNode.state === 'all'
            ? this.taskListService.findAllTasksWithoutState(this.requestNode)
            : this.taskListService.findTasksByState(this.requestNode);
    }
    /**
     * Create an array of ObjectDataRow
     * @param {?} instances
     * @return {?}
     */
    createDataRow(instances) {
        let /** @type {?} */ instancesRows = [];
        instances.forEach((row) => {
            instancesRows.push(new ObjectDataRow(row));
        });
        return instancesRows;
    }
    /**
     * Render the instances list
     *
     * @param {?} instances
     * @return {?}
     */
    renderInstances(instances) {
        instances = this.optimizeNames(instances);
        this.data.setRows(instances);
    }
    /**
     * Select the task given in input if present
     * @param {?} taskIdSelected
     * @return {?}
     */
    selectTask(taskIdSelected) {
        if (!this.isListEmpty()) {
            let /** @type {?} */ rows = this.data.getRows();
            if (rows.length > 0) {
                let /** @type {?} */ dataRow;
                if (taskIdSelected) {
                    dataRow = rows.find((currentRow) => {
                        return currentRow.getValue('id') === taskIdSelected;
                    });
                    if (!dataRow) {
                        dataRow = rows[0];
                    }
                }
                else {
                    dataRow = rows[0];
                }
                this.data.selectedRow = dataRow;
                dataRow.isSelected = true;
                this.currentInstanceId = dataRow.getValue('id');
            }
        }
        else {
            if (this.data) {
                this.data.selectedRow = null;
            }
            this.currentInstanceId = null;
        }
    }
    /**
     * Return the current id
     * @return {?}
     */
    getCurrentId() {
        return this.currentInstanceId;
    }
    /**
     * Check if the taskId is the same of the selected task
     * @param {?} taskId
     * @return {?}
     */
    isEqualToCurrentId(taskId) {
        return this.currentInstanceId === taskId ? true : false;
    }
    /**
     * Check if the list is empty
     * @return {?}
     */
    isListEmpty() {
        return this.data === undefined ||
            (this.data && this.data.getRows() && this.data.getRows().length === 0);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onRowClick(item) {
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRowSelect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRowUnselect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    /**
     * Optimize name field
     * @param {?} istances
     * @return {?}
     */
    optimizeNames(istances) {
        istances = istances.map(t => {
            t.obj.name = t.obj.name || 'No name';
            return t;
        });
        return istances;
    }
    /**
     * @return {?}
     */
    createRequestNode() {
        let /** @type {?} */ requestNode = {
            appDefinitionId: this.appId,
            processInstanceId: this.processInstanceId,
            processDefinitionKey: this.processDefinitionKey,
            text: this.name,
            assignment: this.assignment,
            state: this.state,
            sort: this.sort,
            landingTaskId: this.landingTaskId,
            page: this.page,
            size: this.size,
            start: 0
        };
        return new TaskQueryRequestRepresentationModel(requestNode);
    }
    /**
     * @param {?=} preset
     * @return {?}
     */
    setupDefaultColumns(preset = 'default') {
        if (this.data) {
            const /** @type {?} */ columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    }
    /**
     * @return {?}
     */
    loadLayoutPresets() {
        const /** @type {?} */ externalSettings = this.appConfig.get('adf-task-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, taskPresetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = taskPresetsDefaultModel;
        }
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    getLayoutPreset(name = 'default') {
        return (this.layoutPresets[name] || this.layoutPresets['default']).map(col => new ObjectDataColumn(col));
    }
}
TaskListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tasklist',
                template: `
      <div *ngIf="!requestNode">{{ 'ADF_TASK_LIST.FILTERS.MESSAGES.NONE' | translate }}</div>
      <div *ngIf="requestNode">
          <div>
              <adf-datatable
                  [data]="data"
                  [loading]="isLoading"
                  [multiselect]="multiselect"
                  [selectionMode]="selectionMode"
                  (row-select)="onRowSelect($event)"
                  (row-unselect)="onRowUnselect($event)"
                  (rowClick)="onRowClick($event)"
                  (row-keyup)="onRowKeyUp($event)">
                  <loading-content-template>
                      <ng-template>
                          <!--Add your custom loading template here-->
                          <mat-progress-spinner
                          class="adf-task-list-loading-margin"
                          [color]="'primary'"
                          [mode]="'indeterminate'">
                          </mat-progress-spinner>
                      </ng-template>
                  </loading-content-template>
                  <no-content-template>
                      <!--Add your custom empty template here-->
                      <ng-template>
                          <div class="no-content-message">
                              {{ 'ADF_TASK_LIST.LIST.MESSAGES.NONE' | translate }}
                          </div>
                      </ng-template>
                  </no-content-template>
              </adf-datatable>
          </div>
      </div>
    `,
                styles: [`
      alfresco-datatable >>> .column-header {
          color: #232323;
          font-size: 15px;
      }

      alfresco-datatable >>> .data-cell {
          cursor: pointer !important;
      }

      alfresco-datatable >>> .cell-value{
          width: 250px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis
      }

      .adf-task-list-loading-margin {
          margin-left: calc((100% - 100px) / 2);
          margin-right: calc((100% - 100px) / 2);
      }

      .no-content-message {
          font-size: 16px;
          font-weight: bold;
          text-align: center;
          opacity: 0.54;
          color: #000;
      }
    `]
            },] },
];
/**
 * @nocollapse
 */
TaskListComponent.ctorParameters = () => [
    { type: TaskListService, },
    { type: AppConfigService, },
];
TaskListComponent.propDecorators = {
    'columnList': [{ type: ContentChild, args: [DataColumnListComponent,] },],
    'appId': [{ type: Input },],
    'processInstanceId': [{ type: Input },],
    'processDefinitionKey': [{ type: Input },],
    'state': [{ type: Input },],
    'assignment': [{ type: Input },],
    'sort': [{ type: Input },],
    'name': [{ type: Input },],
    'landingTaskId': [{ type: Input },],
    'data': [{ type: Input },],
    'selectionMode': [{ type: Input },],
    'presetColumn': [{ type: Input },],
    'multiselect': [{ type: Input },],
    'rowClick': [{ type: Output },],
    'rowsSelected': [{ type: Output },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'page': [{ type: Input },],
    'size': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListModule {
}
TaskListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    CardViewModule,
                    DataTableModule,
                    DataColumnModule,
                    DirectiveModule,
                    FormModule,
                    FlexLayoutModule,
                    InfoDrawerModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule,
                    PeopleModule,
                    CommentsModule
                ],
                declarations: [
                    NoTaskDetailsTemplateDirective,
                    TaskFiltersComponent,
                    TaskListComponent,
                    TaskDetailsComponent,
                    TaskAuditDirective,
                    ChecklistComponent,
                    TaskHeaderComponent,
                    StartTaskComponent
                ],
                providers: [
                    TaskListService,
                    TaskFilterService,
                    TaskUploadService,
                    ProcessUploadService,
                    DatePipe
                ],
                exports: [
                    NoTaskDetailsTemplateDirective,
                    TaskFiltersComponent,
                    TaskListComponent,
                    TaskDetailsComponent,
                    TaskAuditDirective,
                    ChecklistComponent,
                    TaskHeaderComponent,
                    StartTaskComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
TaskListModule.ctorParameters = () => [];

class ProcessDefinitionRepresentation {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.name = obj && obj.name || null;
        this.description = obj && obj.description || null;
        this.key = obj && obj.key || null;
        this.category = obj && obj.category || null;
        this.version = obj && obj.version || 0;
        this.deploymentId = obj && obj.deploymentId || null;
        this.tenantId = obj && obj.tenantId || null;
        this.metaDataValues = obj && obj.metaDataValues || [];
        this.hasStartForm = obj && obj.hasStartForm === true ? true : false;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceVariable {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.name = obj && obj.name !== undefined ? obj.name : null;
        this.scope = obj && obj.scope !== undefined ? obj.scope : null;
        this.value = obj && obj.value !== undefined ? obj.value : null;
        this.valueUrl = obj && obj.valueUrl !== undefined ? obj.valueUrl : null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstance {
    /**
     * @param {?=} data
     */
    constructor(data) {
        this.businessKey = data && data.businessKey !== undefined ? data.businessKey : null;
        this.ended = data && data.ended !== undefined ? data.ended : null;
        this.graphicalNotationDefined = data && data.graphicalNotationDefined !== undefined ? data.graphicalNotationDefined : null;
        this.id = data && data.id !== undefined ? data.id : null;
        this.name = data && data.name !== undefined ? data.name : null;
        this.processDefinitionCategory = data && data.processDefinitionCategory !== undefined ? data.processDefinitionCategory : null;
        this.processDefinitionDeploymentId = data && data.processDefinitionDeploymentId !== undefined ? data.processDefinitionDeploymentId : null;
        this.processDefinitionDescription = data && data.processDefinitionDescription !== undefined ? data.processDefinitionDescription : null;
        this.processDefinitionId = data && data.processDefinitionId !== undefined ? data.processDefinitionId : null;
        this.processDefinitionKey = data && data.processDefinitionKey !== undefined ? data.processDefinitionKey : null;
        this.processDefinitionName = data && data.processDefinitionName !== undefined ? data.processDefinitionName : null;
        this.processDefinitionVersion = data && data.processDefinitionVersion !== undefined ? data.processDefinitionVersion : null;
        this.startFormDefined = data && data.startFormDefined !== undefined ? data.startFormDefined : null;
        this.started = data && data.started !== undefined ? data.started : null;
        this.startedBy = data && data.startedBy !== undefined ? data.startedBy : null;
        this.tenantId = data && data.tenantId !== undefined ? data.tenantId : null;
        this.variables = data && data.variables !== undefined ? data.variables : null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessService {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * @param {?} requestNode
     * @param {?=} processDefinitionKey
     * @return {?}
     */
    getProcessInstances(requestNode, processDefinitionKey) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processApi.getProcessInstances(requestNode))
            .map((res) => {
            if (processDefinitionKey) {
                return res.data.filter(process => process.processDefinitionKey === processDefinitionKey);
            }
            else {
                return res.data;
            }
        }).catch(err => this.handleProcessError(err));
    }
    /**
     * fetch the Process Audit information as a pdf
     * @param {?} processId - the process id
     * @return {?}
     */
    fetchProcessAuditPdfById(processId) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processApi.getProcessAuditPdf(processId))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * fetch the Process Audit information in a json format
     * @param {?} processId - the process id
     * @return {?}
     */
    fetchProcessAuditJsonById(processId) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processApi.getProcessAuditJson(processId))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getProcess(processInstanceId) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processApi.getProcessInstance(processInstanceId))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} processInstanceId
     * @param {?=} state
     * @return {?}
     */
    getProcessTasks(processInstanceId, state) {
        let /** @type {?} */ taskOpts = state ? {
            processInstanceId: processInstanceId,
            state: state
        } : {
            processInstanceId: processInstanceId
        };
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.taskApi.listTasks(taskOpts))
            .map(this.extractData)
            .map(tasks => tasks.map((task) => {
            task.created = moment(task.created, 'YYYY-MM-DD').format();
            return task;
        }))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?=} appId
     * @return {?}
     */
    getProcessDefinitions(appId) {
        let /** @type {?} */ opts = appId ? {
            latest: true,
            appDefinitionId: appId
        } : {
            latest: true
        };
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processApi.getProcessDefinitions(opts))
            .map(this.extractData)
            .map(processDefs => processDefs.map((pd) => new ProcessDefinitionRepresentation(pd)))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} processDefinitionId
     * @param {?} name
     * @param {?=} outcome
     * @param {?=} startFormValues
     * @param {?=} variables
     * @return {?}
     */
    startProcess(processDefinitionId, name, outcome, startFormValues, variables) {
        let /** @type {?} */ startRequest = {
            name: name,
            processDefinitionId: processDefinitionId
        };
        if (outcome) {
            startRequest.outcome = outcome;
        }
        if (startFormValues) {
            startRequest.values = startFormValues;
        }
        if (variables) {
            startRequest.variables = variables;
        }
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processApi.startNewProcessInstance(startRequest))
            .map((pd) => new ProcessInstance(pd))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    cancelProcess(processInstanceId) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processApi.deleteProcessInstance(processInstanceId))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getProcessInstanceVariables(processInstanceId) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processInstanceVariablesApi.getProcessInstanceVariables(processInstanceId))
            .map((processVars) => processVars.map((pd) => new ProcessInstanceVariable(pd)))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} processInstanceId
     * @param {?} variables
     * @return {?}
     */
    createOrUpdateProcessInstanceVariables(processInstanceId, variables) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processInstanceVariablesApi.createOrUpdateProcessInstanceVariables(processInstanceId, variables))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} processInstanceId
     * @param {?} variableName
     * @return {?}
     */
    deleteProcessInstanceVariable(processInstanceId, variableName) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.processInstanceVariablesApi.deleteProcessInstanceVariable(processInstanceId, variableName))
            .catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?} res
     * @return {?}
     */
    extractData(res) {
        return res.data || {};
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleProcessError(error) {
        return Observable$1.throw(error || 'Server error');
    }
}
ProcessService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ProcessService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JSON_FORMAT$1 = 'json';
const PDF_FORMAT$1 = 'pdf';
class ProcessAuditDirective {
    /**
     *
     * @param {?} contentService
     * @param {?} processListService
     */
    constructor(contentService, processListService) {
        this.contentService = contentService;
        this.processListService = processListService;
        this.fileName = 'Audit';
        this.format = 'pdf';
        this.download = true;
        this.clicked = new EventEmitter();
        this.error = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.isValidType()) {
            this.setDefaultFormatType();
        }
    }
    /**
     * @return {?}
     */
    isValidType() {
        if (this.format && (this.isJsonFormat() || this.isPdfFormat())) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    setDefaultFormatType() {
        this.format = PDF_FORMAT$1;
    }
    /**
     * fetch the audit information in the requested format
     * @return {?}
     */
    fetchAuditInfo() {
        if (this.isPdfFormat()) {
            this.processListService.fetchProcessAuditPdfById(this.processId).subscribe((blob) => {
                this.audit = blob;
                if (this.download) {
                    this.contentService.downloadBlob(this.audit, this.fileName + '.pdf');
                }
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }, (err) => {
                this.error.emit(err);
            });
        }
        else {
            this.processListService.fetchProcessAuditJsonById(this.processId).subscribe((res) => {
                this.audit = res;
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    /**
     * @return {?}
     */
    onClickAudit() {
        this.fetchAuditInfo();
    }
    /**
     * @return {?}
     */
    isJsonFormat() {
        return this.format === JSON_FORMAT$1;
    }
    /**
     * @return {?}
     */
    isPdfFormat() {
        return this.format === PDF_FORMAT$1;
    }
}
ProcessAuditDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-process-audit]',
                host: {
                    'role': 'button',
                    '(click)': 'onClickAudit()'
                }
            },] },
];
/**
 * @nocollapse
 */
ProcessAuditDirective.ctorParameters = () => [
    { type: ContentService, },
    { type: ProcessService, },
];
ProcessAuditDirective.propDecorators = {
    'processId': [{ type: Input, args: ['process-id',] },],
    'fileName': [{ type: Input },],
    'format': [{ type: Input },],
    'download': [{ type: Input },],
    'clicked': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FilterProcessRepresentationModel {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.appId = obj.appId || null;
            this.name = obj.name || null;
            this.recent = !!obj.recent;
            this.icon = obj.icon || null;
            this.filter = obj.filter || null;
            this.index = obj.index;
        }
    }
    /**
     * @return {?}
     */
    hasFilter() {
        return !!this.filter;
    }
}
/**
 *
 * This object represent the parameters of a process filter.
 *
 *
 */
class ProcessFilterParamRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.processDefinitionId = obj.processDefinitionId || null;
        this.appDefinitionId = obj.appDefinitionId || null;
        this.state = obj.state || null;
        this.sort = obj.sort || null;
        this.page = obj.page || null;
        this.size = obj.size || null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessFilterService {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * @param {?} appId
     * @return {?}
     */
    getProcessFilters(appId) {
        return Observable$1.fromPromise(this.callApiProcessFilters(appId))
            .map((response) => {
            let /** @type {?} */ filters = [];
            response.data.forEach((filter) => {
                let /** @type {?} */ filterModel = new FilterProcessRepresentationModel(filter);
                filters.push(filterModel);
            });
            return filters;
        })
            .catch(err => this.handleProcessError(err));
    }
    /**
     * Retrieve the process filter by id
     * @param {?} filterId - number - The id of the filter
     * @param {?=} appId - string - optional - The id of app
     * @return {?}
     */
    getProcessFilterById(filterId, appId) {
        return Observable$1.fromPromise(this.callApiProcessFilters(appId))
            .map((response) => {
            return response.data.find(filter => filter.id === filterId);
        }).catch(err => this.handleProcessError(err));
    }
    /**
     * Retrieve the process filter by name
     * @param {?} filterName - string - The name of the filter
     * @param {?=} appId - string - optional - The id of app
     * @return {?}
     */
    getProcessFilterByName(filterName, appId) {
        return Observable$1.fromPromise(this.callApiProcessFilters(appId))
            .map((response) => {
            return response.data.find(filter => filter.name === filterName);
        }).catch(err => this.handleProcessError(err));
    }
    /**
     * Create and return the default filters
     * @param {?} appId
     * @return {?}
     */
    createDefaultFilters(appId) {
        let /** @type {?} */ runningFilter = this.getRunningFilterInstance(appId);
        let /** @type {?} */ runningObservable = this.addProcessFilter(runningFilter);
        let /** @type {?} */ completedFilter = this.getCompletedFilterInstance(appId);
        let /** @type {?} */ completedObservable = this.addProcessFilter(completedFilter);
        let /** @type {?} */ allFilter = this.getAllFilterInstance(appId);
        let /** @type {?} */ allObservable = this.addProcessFilter(allFilter);
        return Observable$1.create(observer => {
            Observable$1.forkJoin(runningObservable, completedObservable, allObservable).subscribe((res) => {
                let /** @type {?} */ filters = [];
                res.forEach((filter) => {
                    if (filter.name === runningFilter.name) {
                        filters.push(runningFilter);
                    }
                    else if (filter.name === completedFilter.name) {
                        filters.push(completedFilter);
                    }
                    else if (filter.name === allFilter.name) {
                        filters.push(allFilter);
                    }
                });
                observer.next(filters);
                observer.complete();
            }, (err) => {
                this.handleProcessError(err);
            });
        });
    }
    /**
     * @param {?} appId
     * @return {?}
     */
    getRunningFilterInstance(appId) {
        return new FilterProcessRepresentationModel({
            'name': 'Running',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-random',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'running' }
        });
    }
    /**
     * Return a static Completed filter instance
     * @param {?} appId
     * @return {?}
     */
    getCompletedFilterInstance(appId) {
        return new FilterProcessRepresentationModel({
            'name': 'Completed',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-ok-sign',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'completed' }
        });
    }
    /**
     * Return a static All filter instance
     * @param {?} appId
     * @return {?}
     */
    getAllFilterInstance(appId) {
        return new FilterProcessRepresentationModel({
            'name': 'All',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-th',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'all' }
        });
    }
    /**
     * Add a filter
     * @param {?} filter - FilterProcessRepresentationModel
     * @return {?}
     */
    addProcessFilter(filter) {
        return Observable$1.fromPromise(this.alfrescoApiService.getInstance().activiti.userFiltersApi.createUserProcessInstanceFilter(filter))
            .map(res => res)
            .map((response) => {
            return response;
        }).catch(err => this.handleProcessError(err));
    }
    /**
     * @param {?=} appId
     * @return {?}
     */
    callApiProcessFilters(appId) {
        if (appId) {
            return this.alfrescoApiService.getInstance().activiti.userFiltersApi.getUserProcessInstanceFilters({ appId: appId });
        }
        else {
            return this.alfrescoApiService.getInstance().activiti.userFiltersApi.getUserProcessInstanceFilters();
        }
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleProcessError(error) {
        return Observable$1.throw(error || 'Server error');
    }
}
ProcessFilterService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ProcessFilterService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessFiltersComponent {
    /**
     * @param {?} processFilterService
     * @param {?} appsProcessService
     */
    constructor(processFilterService, appsProcessService) {
        this.processFilterService = processFilterService;
        this.appsProcessService = appsProcessService;
        this.filterClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.showIcon = true;
        this.filters = [];
        this.filter$ = new Observable$1(observer => this.filterObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.filter$.subscribe((filter) => {
            this.filters.push(filter);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ appId = changes['appId'];
        if (appId && (appId.currentValue || appId.currentValue === null)) {
            this.getFiltersByAppId(appId.currentValue);
            return;
        }
        let /** @type {?} */ appName = changes['appName'];
        if (appName && appName.currentValue) {
            this.getFiltersByAppName(appName.currentValue);
            return;
        }
    }
    /**
     * Return the filter list filtered by appId
     * @param {?=} appId - optional
     * @return {?}
     */
    getFiltersByAppId(appId) {
        this.processFilterService.getProcessFilters(appId).subscribe((res) => {
            if (res.length === 0 && this.isFilterListEmpty()) {
                this.processFilterService.createDefaultFilters(appId).subscribe((resDefault) => {
                    this.resetFilter();
                    resDefault.forEach((filter) => {
                        this.filterObserver.next(filter);
                    });
                    this.selectProcessFilter(this.filterParam);
                    this.success.emit(resDefault);
                }, (errDefault) => {
                    this.error.emit(errDefault);
                });
            }
            else {
                this.resetFilter();
                res.forEach((filter) => {
                    this.filterObserver.next(filter);
                });
                this.selectProcessFilter(this.filterParam);
                this.success.emit(res);
            }
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * Return the filter list filtered by appName
     * @param {?} appName
     * @return {?}
     */
    getFiltersByAppName(appName) {
        this.appsProcessService.getDeployedApplicationsByName(appName).subscribe(application => {
            this.getFiltersByAppId(application.id);
            this.selectProcessFilter(this.filterParam);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * Pass the selected filter as next
     * @param {?} filter
     * @return {?}
     */
    selectFilter(filter) {
        this.currentFilter = filter;
        this.filterClick.emit(filter);
    }
    /**
     * Select the first filter of a list if present
     * @param {?} filterParam
     * @return {?}
     */
    selectProcessFilter(filterParam) {
        if (filterParam) {
            this.filters.filter((processFilter, index) => {
                if (filterParam.name && filterParam.name.toLowerCase() === processFilter.name.toLowerCase() || filterParam.index === index) {
                    this.currentFilter = processFilter;
                }
            });
        }
        if (this.isCurrentFilterEmpty()) {
            this.selectDefaultTaskFilter();
        }
    }
    /**
     * Select the Running filter
     * @return {?}
     */
    selectRunningFilter() {
        this.selectProcessFilter(this.processFilterService.getRunningFilterInstance(null));
    }
    /**
     * Select as default task filter the first in the list
     * @return {?}
     */
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    /**
     * Return the current task
     * @return {?}
     */
    getCurrentFilter() {
        return this.currentFilter;
    }
    /**
     * Check if the filter list is empty
     * @return {?}
     */
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    /**
     * Reset the filters properties
     * @return {?}
     */
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
    /**
     * @return {?}
     */
    isCurrentFilterEmpty() {
        return this.currentFilter === undefined || null ? true : false;
    }
}
ProcessFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-filters',
                template: `
      <div class="menu-container">
          <mat-list>
              <mat-list-item (click)="selectFilter(filter)" *ngFor="let filter of filters"
                              class="adf-filters__entry" [class.active]="currentFilter === filter">
                  <mat-icon *ngIf="hasIcon" matListIcon class="adf-filters__entry-icon">assignment</mat-icon>
                  <span matLine [attr.data-automation-id]="filter.name + '_filter'">{{filter.name}}</span>
              </mat-list-item>
          </mat-list>
      </div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
ProcessFiltersComponent.ctorParameters = () => [
    { type: ProcessFilterService, },
    { type: AppsProcessService, },
];
ProcessFiltersComponent.propDecorators = {
    'filterParam': [{ type: Input },],
    'filterClick': [{ type: Output },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'appId': [{ type: Input },],
    'appName': [{ type: Input },],
    'showIcon': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceHeaderComponent {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.refreshData();
    }
    /**
     * @return {?}
     */
    refreshData() {
        if (this.processInstance) {
            this.properties = [
                new CardViewTextItemModel({
                    label: 'ADF_PROCESS_LIST.PROPERTIES.STATUS',
                    value: this.getProcessStatus(),
                    key: 'status'
                }),
                new CardViewDateItemModel({
                    label: 'ADF_PROCESS_LIST.PROPERTIES.END_DATE',
                    value: this.processInstance.ended,
                    format: 'MMM DD YYYY',
                    key: 'ended',
                    default: 'ADF_PROCESS_LIST.PROPERTIES.END_DATE_DEFAULT'
                }),
                new CardViewTextItemModel({
                    label: 'ADF_PROCESS_LIST.PROPERTIES.CATEGORY',
                    value: this.processInstance.processDefinitionCategory,
                    key: 'category',
                    default: 'ADF_PROCESS_LIST.PROPERTIES.CATEGORY_DEFAULT'
                }),
                new CardViewTextItemModel({
                    label: 'ADF_PROCESS_LIST.PROPERTIES.BUSINESS_KEY',
                    value: this.processInstance.businessKey,
                    key: 'businessKey',
                    default: 'ADF_PROCESS_LIST.PROPERTIES.BUSINESS_KEY_DEFAULT'
                }),
                new CardViewTextItemModel({
                    label: 'ADF_PROCESS_LIST.PROPERTIES.CREATED_BY',
                    value: this.getStartedByFullName(),
                    key: 'assignee',
                    default: 'ADF_PROCESS_LIST.PROPERTIES.CREATED_BY_DEFAULT'
                }),
                new CardViewDateItemModel({
                    label: 'ADF_PROCESS_LIST.PROPERTIES.CREATED',
                    value: this.processInstance.started,
                    format: 'MMM DD YYYY',
                    key: 'created'
                }),
                new CardViewTextItemModel({ label: 'ADF_PROCESS_LIST.PROPERTIES.ID',
                    value: this.processInstance.id,
                    key: 'id'
                }),
                new CardViewTextItemModel({ label: 'ADF_PROCESS_LIST.PROPERTIES.DESCRIPTION',
                    value: this.processInstance.processDefinitionDescription,
                    key: 'description',
                    default: 'ADF_PROCESS_LIST.PROPERTIES.DESCRIPTION_DEFAULT'
                })
            ];
        }
    }
    /**
     * @return {?}
     */
    getProcessStatus() {
        if (this.processInstance) {
            return this.isRunning() ? 'Running' : 'Completed';
        }
    }
    /**
     * @return {?}
     */
    getStartedByFullName() {
        let /** @type {?} */ fullName = '';
        if (this.processInstance && this.processInstance.startedBy) {
            fullName += this.processInstance.startedBy.firstName || '';
            fullName += fullName ? ' ' : '';
            fullName += this.processInstance.startedBy.lastName || '';
        }
        return fullName;
    }
    /**
     * @return {?}
     */
    isRunning() {
        return this.processInstance && !this.processInstance.ended;
    }
}
ProcessInstanceHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-header',
                template: `
      <mat-card *ngIf="processInstance" class="adf-card-container">
          <mat-card-content>
              <adf-card-view [properties]="properties"></adf-card-view>
          </mat-card-content>
      </mat-card>
    `,
                styles: [`
      :host {
          width: 100%;
      }

      .adf-card-container {
          font-family: inherit;
      }
    `]
            },] },
];
/**
 * @nocollapse
 */
ProcessInstanceHeaderComponent.ctorParameters = () => [];
ProcessInstanceHeaderComponent.propDecorators = {
    'processInstance': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDetailsEvent {
    /**
     * @param {?} value
     */
    constructor(value) {
        this._defaultPrevented = false;
        this._value = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceTasksComponent {
    /**
     * @param {?} activitiProcess
     * @param {?} logService
     * @param {?} dialog
     */
    constructor(activitiProcess, logService, dialog) {
        this.activitiProcess = activitiProcess;
        this.logService = logService;
        this.dialog = dialog;
        this.showRefreshButton = true;
        this.error = new EventEmitter();
        this.activeTasks = [];
        this.completedTasks = [];
        this.taskClick = new EventEmitter();
        this.task$ = new Observable$1(observer => this.taskObserver = observer).share();
        this.completedTask$ = new Observable$1(observer => this.completedTaskObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.task$.subscribe((task) => {
            this.activeTasks.push(task);
        });
        this.completedTask$.subscribe((task) => {
            this.completedTasks.push(task);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ processInstanceDetails = changes['processInstanceDetails'];
        if (processInstanceDetails && processInstanceDetails.currentValue) {
            this.load(processInstanceDetails.currentValue.id);
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    load(processInstanceId) {
        this.loadActive(processInstanceId);
        this.loadCompleted(processInstanceId);
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    loadActive(processInstanceId) {
        this.activeTasks = [];
        if (processInstanceId) {
            this.activitiProcess.getProcessTasks(processInstanceId, null).subscribe((res) => {
                res.forEach((task) => {
                    this.taskObserver.next(task);
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
        else {
            this.activeTasks = [];
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    loadCompleted(processInstanceId) {
        this.completedTasks = [];
        if (processInstanceId) {
            this.activitiProcess.getProcessTasks(processInstanceId, 'completed').subscribe((res) => {
                res.forEach((task) => {
                    this.completedTaskObserver.next(task);
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
        else {
            this.completedTasks = [];
        }
    }
    /**
     * @return {?}
     */
    hasStartFormDefined() {
        return this.processInstanceDetails && this.processInstanceDetails.startFormDefined === true;
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getUserFullName(user) {
        if (user) {
            return (user.firstName && user.firstName !== 'null'
                ? user.firstName + ' ' : '') +
                user.lastName;
        }
        return 'Nobody';
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    getFormatDate(value, format) {
        let /** @type {?} */ datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            this.logService.error(`ProcessListInstanceTask: error parsing date ${value} to format ${format}`);
        }
    }
    /**
     * @param {?} $event
     * @param {?} task
     * @return {?}
     */
    clickTask($event, task) {
        let /** @type {?} */ args = new TaskDetailsEvent(task);
        this.taskClick.emit(args);
    }
    /**
     * @return {?}
     */
    clickStartTask() {
        this.processId = this.processInstanceDetails.id;
        this.showStartDialog();
    }
    /**
     * @return {?}
     */
    showStartDialog() {
        this.dialog.open(this.startDialog, { height: '500px', width: '700px' });
    }
    /**
     * @return {?}
     */
    closeSartDialog() {
        this.dialog.closeAll();
    }
    /**
     * @return {?}
     */
    onRefreshClicked() {
        this.load(this.processInstanceDetails.id);
    }
    /**
     * @return {?}
     */
    onFormContentClick() {
        this.closeSartDialog();
    }
}
ProcessInstanceTasksComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-tasks',
                template: `
      <div  *ngIf="showRefreshButton" class="process-tasks-refresh" >
          <button mat-icon-button (click)="onRefreshClicked()">
              <mat-icon class="md-24" aria-label="Refresh">refresh</mat-icon>
          </button>
      </div>

      <!-- ACTIVE FORM -->

      <mat-chip-list>
          <span class="adf-chip-label">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASKS_ACTIVE'|translate }}</span>
          <mat-chip class="adf-process-badge" color="accent" selected="true">{{activeTasks?.length}}</mat-chip>
      </mat-chip-list>

      <div class="menu-container" *ngIf="activeTasks?.length > 0" data-automation-id="active-tasks">
          <mat-list>
              <mat-list-item class="process-tasks__task-item" *ngFor="let task of activeTasks" (click)="clickTask($event, task)">
                      <mat-icon mat-list-icon>assignment</mat-icon>
                      <h3 matLine>{{task.name || 'Nameless task'}}</h3>
                      <span matLine>
                          {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user: getUserFullName(task.assignee), created: getFormatDate(task.created, 'mediumDate') } }}
                      </span>
              </mat-list-item>
          </mat-list>
      </div>

      <!-- START FORM -->

      <div *ngIf="activeTasks?.length === 0" data-automation-id="active-tasks-none" class="no-results">
          {{ 'ADF_PROCESS_LIST.DETAILS.TASKS.NO_ACTIVE' | translate }}
      </div>

      <div *ngIf="hasStartFormDefined()">
          <span class="activiti-label">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</span>

          <!--IF START TASK COMPLETED -->
          <div class="menu-container">
              <mat-list>
                  <mat-list-item class="process-tasks__task-item" (click)="clickStartTask($event)">
                      <mat-icon mat-list-icon>assignment</mat-icon>
                      <h3 matLine>{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</h3>
                      <span matLine>
                          {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user:getUserFullName(processInstanceDetails.startedBy), created: getFormatDate(processInstanceDetails.started, 'mediumDate') } }}
                      </span>
                  </mat-list-item>
              </mat-list>
          </div>

      </div>

      <!-- COMPLETED FORM -->
      <mat-chip-list>
              <span class="adf-chip-label">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASKS_COMPLETED'|translate }}</span>
              <mat-chip class="adf-process-badge" color="accent" selected="true">{{completedTasks?.length}}</mat-chip>
      </mat-chip-list>

      <div class="menu-container" *ngIf="completedTasks?.length > 0" data-automation-id="completed-tasks">
          <mat-list>
              <mat-list-item class="process-tasks__task-item" *ngFor="let task of completedTasks" (click)="clickTask($event, task)">
                  <mat-icon mat-list-icon>assignment</mat-icon>
                  <h3 matLine>{{task.name || 'Nameless task'}}</h3>
                  <span matLine>
                      {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user:getUserFullName(task.assignee), created: getFormatDate(task.created, 'mediumDate') } }}
                  </span>
              </mat-list-item>
          </mat-list>
      </div>

      <div *ngIf="completedTasks?.length === 0" data-automation-id="completed-tasks-none" class="no-results">
          {{ 'ADF_PROCESS_LIST.DETAILS.TASKS.NO_COMPLETED' | translate }}
      </div>

      <ng-template *ngIf="hasStartFormDefined()" #startDialog>
          <div id="adf-start-process-dialog" class="adf-start-process-dialog">
              <h4 matDialogTitle>{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</h4>
              <div mat-dialog-content class="adf-start-process-dialog-content">
                  <adf-start-form [processId]="processId"
                                       [showRefreshButton]="false" [readOnlyForm]="true"
                                       (formContentClicked)='onFormContentClick($event)'>
                  </adf-start-form>
              </div>
              <div mat-dialog-actions class="adf-start-process-dialog-actions">
                  <button mat-button type="button" (click)="closeSartDialog()">{{ 'ADF_PROCESS_LIST.DETAILS.TASKS.TASK_CLOSE' | translate }}</button>
              </div>
          </div>
      </ng-template>
    `,
                styles: [`
      :host {
          width: 100%;
      }

      .activiti-label {
          font-weight: bolder;
          vertical-align: top;
      }

      .adf-process-badge {
          pointer-events: none;
          outline: none;
      }

      .adf-chip-label {
          position: relative;
          top: 5px;
          margin-right: 8px;
          font-weight: bold;
      }

      .menu-container {
          margin-bottom: 32px;
      }

      .activiti-label + .icon {
          position: relative;
          top: -2px;
      }

      .task-details-dialog {
          position: fixed;
          top: 50%;
          -webkit-transform: translate(0, -50%);
                  transform: translate(0, -50%);
          width: 40%;
      }

      .process-tasks-refresh {
          float: right;
      }

      .adf-start-process-dialog {
          width: 100%;
          height: 100%;
          display: -webkit-box;
          display: -ms-flexbox;
          display: flex;
          -webkit-box-orient: vertical;
          -webkit-box-direction: normal;
              -ms-flex-direction: column;
                  flex-direction: column;
      }

      .adf-start-process-dialog-content {
          -webkit-box-flex: 1;
              -ms-flex-positive: 1;
                  flex-grow: 1;
      }

      .adf-start-process-dialog-actions {
          display: -webkit-box;
          display: -ms-flexbox;
          display: flex;
          -webkit-box-pack: end;
              -ms-flex-pack: end;
                  justify-content: flex-end;
      }

      .no-results {
          margin-left: 9px;
          font-size: 14px;
          font-weight: 400;
          letter-spacing: 0;
          line-height: 18px;
          color: rgba(0, 0, 0, .54);
          display: block;
          padding: 12px;
      }

      .process-tasks__task-item {
          cursor: pointer;
      }
    `]
            },] },
];
/**
 * @nocollapse
 */
ProcessInstanceTasksComponent.ctorParameters = () => [
    { type: ProcessService, },
    { type: LogService, },
    { type: MatDialog, },
];
ProcessInstanceTasksComponent.propDecorators = {
    'processInstanceDetails': [{ type: Input },],
    'showRefreshButton': [{ type: Input },],
    'error': [{ type: Output },],
    'startDialog': [{ type: ViewChild, args: ['startDialog',] },],
    'taskdetails': [{ type: ViewChild, args: ['taskdetails',] },],
    'taskClick': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceDetailsComponent {
    /**
     * Constructor
     * @param {?} activitiProcess   Process service
     * @param {?} logService
     */
    constructor(activitiProcess, logService) {
        this.activitiProcess = activitiProcess;
        this.logService = logService;
        this.showTitle = true;
        this.showRefreshButton = true;
        this.processCancelled = new EventEmitter();
        this.error = new EventEmitter();
        this.taskClick = new EventEmitter();
        this.showProcessDiagram = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ processInstanceId = changes['processInstanceId'];
        if (processInstanceId && !processInstanceId.currentValue) {
            this.reset();
            return;
        }
        if (processInstanceId && processInstanceId.currentValue) {
            this.load(processInstanceId.currentValue);
            return;
        }
    }
    /**
     * Reset the task detail to undefined
     * @return {?}
     */
    reset() {
        this.processInstanceDetails = null;
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    load(processId) {
        if (processId) {
            this.activitiProcess.getProcess(processId).subscribe((res) => {
                this.processInstanceDetails = res;
            });
        }
    }
    /**
     * @return {?}
     */
    isRunning() {
        return this.processInstanceDetails && !this.processInstanceDetails.ended;
    }
    /**
     * @return {?}
     */
    cancelProcess() {
        this.activitiProcess.cancelProcess(this.processInstanceId).subscribe((data) => {
            this.processCancelled.emit(data);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTaskClicked(event) {
        this.taskClick.emit(event);
    }
    /**
     * @param {?} dateFormat
     * @return {?}
     */
    getProcessNameOrDescription(dateFormat) {
        let /** @type {?} */ name = '';
        if (this.processInstanceDetails) {
            name = this.processInstanceDetails.name ||
                this.processInstanceDetails.processDefinitionName + ' - ' + this.getFormatDate(this.processInstanceDetails.started, dateFormat);
        }
        return name;
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    getFormatDate(value, format) {
        let /** @type {?} */ datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            this.logService.error(`ProcessListInstanceHeader: error parsing date ${value} to format ${format}`);
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    onShowProcessDiagram(processInstanceId) {
        this.showProcessDiagram.emit({ value: this.processInstanceId });
    }
}
ProcessInstanceDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-details',
                template: `
      <div *ngIf="!processInstanceDetails">{{ 'ADF_PROCESS_LIST.DETAILS.MESSAGES.NONE'|translate }}</div>
      <mat-card *ngIf="processInstanceDetails">
          <mat-card-header>
              <mat-card-title>{{ getProcessNameOrDescription('medium') }}</mat-card-title>
          </mat-card-header>
          <mat-card-content>
              <adf-process-instance-header
                  [processInstance]="processInstanceDetails"
                  (showProcessDiagram)="onShowProcessDiagram($event)">
              </adf-process-instance-header>

              <button class="adf-in-medias-res-button" mat-button id="show-diagram-button" type="button" mat-button mat-raised-button [disabled]="!isRunning()" (click)="onShowProcessDiagram(processInstanceId)">{{ 'ADF_PROCESS_LIST.DETAILS.BUTTON.SHOW_DIAGRAM' | translate }}</button>

              <mat-card>
                  <mat-card-content>
                      <adf-process-instance-tasks
                          [processInstanceDetails]="processInstanceDetails"
                          (taskClick)="onTaskClicked($event)">
                      </adf-process-instance-tasks>
                  </mat-card-content>
              </mat-card>

              <div data-automation-id="header-status" *ngIf="isRunning()" class="adf-in-medias-res-button">
                  <button mat-button type="button" (click)="cancelProcess()">{{ 'ADF_PROCESS_LIST.DETAILS.BUTTON.CANCEL' | translate }}</button>
              </div>

              <mat-card>
                  <mat-card-content>
                      <adf-process-instance-comments #activiticomments
                          [readOnly]="false"
                          [processInstanceId]="processInstanceDetails.id">
                      </adf-process-instance-comments>
                  </mat-card-content>
              </mat-card>

          </mat-card-content>
      </mat-card>
    `,
                styles: [`
      :host {
          width: 100%;
      }

      .activiti-process-container {
          width: 100%;
          min-height: 100px;
          overflow: visible;
          padding: 10px;
      }

      .adf-comments-dialog {
          position: fixed;
          top: 50%;
          -webkit-transform: translate(0, -50%);
                  transform: translate(0, -50%);
          width: 40%;
      }

      .adf-in-medias-res-button {
          margin: 16px 0;
      }
    `]
            },] },
];
/**
 * @nocollapse
 */
ProcessInstanceDetailsComponent.ctorParameters = () => [
    { type: ProcessService, },
    { type: LogService, },
];
ProcessInstanceDetailsComponent.propDecorators = {
    'processInstanceId': [{ type: Input },],
    'processInstanceHeader': [{ type: ViewChild, args: [ProcessInstanceHeaderComponent,] },],
    'tasksList': [{ type: ViewChild, args: [ProcessInstanceTasksComponent,] },],
    'showTitle': [{ type: Input },],
    'showRefreshButton': [{ type: Input },],
    'processCancelled': [{ type: Output },],
    'error': [{ type: Output },],
    'taskClick': [{ type: Output },],
    'showProcessDiagram': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let processPresetsDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_PROCESS_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'created',
            'type': 'text',
            'title': 'ADF_PROCESS_LIST.PROPERTIES.CREATED',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceListComponent {
    /**
     * @param {?} processService
     * @param {?} appConfig
     */
    constructor(processService, appConfig) {
        this.processService = processService;
        this.appConfig = appConfig;
        this.rowClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.isLoading = true;
        this.layoutPresets = {};
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.loadLayoutPresets();
        this.setupSchema();
        if (this.appId) {
            this.reload();
        }
    }
    /**
     * Setup html-based (html definitions) or code behind (data adapter) schema.
     * If component is assigned with an empty data adater the default schema settings applied.
     * @return {?}
     */
    setupSchema() {
        let /** @type {?} */ schema = [];
        if (this.columnList && this.columnList.columns && this.columnList.columns.length > 0) {
            schema = this.columnList.columns.map(c => /** @type {?} */ (c));
        }
        if (!this.data) {
            this.data = new ObjectDataTableAdapter([], schema.length > 0 ? schema : this.getLayoutPreset(this.presetColumn));
        }
        else {
            if (schema && schema.length > 0) {
                this.data.setColumns(schema);
            }
            else if (this.data.getColumns().length === 0) {
                this.presetColumn ? this.setupDefaultColumns(this.presetColumn) : this.setupDefaultColumns();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isPropertyChanged(changes)) {
            this.reload();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    isPropertyChanged(changes) {
        let /** @type {?} */ changed = false;
        let /** @type {?} */ appId = changes['appId'];
        let /** @type {?} */ processDefinitionKey = changes['processDefinitionKey'];
        let /** @type {?} */ state = changes['state'];
        let /** @type {?} */ sort = changes['sort'];
        let /** @type {?} */ name = changes['name'];
        if (appId && appId.currentValue) {
            changed = true;
        }
        else if (processDefinitionKey && processDefinitionKey.currentValue) {
            changed = true;
        }
        else if (state && state.currentValue) {
            changed = true;
        }
        else if (sort && sort.currentValue) {
            changed = true;
        }
        else if (name && name.currentValue) {
            changed = true;
        }
        return changed;
    }
    /**
     * @return {?}
     */
    reload() {
        this.requestNode = this.createRequestNode();
        this.load(this.requestNode);
    }
    /**
     * @param {?} requestNode
     * @return {?}
     */
    load(requestNode) {
        this.isLoading = true;
        this.processService.getProcessInstances(requestNode, this.processDefinitionKey)
            .subscribe((response) => {
            let /** @type {?} */ instancesRow = this.createDataRow(response);
            this.renderInstances(instancesRow);
            this.selectFirst();
            this.success.emit(response);
            this.isLoading = false;
        }, error => {
            this.error.emit(error);
            this.isLoading = false;
        });
    }
    /**
     * Create an array of ObjectDataRow
     * @param {?} instances
     * @return {?}
     */
    createDataRow(instances) {
        let /** @type {?} */ instancesRows = [];
        instances.forEach((row) => {
            instancesRows.push(new ObjectDataRow(row));
        });
        return instancesRows;
    }
    /**
     * Render the instances list
     *
     * @param {?} instances
     * @return {?}
     */
    renderInstances(instances) {
        instances = this.optimizeNames(instances);
        this.setDatatableSorting();
        this.data.setRows(instances);
    }
    /**
     * Sort the datatable rows based on current value of 'sort' property
     * @return {?}
     */
    setDatatableSorting() {
        if (!this.sort) {
            return;
        }
        let /** @type {?} */ sortingParams = this.sort.split('-');
        if (sortingParams.length === 2) {
            let /** @type {?} */ sortColumn = sortingParams[0] === 'created' ? 'started' : sortingParams[0];
            let /** @type {?} */ sortOrder = sortingParams[1];
            this.data.setSorting(new DataSorting(sortColumn, sortOrder));
        }
    }
    /**
     * Select the first instance of a list if present
     * @return {?}
     */
    selectFirst() {
        if (!this.isListEmpty()) {
            let /** @type {?} */ row = this.data.getRows()[0];
            row.isSelected = true;
            this.data.selectedRow = row;
            this.currentInstanceId = row.getValue('id');
        }
        else {
            if (this.data) {
                this.data.selectedRow = null;
            }
            this.currentInstanceId = null;
        }
    }
    /**
     * Return the current id
     * @return {?}
     */
    getCurrentId() {
        return this.currentInstanceId;
    }
    /**
     * Check if the list is empty
     * @return {?}
     */
    isListEmpty() {
        return this.data === undefined ||
            (this.data && this.data.getRows() && this.data.getRows().length === 0);
    }
    /**
     * Emit the event rowClick passing the current task id when the row is clicked
     * @param {?} event
     * @return {?}
     */
    onRowClick(event) {
        let /** @type {?} */ item = event;
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    /**
     * Emit the event rowClick passing the current task id when pressed the Enter key on the selected row
     * @param {?} event
     * @return {?}
     */
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    /**
     * Optimize name field
     * @param {?} instances
     * @return {?}
     */
    optimizeNames(instances) {
        instances = instances.map(t => {
            t.obj.name = this.getProcessNameOrDescription(t.obj, 'medium');
            return t;
        });
        return instances;
    }
    /**
     * @param {?} processInstance
     * @param {?} dateFormat
     * @return {?}
     */
    getProcessNameOrDescription(processInstance, dateFormat) {
        let /** @type {?} */ name = '';
        if (processInstance) {
            name = processInstance.name ||
                processInstance.processDefinitionName + ' - ' + this.getFormatDate(processInstance.started, dateFormat);
        }
        return name;
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    getFormatDate(value, format) {
        let /** @type {?} */ datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            return '';
        }
    }
    /**
     * @return {?}
     */
    createRequestNode() {
        let /** @type {?} */ requestNode = {
            appDefinitionId: this.appId,
            state: this.state,
            sort: this.sort
        };
        return new ProcessFilterParamRepresentationModel(requestNode);
    }
    /**
     * @param {?=} preset
     * @return {?}
     */
    setupDefaultColumns(preset = 'default') {
        if (this.data) {
            const /** @type {?} */ columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    }
    /**
     * @return {?}
     */
    loadLayoutPresets() {
        const /** @type {?} */ externalSettings = this.appConfig.get('adf-process-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, processPresetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = processPresetsDefaultModel;
        }
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    getLayoutPreset(name = 'default') {
        return (this.layoutPresets[name] || this.layoutPresets['default']).map(col => new ObjectDataColumn(col));
    }
}
ProcessInstanceListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-list',
                styles: [`
      adf-datatable >>> .column-header {
          color: #232323;
          font-size: 15px;
      }

      adf-datatable >>> .data-cell {
          cursor: pointer !important;
      }

      adf-datatable >>> .cell-value{
          width: 250px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis
      }

      .adf-process-list-loading-margin {
          margin-left: calc((100% - 100px) / 2);
          margin-right: calc((100% - 100px) / 2);
      }

      .no-content-message {
          font-size: 16px;
          font-weight: bold;
          text-align: center;
          opacity: 0.54;
          color: #000;
      }
    `],
                template: `
      <div *ngIf="!requestNode">{{ 'ADF_PROCESS_LIST.FILTERS.MESSAGES.NONE' | translate }}</div>
      <div *ngIf="requestNode">
          <adf-datatable
              [data]="data"
              [loading]="isLoading"
              (rowClick)="onRowClick($event)"
              (row-keyup)="onRowKeyUp($event)">
              <loading-content-template>
                  <ng-template>
                      <!--Add your custom loading template here-->
                      <mat-progress-spinner
                          class="adf-process-list-loading-margin"
                          [color]="'primary'"
                          [mode]="'indeterminate'">
                      </mat-progress-spinner>
                  </ng-template>
              </loading-content-template>
              <no-content-template>
                  <!--Add your custom empty template here-->
                  <ng-template>
                      <div class="no-content-message">
                          {{ 'ADF_PROCESS_LIST.LIST.NONE' | translate }}
                      </div>
                  </ng-template>
              </no-content-template>
          </adf-datatable>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
ProcessInstanceListComponent.ctorParameters = () => [
    { type: ProcessService, },
    { type: AppConfigService, },
];
ProcessInstanceListComponent.propDecorators = {
    'columnList': [{ type: ContentChild, args: [DataColumnListComponent,] },],
    'appId': [{ type: Input },],
    'processDefinitionKey': [{ type: Input },],
    'state': [{ type: Input },],
    'sort': [{ type: Input },],
    'name': [{ type: Input },],
    'presetColumn': [{ type: Input },],
    'data': [{ type: Input },],
    'rowClick': [{ type: Output },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartProcessInstanceComponent {
    /**
     * @param {?} activitiProcess
     */
    constructor(activitiProcess) {
        this.activitiProcess = activitiProcess;
        this.start = new EventEmitter();
        this.cancel = new EventEmitter();
        this.error = new EventEmitter();
        this.processDefinitions = [];
        this.currentProcessDef = new ProcessDefinitionRepresentation();
        this.errorMessageId = '';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ appIdChange = changes['appId'];
        let /** @type {?} */ appId = appIdChange ? appIdChange.currentValue : null;
        this.load(appId);
    }
    /**
     * @param {?=} appId
     * @return {?}
     */
    load(appId) {
        this.resetSelectedProcessDefinition();
        this.resetErrorMessage();
        this.activitiProcess.getProcessDefinitions(appId).subscribe((res) => {
            this.processDefinitions = res;
        }, () => {
            this.errorMessageId = 'ADF_PROCESS_LIST.START_PROCESS.ERROR.LOAD_PROCESS_DEFS';
        });
    }
    /**
     * @param {?=} outcome
     * @return {?}
     */
    startProcess(outcome) {
        if (this.currentProcessDef.id && this.name) {
            this.resetErrorMessage();
            let /** @type {?} */ formValues = this.startForm ? this.startForm.form.values : undefined;
            this.activitiProcess.startProcess(this.currentProcessDef.id, this.name, outcome, formValues, this.variables).subscribe((res) => {
                this.name = '';
                this.start.emit(res);
            }, (err) => {
                this.errorMessageId = 'ADF_PROCESS_LIST.START_PROCESS.ERROR.START';
                this.error.error(err);
            });
        }
    }
    /**
     * @param {?} processDefinitionId
     * @return {?}
     */
    onProcessDefChange(processDefinitionId) {
        let /** @type {?} */ processDef = this.processDefinitions.find((processDefinition) => {
            return processDefinition.id === processDefinitionId;
        });
        if (processDef) {
            this.currentProcessDef = JSON.parse(JSON.stringify(processDef));
        }
        else {
            this.resetSelectedProcessDefinition();
        }
    }
    /**
     * @return {?}
     */
    cancelStartProcess() {
        this.cancel.emit();
    }
    /**
     * @return {?}
     */
    hasStartForm() {
        return this.currentProcessDef && this.currentProcessDef.hasStartForm;
    }
    /**
     * @return {?}
     */
    isProcessDefinitionEmpty() {
        return this.processDefinitions ? (this.processDefinitions.length > 0 || this.errorMessageId) : this.errorMessageId;
    }
    /**
     * @return {?}
     */
    isStartFormMissingOrValid() {
        if (this.startForm) {
            return this.startForm.form && this.startForm.form.isValid;
        }
        else {
            return true;
        }
    }
    /**
     * @return {?}
     */
    validateForm() {
        return this.currentProcessDef.id && this.name && this.isStartFormMissingOrValid();
    }
    /**
     * @return {?}
     */
    resetSelectedProcessDefinition() {
        this.currentProcessDef = new ProcessDefinitionRepresentation();
    }
    /**
     * @return {?}
     */
    resetErrorMessage() {
        this.errorMessageId = '';
    }
    /**
     * @return {?}
     */
    hasErrorMessage() {
        return this.processDefinitions.length === 0 && !this.errorMessageId;
    }
    /**
     * @param {?} outcome
     * @return {?}
     */
    onOutcomeClick(outcome) {
        this.startProcess(outcome);
    }
    /**
     * @return {?}
     */
    reset() {
        this.resetSelectedProcessDefinition();
        this.name = '';
        if (this.startForm) {
            this.startForm.data = {};
        }
        this.resetErrorMessage();
    }
    /**
     * @return {?}
     */
    hasProcessName() {
        return this.name ? true : false;
    }
}
StartProcessInstanceComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-process',
                template: `
      <mat-card class="adf-start-process">
      	<mat-card-title>{{'ADF_PROCESS_LIST.START_PROCESS.FORM.TITLE' | translate}}
      	</mat-card-title>
      	<mat-card-content *ngIf="isProcessDefinitionEmpty()">
      		<mat-card-subtitle id="error-message" *ngIf="errorMessageId">
      			{{errorMessageId|translate}}
      		</mat-card-subtitle>
      		<mat-form-field class="adf-process-input-container">
      			<input matInput placeholder="{{'ADF_PROCESS_LIST.START_PROCESS.FORM.LABEL.NAME'|translate}}" [(ngModel)]="name" id="processName" required />
      		</mat-form-field>
              <mat-form-field>
                  <mat-select placeholder="{{'ADF_PROCESS_LIST.START_PROCESS.FORM.LABEL.TYPE'|translate}}" [(ngModel)]="currentProcessDef.id" (ngModelChange)="onProcessDefChange($event)" required>
                      <mat-option>{{'ADF_PROCESS_LIST.START_PROCESS.FORM.TYPE_PLACEHOLDER' | translate}}</mat-option>
                      <mat-option *ngFor="let processDef of processDefinitions" [value]="processDef.id">
                          {{ processDef.name }}
                      </mat-option>
                  </mat-select>
              </mat-form-field>
              <adf-start-form *ngIf="hasStartForm()"
                  [disableStartProcessButton]="!hasProcessName()"
      			[processDefinitionId]="currentProcessDef.id"
      			(outcomeClick)="onOutcomeClick($event)"
      		    [showRefreshButton]="false">
      		<button form-custom-button mat-button (click)="cancelStartProcess()" id="cancle_process" class=""> {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.CANCEL'| translate}} </button>
      		</adf-start-form>
      	</mat-card-content>
      	<mat-card-content *ngIf="hasErrorMessage()">
      		<mat-card-subtitle class="error-message" id="no-process-message">
      			{{'ADF_PROCESS_LIST.START_PROCESS.NO_PROCESS_DEFINITIONS' | translate}}
      		</mat-card-subtitle>
      	</mat-card-content>
      	<mat-card-actions *ngIf="!hasStartForm()">
      		<button mat-button *ngIf="!hasStartForm()" (click)="cancelStartProcess()" id="cancle_process" class=""> {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.CANCEL'| translate}} </button>
      		<button mat-button *ngIf="!hasStartForm()" [disabled]="!validateForm()" (click)="startProcess()" data-automation-id="btn-start" id="button-start" class="btn-start"> {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.START' | translate}} </button>
      	</mat-card-actions>
      </mat-card>
    `,
                styles: [`
      .adf-start-process {
        width: calc(66.6666% - 48px);
        margin-left: calc(33.3333333333% / 2);
        margin-right: calc(33.3333333333% / 2);
        margin-top: 10px; }
        .adf-start-process .mat-select-trigger {
          font-size: 14px !important; }
        .adf-start-process mat-form-field {
          width: 100%; }
        .adf-start-process mat-select {
          width: 100%;
          padding: 16px 0px 0px 0px; }
        .adf-start-process mat-card-actions {
          text-align: right; }

      .adf-process-input-container mat-form-field {
        width: 100%; }

      .adf-start-form-container .mat-card {
        -webkit-box-shadow: none !important;
                box-shadow: none !important;
        padding: 0px !important; }

      .adf-start-form-actions {
        text-align: right !important; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
StartProcessInstanceComponent.ctorParameters = () => [
    { type: ProcessService, },
];
StartProcessInstanceComponent.propDecorators = {
    'appId': [{ type: Input },],
    'variables': [{ type: Input },],
    'start': [{ type: Output },],
    'cancel': [{ type: Output },],
    'error': [{ type: Output },],
    'startForm': [{ type: ViewChild, args: [StartFormComponent,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessListModule {
}
ProcessListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    DataTableModule,
                    FormModule,
                    TaskListModule,
                    MaterialModule,
                    FlexLayoutModule,
                    TranslateModule,
                    CardViewModule,
                    FormsModule,
                    ReactiveFormsModule,
                    PipeModule,
                    DataColumnModule,
                    DirectiveModule,
                    PeopleModule,
                    CommentsModule
                ],
                declarations: [
                    ProcessInstanceListComponent,
                    ProcessFiltersComponent,
                    ProcessInstanceDetailsComponent,
                    ProcessAuditDirective,
                    ProcessInstanceHeaderComponent,
                    ProcessInstanceTasksComponent,
                    StartProcessInstanceComponent
                ],
                providers: [
                    ProcessService,
                    ProcessFilterService,
                    CardViewUpdateService
                ],
                exports: [
                    ProcessInstanceListComponent,
                    ProcessFiltersComponent,
                    ProcessInstanceDetailsComponent,
                    ProcessAuditDirective,
                    ProcessInstanceHeaderComponent,
                    ProcessInstanceTasksComponent,
                    StartProcessInstanceComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
ProcessListModule.ctorParameters = () => [];

class IconModel {
    constructor() {
        this.initIconsMDL();
    }
    /**
     * @param {?} icon
     * @return {?}
     */
    mapGlyphiconToMaterialDesignIcons(icon) {
        return this.iconsMDL.get(icon) ? this.iconsMDL.get(icon) : IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON;
    }
    /**
     * Map all the bootstrap glyphicon icons with Material design material icon
     * @return {?}
     */
    initIconsMDL() {
        this.iconsMDL = new Map();
        this.iconsMDL.set('glyphicon-asterisk', 'ac_unit');
        this.iconsMDL.set('glyphicon-plus', 'add');
        this.iconsMDL.set('glyphicon-euro', 'euro_symbol');
        this.iconsMDL.set('glyphicon-cloud', 'cloud');
        this.iconsMDL.set('glyphicon-envelope', 'mail');
        this.iconsMDL.set('glyphicon-pencil', 'create');
        this.iconsMDL.set('glyphicon-glass', 'local_bar');
        this.iconsMDL.set('glyphicon-music', 'music_note');
        this.iconsMDL.set('glyphicon-search', 'search');
        this.iconsMDL.set('glyphicon-heart', 'favorite');
        this.iconsMDL.set('glyphicon-heart-empty', 'favorite_border');
        this.iconsMDL.set('glyphicon-star', 'star');
        this.iconsMDL.set('glyphicon-star-empty', 'star_border');
        this.iconsMDL.set('glyphicon-user', 'person');
        this.iconsMDL.set('glyphicon-film', 'movie_creation');
        this.iconsMDL.set('glyphicon-th-large', 'view_comfy');
        this.iconsMDL.set('glyphicon-th', 'view_compact');
        this.iconsMDL.set('glyphicon-th-list', 'list');
        this.iconsMDL.set('glyphicon-ok', 'done');
        this.iconsMDL.set('glyphicon-remove', 'cancel');
        this.iconsMDL.set('glyphicon-zoom-in', 'zoom_in');
        this.iconsMDL.set('glyphicon-zoom-out', 'zoom_out');
        this.iconsMDL.set('glyphicon-off', 'highlight_off');
        this.iconsMDL.set('glyphicon-signal', 'signal_cellular_4_bar');
        this.iconsMDL.set('glyphicon-cog', 'settings');
        this.iconsMDL.set('glyphicon-trash', 'delete');
        this.iconsMDL.set('glyphicon-home', 'home');
        this.iconsMDL.set('glyphicon-file', 'insert_drive_file');
        this.iconsMDL.set('glyphicon-time', 'access_time');
        this.iconsMDL.set('glyphicon-road', 'map');
        this.iconsMDL.set('glyphicon-download-alt', 'file_download');
        this.iconsMDL.set('glyphicon-download', 'file_download');
        this.iconsMDL.set('glyphicon-upload', 'file_upload');
        this.iconsMDL.set('glyphicon-inbox', 'inbox');
        this.iconsMDL.set('glyphicon-play-circle', 'play_circle_outline');
        this.iconsMDL.set('glyphicon-repeat', 'refresh');
        this.iconsMDL.set('glyphicon-refresh', 'sync');
        this.iconsMDL.set('glyphicon-list-alt', 'event_note');
        this.iconsMDL.set('glyphicon-lock', 'lock_outline');
        this.iconsMDL.set('glyphicon-flag', 'assistant_photo');
        this.iconsMDL.set('glyphicon-headphones', 'headset');
        this.iconsMDL.set('glyphicon-volume-up', 'volume_up');
        this.iconsMDL.set('glyphicon-tag', 'local_offer');
        this.iconsMDL.set('glyphicon-tags', 'local_offer');
        this.iconsMDL.set('glyphicon-book', 'library_books');
        this.iconsMDL.set('glyphicon-bookmark', 'collections_bookmark');
        this.iconsMDL.set('glyphicon-print', 'local_printshop');
        this.iconsMDL.set('glyphicon-camera', 'local_see');
        this.iconsMDL.set('glyphicon-list', 'view_list');
        this.iconsMDL.set('glyphicon-facetime-video', 'video_call');
        this.iconsMDL.set('glyphicon-picture', 'photo');
        this.iconsMDL.set('glyphicon-map-marker', 'add_location');
        this.iconsMDL.set('glyphicon-adjust', 'brightness_4');
        this.iconsMDL.set('glyphicon-tint', 'invert_colors');
        this.iconsMDL.set('glyphicon-edit', 'edit');
        this.iconsMDL.set('glyphicon-share', 'share');
        this.iconsMDL.set('glyphicon-check', 'assignment_turned_in');
        this.iconsMDL.set('glyphicon-move', 'open_with');
        this.iconsMDL.set('glyphicon-play', 'play_arrow');
        this.iconsMDL.set('glyphicon-eject', 'eject');
        this.iconsMDL.set('glyphicon-plus-sign', 'add_circle');
        this.iconsMDL.set('glyphicon-minus-sign', 'remove_circle');
        this.iconsMDL.set('glyphicon-remove-sign', 'cancel');
        this.iconsMDL.set('glyphicon-ok-sign', 'check_circle');
        this.iconsMDL.set('glyphicon-question-sign', 'help');
        this.iconsMDL.set('glyphicon-info-sign', 'info');
        this.iconsMDL.set('glyphicon-screenshot', 'flare');
        this.iconsMDL.set('glyphicon-remove-circle', 'cancel');
        this.iconsMDL.set('glyphicon-ok-circle', 'add_circle');
        this.iconsMDL.set('glyphicon-ban-circle', 'block');
        this.iconsMDL.set('glyphicon-share-alt', 'redo');
        this.iconsMDL.set('glyphicon-exclamation-sign', 'error');
        this.iconsMDL.set('glyphicon-gift', 'giftcard');
        this.iconsMDL.set('glyphicon-leaf', 'spa');
        this.iconsMDL.set('glyphicon-fire', 'whatshot');
        this.iconsMDL.set('glyphicon-eye-open', 'remove_red_eye');
        this.iconsMDL.set('glyphicon-eye-close', 'remove_red_eye');
        this.iconsMDL.set('glyphicon-warning-sign', 'warning');
        this.iconsMDL.set('glyphicon-plane', 'airplanemode_active');
        this.iconsMDL.set('glyphicon-calendar', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-random', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-comment', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-magnet', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-retweet', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-shopping-cart', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-folder-close', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-folder-open', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-hdd', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-bullhorn', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-bell', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-certificate', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-thumbs-up', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-thumbs-down', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-hand-left', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-globe', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-wrench', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tasks', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-filter', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-briefcase', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-dashboard', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-paperclip', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-link', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-phone', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-pushpin', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-usd', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-gbp', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-sort', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-flash', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-record', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-save', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-open', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-saved', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-send', 'send');
        this.iconsMDL.set('glyphicon-floppy-disk', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-credit-card', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cutlery', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-earphone', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-phone-alt', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tower', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-stats', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cloud-download', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cloud-upload', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tree-conifer', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tree-deciduous', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
    }
}
IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON = 'favorite_border';

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppsListComponent {
    /**
     * @param {?} appsProcessService
     * @param {?} translationService
     */
    constructor(appsProcessService, translationService) {
        this.appsProcessService = appsProcessService;
        this.translationService = translationService;
        this.layoutType = AppsListComponent.LAYOUT_GRID;
        this.appClick = new EventEmitter();
        this.error = new EventEmitter();
        this.appList = [];
        this.apps$ = new Observable$1(observer => this.appsObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.isValidType()) {
            this.setDefaultLayoutType();
        }
        this.apps$.subscribe((app) => {
            this.appList.push(app);
        });
        this.iconsMDL = new IconModel();
        this.load();
    }
    /**
     * @return {?}
     */
    load() {
        this.appsProcessService.getDeployedApplications()
            .subscribe((res) => {
            this.filterApps(res).forEach((app) => {
                if (this.isDefaultApp(app)) {
                    app.theme = AppsListComponent.DEFAULT_TASKS_APP_THEME;
                    app.icon = AppsListComponent.DEFAULT_TASKS_APP_ICON;
                    this.appsObserver.next(app);
                }
                else if (app.deploymentId) {
                    this.appsObserver.next(app);
                }
            });
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} app
     * @return {?}
     */
    isDefaultApp(app) {
        return app.defaultAppId === AppsListComponent.DEFAULT_TASKS_APP;
    }
    /**
     * @param {?} app
     * @return {?}
     */
    getAppName(app) {
        return this.isDefaultApp(app)
            ? this.translationService.get(AppsListComponent.DEFAULT_TASKS_APP_NAME)
            : Observable$1.of(app.name);
    }
    /**
     * Pass the selected app as next
     * @param {?} app
     * @return {?}
     */
    selectApp(app) {
        this.currentApp = app;
        this.appClick.emit(app);
    }
    /**
     * Return true if the appId is the current app
     * @param {?} appId
     * @return {?}
     */
    isSelected(appId) {
        return (this.currentApp !== undefined && appId === this.currentApp.id);
    }
    /**
     * @param {?} apps
     * @return {?}
     */
    filterApps(apps) {
        let /** @type {?} */ filteredApps = [];
        if (this.filtersAppId) {
            apps.filter((app) => {
                this.filtersAppId.forEach((filter) => {
                    if (app.defaultAppId === filter.defaultAppId ||
                        app.deploymentId === filter.deploymentId ||
                        app.name === filter.name ||
                        app.id === filter.id ||
                        app.modelId === filter.modelId ||
                        app.tenantId === filter.tenantId) {
                        filteredApps.push(app);
                    }
                });
            });
        }
        else {
            return apps;
        }
        return filteredApps;
    }
    /**
     * Check if the value of the layoutType property is an allowed value
     * @return {?}
     */
    isValidType() {
        if (this.layoutType && (this.layoutType === AppsListComponent.LAYOUT_LIST || this.layoutType === AppsListComponent.LAYOUT_GRID)) {
            return true;
        }
        return false;
    }
    /**
     * Assign the default value to LayoutType
     * @return {?}
     */
    setDefaultLayoutType() {
        this.layoutType = AppsListComponent.LAYOUT_GRID;
    }
    /**
     * Return true if the layout type is LIST
     * @return {?}
     */
    isList() {
        return this.layoutType === AppsListComponent.LAYOUT_LIST;
    }
    /**
     * Return true if the layout type is GRID
     * @return {?}
     */
    isGrid() {
        return this.layoutType === AppsListComponent.LAYOUT_GRID;
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.appList.length === 0;
    }
    /**
     * @param {?} app
     * @return {?}
     */
    getTheme(app) {
        return app.theme ? app.theme : '';
    }
    /**
     * @param {?} app
     * @return {?}
     */
    getBackgroundIcon(app) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(app.icon);
    }
}
AppsListComponent.LAYOUT_LIST = 'LIST';
AppsListComponent.LAYOUT_GRID = 'GRID';
AppsListComponent.DEFAULT_TASKS_APP = 'tasks';
AppsListComponent.DEFAULT_TASKS_APP_NAME = 'ADF_TASK_LIST.APPS.TASK_APP_NAME';
AppsListComponent.DEFAULT_TASKS_APP_THEME = 'theme-2';
AppsListComponent.DEFAULT_TASKS_APP_ICON = 'glyphicon-asterisk';
AppsListComponent.DEFAULT_TASKS_APP_MATERIAL_ICON = 'favorite_border';
AppsListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-apps',
                template: `
      <div class="menu-container" *ngIf="!isEmpty()">
          <mat-list *ngIf="isList()" class="adf-app-list">
              <mat-list-item class="adf-app-list-item" (click)="selectApp(app)" (keyup.enter)="selectApp(app)" *ngFor="let app of appList" tabindex="0" role="button" title="{{app.name}}">
                  <mat-icon matListIcon>touch_app</mat-icon>
                  <span matLine>{{getAppName(app) | async}}</span>
              </mat-list-item>
          </mat-list>
          <div fxLayout="row wrap" *ngIf="isGrid()" class="adf-app-listgrid">
              <div *ngFor="let app of appList"
                  class="adf-app-listgrid-item"
                  fxFlex="33.33333%" fxFlex.lt-md="50%" fxFlex.lt-sm="100%">
                      <mat-card tabindex="0"
                          fxLayout="column"
                          role="button"
                          class="adf-app-listgrid-item-card"
                          title="{{getAppName(app) | async}}"
                          [ngClass]="[getTheme(app)]"
                          (click)="selectApp(app)"
                          (keyup.enter)="selectApp(app)">
                              <div class="adf-app-listgrid-item-card-logo">
                                  <mat-icon class="adf-app-listgrid-item-card-logo-icon">{{getBackgroundIcon(app)}}</mat-icon>
                              </div>
                              <div mat-card-title class="adf-app-listgrid-item-card-title">
                                  <h1>{{getAppName(app) | async}}</h1>
                              </div>
                              <mat-card-subtitle class="adf-app-listgrid-item-card-subtitle" fxFlex="1 0 auto">
                                  <p>{{app.description}}</p>
                              </mat-card-subtitle>

                              <mat-card-actions class="adf-app-listgrid-item-card-actions">
                                  <mat-icon class="adf-app-listgrid-item-card-actions-icon" *ngIf="isSelected(app.id)">done</mat-icon>
                              </mat-card-actions>
                      </mat-card>
              </div>
          </div>
      </div>
      <div class="menu-container" *ngIf="isEmpty()">
          {{ 'ADF_TASK_LIST.APPS.NONE' | translate }}
      </div>
    `,
                styles: [`
      :host {
        width: 100%; }

      .adf-app-list-item {
        cursor: pointer; }

      .adf-app-listgrid {
        padding: 8px; }
        .adf-app-listgrid-item {
          outline: none;
          padding: 8px;
          -webkit-box-sizing: border-box;
                  box-sizing: border-box; }
          .adf-app-listgrid-item-card {
            outline: none;
            -webkit-transition: -webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);
            transition: -webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);
            transition: transform 280ms cubic-bezier(0.4, 0, 0.2, 1), box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);
            transition: transform 280ms cubic-bezier(0.4, 0, 0.2, 1), box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 200px;
            padding: 0; }
            .adf-app-listgrid-item-card.theme-1 {
              background-color: #269abc; }
            .adf-app-listgrid-item-card.theme-2 {
              background-color: #7da9b0; }
            .adf-app-listgrid-item-card.theme-3 {
              background-color: #7689ab; }
            .adf-app-listgrid-item-card.theme-4 {
              background-color: #c74e3e; }
            .adf-app-listgrid-item-card.theme-5 {
              background-color: #fab96c; }
            .adf-app-listgrid-item-card.theme-6 {
              background-color: #759d4c; }
            .adf-app-listgrid-item-card.theme-7 {
              background-color: #b1b489; }
            .adf-app-listgrid-item-card.theme-8 {
              background-color: #a17299; }
            .adf-app-listgrid-item-card.theme-9 {
              background-color: #696c67; }
            .adf-app-listgrid-item-card.theme-10 {
              background-color: #cabb33; }
            .adf-app-listgrid-item-card:hover {
              -webkit-box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.2);
                      box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.2);
              cursor: pointer;
              -webkit-transform: scale(1.015);
                      transform: scale(1.015); }
            .adf-app-listgrid-item-card-logo {
              position: absolute;
              right: 20px;
              top: 20px;
              padding: 16px; }
              .adf-app-listgrid-item-card-logo-icon {
                font-size: 70px;
                width: 1em;
                height: 1em; }
                .theme-1 .adf-app-listgrid-item-card-logo-icon {
                  color: #168aac; }
                .theme-2 .adf-app-listgrid-item-card-logo-icon {
                  color: #6d99a0; }
                .theme-3 .adf-app-listgrid-item-card-logo-icon {
                  color: #66799b; }
                .theme-4 .adf-app-listgrid-item-card-logo-icon {
                  color: #b73e2e; }
                .theme-5 .adf-app-listgrid-item-card-logo-icon {
                  color: #eaa95c; }
                .theme-6 .adf-app-listgrid-item-card-logo-icon {
                  color: #658d3c; }
                .theme-7 .adf-app-listgrid-item-card-logo-icon {
                  color: #a1a479; }
                .theme-8 .adf-app-listgrid-item-card-logo-icon {
                  color: #916289; }
                .theme-9 .adf-app-listgrid-item-card-logo-icon {
                  color: #595c57; }
                .theme-10 .adf-app-listgrid-item-card-logo-icon {
                  color: #baab23; }
            .adf-app-listgrid-item-card-title {
              padding: 16px; }
              .adf-app-listgrid-item-card-title h1 {
                color: white;
                width: 80%;
                font-size: 24px;
                margin: 0;
                line-height: normal;
                white-space: nowrap;
                text-overflow: ellipsis;
                overflow: hidden; }
            .adf-app-listgrid-item-card-subtitle {
              padding: 16px; }
            .adf-app-listgrid-item-card-actions {
              padding: 0 16px 16px 16px;
              border-top: 1px solid rgba(0, 0, 0, 0.1);
              min-height: 48px;
              -webkit-box-sizing: border-box;
                      box-sizing: border-box; }
              .adf-app-listgrid-item-card-actions-icon {
                color: #e9f1f3; }
              .adf-app-listgrid-item-card-actions.mat-card-actions {
                margin-left: 0px;
                margin-right: 0px; }
                .adf-app-listgrid-item-card-actions.mat-card-actions:last-child {
                  margin-bottom: 0; }
    `]
            },] },
];
/**
 * @nocollapse
 */
AppsListComponent.ctorParameters = () => [
    { type: AppsProcessService, },
    { type: TranslationService, },
];
AppsListComponent.propDecorators = {
    'layoutType': [{ type: Input },],
    'filtersAppId': [{ type: Input },],
    'appClick': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppsListModule {
}
AppsListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule,
                    TranslateModule
                ],
                declarations: [
                    AppsListComponent
                ],
                providers: [],
                exports: [
                    AppsListComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
AppsListModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskAttachmentListComponent {
    /**
     * @param {?} activitiContentService
     * @param {?} contentService
     * @param {?} thumbnailService
     * @param {?} ngZone
     */
    constructor(activitiContentService, contentService, thumbnailService, ngZone) {
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.ngZone = ngZone;
        this.disabled = false;
        this.attachmentClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.hasCustomTemplate = false;
        this.attachments = [];
        this.isLoading = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['taskId'] && changes['taskId'].currentValue) {
            this.loadAttachmentsByTaskId(changes['taskId'].currentValue);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.emptyTemplate) {
            this.hasCustomTemplate = true;
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.attachments = [];
    }
    /**
     * @return {?}
     */
    hasCutomEmptyTemplate() {
        return !!this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    reload() {
        this.ngZone.run(() => {
            this.loadAttachmentsByTaskId(this.taskId);
        });
    }
    /**
     * @param {?} content
     * @return {?}
     */
    add(content) {
        this.ngZone.run(() => {
            this.attachments.push({
                id: content.id,
                name: content.name,
                created: content.created,
                createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
            });
        });
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    loadAttachmentsByTaskId(taskId) {
        if (taskId) {
            this.isLoading = true;
            this.reset();
            this.activitiContentService.getTaskRelatedContent(taskId).subscribe((res) => {
                let /** @type {?} */ attachList = [];
                res.data.forEach(content => {
                    attachList.push({
                        id: content.id,
                        name: content.name,
                        created: content.created,
                        createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                        icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
                    });
                });
                this.attachments = attachList;
                this.success.emit(this.attachments);
                this.isLoading = false;
            }, (err) => {
                this.error.emit(err);
                this.isLoading = false;
            });
        }
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    deleteAttachmentById(contentId) {
        if (contentId) {
            this.activitiContentService.deleteRelatedContent(contentId).subscribe((res) => {
                this.attachments = this.attachments.filter(content => {
                    return content.id !== contentId;
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.attachments && this.attachments.length === 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        let /** @type {?} */ viewAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.VIEW_CONTENT',
            name: 'view'
        };
        let /** @type {?} */ removeAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.REMOVE_CONTENT',
            name: 'remove'
        };
        let /** @type {?} */ downloadAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.DOWNLOAD_CONTENT',
            name: 'download'
        };
        event.value.actions = [
            viewAction,
            downloadAction
        ];
        if (!this.disabled) {
            event.value.actions.splice(1, 0, removeAction);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        let /** @type {?} */ args = event.value;
        let /** @type {?} */ action = args.action;
        if (action.name === 'view') {
            this.emitDocumentContent(args.row.obj);
        }
        else if (action.name === 'remove') {
            this.deleteAttachmentById(args.row.obj.id);
        }
        else if (action.name === 'download') {
            this.downloadContent(args.row.obj);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openContent(event) {
        let /** @type {?} */ content = event.value.obj;
        this.emitDocumentContent(content);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    emitDocumentContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((blob) => {
            content.contentBlob = blob;
            this.attachmentClick.emit(content);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} content
     * @return {?}
     */
    downloadContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((blob) => this.contentService.downloadBlob(blob, content.name), (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @return {?}
     */
    isDisabled() {
        return this.disabled;
    }
}
TaskAttachmentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-attachment-list',
                styles: [`

    `],
                template: `
      <adf-datatable [rows]="attachments"
                     [actions]="true"
                     [loading]="isLoading"
                     (rowDblClick)="openContent($event)"
                     (showRowActionsMenu)="onShowRowActionsMenu($event)"
                     (executeRowAction)="onExecuteRowAction($event)">
                  <no-content-template>
                      <ng-template>
                          <ng-content *ngIf="hasCustomTemplate; else defaulEmptyList" class="adf-custom-empty-template"></ng-content>
                          <ng-template #defaulEmptyList>
                              <adf-empty-list>
                                  <div adf-empty-list-header class="adf-empty-list-header">
                                      {{'ADF_TASK_LIST.ATTACHMENT.EMPTY.HEADER' | translate}}
                                  </div>
                              </adf-empty-list>
                          </ng-template>
                      </ng-template>
                  </no-content-template>

                  <data-columns>
                      <data-column key="icon" type="image" srTitle="ADF_TASK_LIST.PROPERTIES.THUMBNAIL" [sortable]="false"></data-column>
                      <data-column key="name" type="text" title="ADF_TASK_LIST.PROPERTIES.NAME" class="full-width ellipsis-cell" [sortable]="true"></data-column>
                      <data-column key="created" type="date" format="shortDate" title="ADF_TASK_LIST.PROPERTIES.CREATED"></data-column>
                  </data-columns>
                  <loading-content-template>
                      <ng-template>
                      <!--Add your custom loading template here-->
                          <mat-progress-spinner class="adf-attachment-list-loading-margin" [color]="'primary'" [mode]="'indeterminate'">
                          </mat-progress-spinner>
                      </ng-template>
                  </loading-content-template>
      </adf-datatable>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TaskAttachmentListComponent.ctorParameters = () => [
    { type: ProcessContentService, },
    { type: ContentService, },
    { type: ThumbnailService, },
    { type: NgZone, },
];
TaskAttachmentListComponent.propDecorators = {
    'emptyTemplate': [{ type: ContentChild, args: [EmptyListComponent,] },],
    'taskId': [{ type: Input },],
    'disabled': [{ type: Input },],
    'attachmentClick': [{ type: Output },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'customTemplateRef': [{ type: ViewChild, args: ['customEmptyListTemplate',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessAttachmentListComponent {
    /**
     * @param {?} activitiContentService
     * @param {?} contentService
     * @param {?} thumbnailService
     * @param {?} ngZone
     */
    constructor(activitiContentService, contentService, thumbnailService, ngZone) {
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.ngZone = ngZone;
        this.disabled = false;
        this.attachmentClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.emptyListImageUrl = './assets/images/empty_doc_lib.svg';
        this.attachments = [];
        this.isLoading = true;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['processInstanceId'] && changes['processInstanceId'].currentValue) {
            this.loadAttachmentsByProcessInstanceId(changes['processInstanceId'].currentValue);
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.attachments = [];
    }
    /**
     * @return {?}
     */
    reload() {
        this.ngZone.run(() => {
            this.loadAttachmentsByProcessInstanceId(this.processInstanceId);
        });
    }
    /**
     * @param {?} content
     * @return {?}
     */
    add(content) {
        this.ngZone.run(() => {
            this.attachments.push({
                id: content.id,
                name: content.name,
                created: content.created,
                createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
            });
        });
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    loadAttachmentsByProcessInstanceId(processInstanceId) {
        if (processInstanceId) {
            this.reset();
            this.isLoading = true;
            this.activitiContentService.getProcessRelatedContent(processInstanceId).subscribe((res) => {
                res.data.forEach(content => {
                    this.attachments.push({
                        id: content.id,
                        name: content.name,
                        created: content.created,
                        createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                        icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
                    });
                });
                this.success.emit(this.attachments);
                this.isLoading = false;
            }, (err) => {
                this.error.emit(err);
                this.isLoading = false;
            });
        }
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    deleteAttachmentById(contentId) {
        if (contentId) {
            this.activitiContentService.deleteRelatedContent(contentId).subscribe((res) => {
                this.attachments = this.attachments.filter(content => {
                    return content.id !== contentId;
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.attachments && this.attachments.length === 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        let /** @type {?} */ viewAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.VIEW_CONTENT',
            name: 'view'
        };
        let /** @type {?} */ removeAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.REMOVE_CONTENT',
            name: 'remove'
        };
        let /** @type {?} */ downloadAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.DOWNLOAD_CONTENT',
            name: 'download'
        };
        event.value.actions = [
            viewAction,
            downloadAction
        ];
        if (!this.disabled) {
            event.value.actions.splice(1, 0, removeAction);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        let /** @type {?} */ args = event.value;
        let /** @type {?} */ action = args.action;
        if (action.name === 'view') {
            this.emitDocumentContent(args.row.obj);
        }
        else if (action.name === 'remove') {
            this.deleteAttachmentById(args.row.obj.id);
        }
        else if (action.name === 'download') {
            this.downloadContent(args.row.obj);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openContent(event) {
        let /** @type {?} */ content = event.value.obj;
        this.emitDocumentContent(content);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    emitDocumentContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((blob) => {
            content.contentBlob = blob;
            this.attachmentClick.emit(content);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} content
     * @return {?}
     */
    downloadContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((blob) => this.contentService.downloadBlob(blob, content.name), (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @return {?}
     */
    isDisabled() {
        return this.disabled;
    }
}
ProcessAttachmentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-attachment-list',
                styles: [`

    `],
                template: `
      <adf-datatable [rows]="attachments" [actions]="true" [loading]="isLoading" (rowDblClick)="openContent($event)" (showRowActionsMenu)="onShowRowActionsMenu($event)"
          (executeRowAction)="onExecuteRowAction($event)">

          <adf-empty-list *ngIf="isEmpty()">
              <div adf-empty-list-header class="adf-empty-list-header"> {{'ADF_PROCESS_LIST.PROCESS-ATTACHMENT.EMPTY.HEADER' | translate}} </div>
              <div adf-empty-list-body *ngIf="!isDisabled()">
                  <div fxHide.lt-md="true" class="adf-empty-list-drag_drop">{{'ADF_PROCESS_LIST.PROCESS-ATTACHMENT.EMPTY.DRAG-AND-DROP.TITLE' | translate}}</div>
                  <div fxHide.lt-md="true" class="adf-empty-list__any-files-here-to-add"> {{'ADF_PROCESS_LIST.PROCESS-ATTACHMENT.EMPTY.DRAG-AND-DROP.SUBTITLE' | translate}} </div>
              </div>
              <div adf-empty-list-footer *ngIf="!isDisabled()">
                  <img class="adf-empty-list__empty_doc_lib" [src]="emptyListImageUrl">
              </div>
          </adf-empty-list>

          <data-columns>
              <data-column key="icon" type="image" srTitle="ADF_PROCESS_LIST.PROPERTIES.THUMBNAIL" [sortable]="false"></data-column>
              <data-column key="name" type="text" title="{{'ADF_PROCESS_LIST.PROPERTIES.NAME' | translate}}" class="full-width ellipsis-cell" [sortable]="true"></data-column>
              <data-column key="created" type="date" format="shortDate" title="{{'ADF_PROCESS_LIST.PROPERTIES.CREATED' | translate}}"></data-column>
          </data-columns>

          <loading-content-template>
              <ng-template>
                  <!--Add your custom loading template here-->
                  <mat-progress-spinner class="adf-attachment-list-loading-margin" [color]="'primary'" [mode]="'indeterminate'">
                  </mat-progress-spinner>
              </ng-template>
          </loading-content-template>

      </adf-datatable>
    `
            },] },
];
/**
 * @nocollapse
 */
ProcessAttachmentListComponent.ctorParameters = () => [
    { type: ProcessContentService, },
    { type: ContentService, },
    { type: ThumbnailService, },
    { type: NgZone, },
];
ProcessAttachmentListComponent.propDecorators = {
    'processInstanceId': [{ type: Input },],
    'disabled': [{ type: Input },],
    'attachmentClick': [{ type: Output },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'emptyListImageUrl': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CreateProcessAttachmentComponent {
    /**
     * @param {?} activitiContentService
     */
    constructor(activitiContentService) {
        this.activitiContentService = activitiContentService;
        this.error = new EventEmitter();
        this.success = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['processInstanceId'] && changes['processInstanceId'].currentValue) {
            this.processInstanceId = changes['processInstanceId'].currentValue;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileUpload(event) {
        let /** @type {?} */ filesList = event.detail.files.map(obj => obj.file);
        for (let /** @type {?} */ fileInfoObj of filesList) {
            let /** @type {?} */ file = fileInfoObj;
            let /** @type {?} */ opts = {
                isRelatedContent: true
            };
            this.activitiContentService.createProcessRelatedContent(this.processInstanceId, file, opts).subscribe((res) => {
                this.success.emit(res);
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
}
CreateProcessAttachmentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-create-process-attachment',
                styles: [`
      .adf-create-attachment {
          display: inline-block;
          line-height: 0px;
          vertical-align: middle;
      }
    `],
                template: `
      <button
          id="add_new_process_content_button"
          color="primary"
          mat-button
          mat-raised-button
          mat-icon-button
          class="adf-create-attachment"
          [adf-upload]="true"
          mode="['click']"
          [multiple]="true"
          (upload-files)="onFileUpload($event)">
          <mat-icon>add</mat-icon>
      </button>
    `
            },] },
];
/**
 * @nocollapse
 */
CreateProcessAttachmentComponent.ctorParameters = () => [
    { type: ProcessContentService, },
];
CreateProcessAttachmentComponent.propDecorators = {
    'processInstanceId': [{ type: Input },],
    'error': [{ type: Output },],
    'success': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachmentComponent {
    /**
     * @param {?} activitiContentService
     */
    constructor(activitiContentService) {
        this.activitiContentService = activitiContentService;
        this.error = new EventEmitter();
        this.success = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['taskId'] && changes['taskId'].currentValue) {
            this.taskId = changes['taskId'].currentValue;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileUpload(event) {
        let /** @type {?} */ filesList = event.detail.files.map(obj => obj.file);
        for (let /** @type {?} */ fileInfoObj of filesList) {
            let /** @type {?} */ file = fileInfoObj;
            let /** @type {?} */ opts = {
                isRelatedContent: true
            };
            this.activitiContentService.createTaskRelatedContent(this.taskId, file, opts).subscribe((res) => {
                this.success.emit(res);
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
}
AttachmentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-create-task-attachment',
                styles: [`
      .adf-create-attachment {
        display: inline-block;
        line-height: 0px;
        vertical-align: middle; }
    `],
                template: `
      <button
          color="primary"
          mat-button
          mat-raised-button
          mat-icon-button
          class="adf-create-attachment"
          [adf-upload]="true"
          mode="['click']"
          [multiple]="true"
          (upload-files)="onFileUpload($event)">
          <mat-icon>add</mat-icon>
      </button>
    `
            },] },
];
/**
 * @nocollapse
 */
AttachmentComponent.ctorParameters = () => [
    { type: ProcessContentService, },
];
AttachmentComponent.propDecorators = {
    'taskId': [{ type: Input },],
    'error': [{ type: Output },],
    'success': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachmentModule {
}
AttachmentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    DataColumnModule,
                    DataTableModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule,
                    DirectiveModule
                ],
                declarations: [
                    TaskAttachmentListComponent,
                    ProcessAttachmentListComponent,
                    CreateProcessAttachmentComponent,
                    CreateProcessAttachmentComponent,
                    AttachmentComponent
                ],
                exports: [
                    TaskAttachmentListComponent,
                    ProcessAttachmentListComponent,
                    CreateProcessAttachmentComponent,
                    CreateProcessAttachmentComponent,
                    AttachmentComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
AttachmentModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessModule {
}
ProcessModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    CommonModule,
                    CommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    BrowserAnimationsModule,
                    MaterialModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: {
                            name: 'adf-process-services',
                            source: 'assets/adf-process-services'
                        }
                    }
                ],
                exports: [
                    CommonModule,
                    CommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    BrowserAnimationsModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule,
                    MaterialModule
                ]
            },] },
];
/**
 * @nocollapse
 */
ProcessModule.ctorParameters = () => [];

class ProcessFilterRequestRepresentation {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.processDefinitionId = obj && obj.processDefinitionId || null;
        this.appDefinitionId = obj && obj.appDefinitionId || null;
        this.state = obj && obj.state || null;
        this.sort = obj && obj.sort || null;
        this.page = obj && obj.page || 0;
        this.size = obj && obj.size || 25;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// component

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ProcessModule, ProcessListModule, TaskListModule, AppsListModule, AttachmentModule, CommentsModule, PeopleModule, ProcessFiltersComponent, ProcessInstanceDetailsComponent, ProcessAuditDirective, ProcessInstanceHeaderComponent, ProcessInstanceTasksComponent, ProcessInstanceListComponent, StartProcessInstanceComponent, ProcessService, ProcessFilterService, FilterProcessRepresentationModel, ProcessFilterParamRepresentationModel, ProcessDefinitionRepresentation, ProcessInstance, ProcessFilterRequestRepresentation, ProcessInstanceVariable, TaskListComponent, ChecklistComponent, TaskHeaderComponent, NoTaskDetailsTemplateDirective, TaskFiltersComponent, TaskDetailsComponent, TaskAuditDirective, StartTaskComponent, TaskListService, ProcessUploadService, TaskUploadService, TaskFilterService, AppDefinitionRepresentationModel, FilterParamsModel, FilterRepresentationModel, FilterParamRepresentationModel, TaskQueryRequestRepresentationModel, TaskDetailsModel, TaskDetailsEvent, UserEventModel, StartTaskModel, AppsListComponent, TaskAttachmentListComponent, ProcessAttachmentListComponent, CreateProcessAttachmentComponent, AttachmentComponent, ProcessCommentsComponent, CommentListComponent, CommentsComponent, PeopleComponent, PeopleListComponent, PeopleSearchComponent, PeopleSearchTitleDirective, PeopleSearchActionLabelDirective, AppsListComponent as bf, CreateProcessAttachmentComponent as bi, AttachmentComponent as bj, ProcessAttachmentListComponent as bh, TaskAttachmentListComponent as bg, CommentListComponent as d, CommentsComponent as e, ProcessCommentsComponent as c, MaterialModule as b, modules as a, PeopleListComponent as j, PeopleSearchActionLabelDirective as i, PeopleSearchComponent as g, PeopleSearchTitleDirective as h, PeopleComponent as f, ProcessAuditDirective as bd, ProcessFiltersComponent as y, ProcessInstanceDetailsComponent as ba, ProcessInstanceHeaderComponent as bb, ProcessInstanceTasksComponent as bc, ProcessInstanceListComponent as w, StartProcessInstanceComponent as be, ProcessFilterService as z, ProcessService as x, ChecklistComponent as r, NoTaskDetailsTemplateDirective as k, StartTaskComponent as t, TaskAuditDirective as q, TaskDetailsComponent as l, TaskFiltersComponent as n, TaskHeaderComponent as s, TaskListComponent as p, ProcessUploadService as v, TaskFilterService as o, TaskUploadService as u, TaskListService as m };
//# sourceMappingURL=adf-process-services.js.map
