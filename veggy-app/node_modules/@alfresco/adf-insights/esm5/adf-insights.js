import { CommonModule } from '@angular/common';
import { Component, Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { FormBuilder, FormControl, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { AlfrescoApiService, ContentService, CoreModule, LogService, MOMENT_DATE_FORMATS, MomentDateAdapter, TRANSLATION_PROVIDER, ToolbarModule, UserPreferencesService } from '@alfresco/adf-core';
import { TranslateModule } from '@ngx-translate/core';
import { Observable as Observable$1 } from 'rxjs/Observable';
import 'rxjs/add/observable/throw';
import { DateAdapter, MAT_DATE_FORMATS, MAT_PLACEHOLDER_GLOBAL_OPTIONS, MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatDialog, MatDialogModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule, MatTooltipModule } from '@angular/material';
import { ChartsModule } from 'ng2-charts';
import moment from 'moment-es6';

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramColorService {
    constructor() {
    }
    /**
     * @param {?} totalColors
     * @return {?}
     */
    setTotalColors(totalColors) {
        this.totalColors = totalColors;
    }
    /**
     * @return {?}
     */
    getFillOpacity() {
        return '0.6';
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getFillColour(key) {
        if (this.totalColors && this.totalColors.hasOwnProperty(key)) {
            let /** @type {?} */ colorPercentage = this.totalColors[key];
            return this.convertColorToHsb(colorPercentage);
        }
        else {
            return DiagramColorService.ACTIVITY_FILL_COLOR;
        }
    }
    /**
     * @param {?} data
     * @param {?} defaultColor
     * @return {?}
     */
    getBpmnColor(data, defaultColor) {
        if (data.current) {
            return DiagramColorService.CURRENT_COLOR;
        }
        else if (data.completed) {
            return DiagramColorService.COMPLETED_COLOR;
        }
        else {
            return defaultColor;
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    getBpmnStrokeWidth(data) {
        if (data.current || data.completed) {
            return DiagramColorService.TASK_HIGHLIGHT_STROKE;
        }
        else {
            return DiagramColorService.TASK_STROKE;
        }
    }
    /**
     * @param {?} colorPercentage
     * @return {?}
     */
    convertColorToHsb(colorPercentage) {
        let /** @type {?} */ hue = (120.0 - (colorPercentage * 1.2)) / 360.0;
        return 'hsb(' + hue + ', 1, 1)';
    }
}
DiagramColorService.CURRENT_COLOR = '#017501';
DiagramColorService.COMPLETED_COLOR = '#2632aa';
DiagramColorService.ACTIVITY_STROKE_COLOR = '#bbbbbb';
DiagramColorService.MAIN_STROKE_COLOR = '#585858';
DiagramColorService.ACTIVITY_FILL_COLOR = '#f9f9f9';
DiagramColorService.TASK_STROKE = 1;
DiagramColorService.TASK_HIGHLIGHT_STROKE = 2;
DiagramColorService.CALL_ACTIVITY_STROKE = 2;
DiagramColorService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DiagramColorService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramEndEventComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '', radius: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.options.radius = 14;
        this.options.strokeWidth = 4;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
        this.iconFillColor = 'black';
    }
}
DiagramEndEventComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-end-event',
                template: `
      <diagram-event [data]="data" [options]="options" [iconFillColor]="iconFillColor"></diagram-event>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramEndEventComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramEndEventComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramEventComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '', radius: '' };
        this.error = new EventEmitter();
        this.center = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x + (this.data.width / 2);
        this.center.y = this.data.y + (this.data.height / 2);
    }
}
DiagramEventComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-event',
                template: `
      <raphael-circle [elementId]="data.id" [center]="center" [radius]="options.radius" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <diagram-container-icon-event [data]="data" [type]="data.eventDefinition && data.eventDefinition.type"
                                    [fillColor]="iconFillColor"></diagram-container-icon-event>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramEventComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramEventComponent.propDecorators = {
    'data': [{ type: Input },],
    'options': [{ type: Input },],
    'iconFillColor': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramStartEventComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '', radius: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.options.radius = 15;
        this.options.strokeWidth = 1;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
        this.iconFillColor = 'none';
    }
}
DiagramStartEventComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-start-event',
                template: `
      <diagram-event [data]="data" [options]="options" [iconFillColor]="iconFillColor"></diagram-event>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramStartEventComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramStartEventComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramAlfrescoPublishTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramAlfrescoPublishTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-diagram-publish-task, diagram-alfresco-publish-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-alfresco-publish-task [data]="data"></diagram-icon-alfresco-publish-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramAlfrescoPublishTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramAlfrescoPublishTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramBoxPublishTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramBoxPublishTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-box-publish-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-box-publish-task [data]="data"></diagram-icon-box-publish-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramBoxPublishTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramBoxPublishTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramBusinessRuleTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
}
DiagramBusinessRuleTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-business-rule-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-business-rule-task [data]="data"></diagram-icon-business-rule-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramBusinessRuleTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramBusinessRuleTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramCamelTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramCamelTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-camel-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-camel-task [data]="data"></diagram-icon-camel-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramCamelTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramCamelTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramContainerServiceTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramContainerServiceTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-container-service-task',
                template: `
      <div [ngSwitch]="data.taskType">
          <div *ngSwitchCase="'mail'">
              <diagram-send-task [data]="data"></diagram-send-task>
          </div>
          <div *ngSwitchCase="'camel'">
              <diagram-camel-task [data]="data"></diagram-camel-task>
          </div>
          <div *ngSwitchCase="'mule'">
              <diagram-mule-task [data]="data"></diagram-mule-task>
          </div>
          <div *ngSwitchCase="'alfresco_publish'">
              <adf-diagram-publish-task [data]="data"></adf-diagram-publish-task>
          </div>
          <div *ngSwitchCase="'rest_call'">
              <diagram-rest-call-task [data]="data"></diagram-rest-call-task>
          </div>
          <div *ngSwitchCase="'google_drive_publish'">
              <diagram-google-drive-publish-task [data]="data"></diagram-google-drive-publish-task>
          </div>
          <div *ngSwitchCase="'box_publish'">
              <diagram-box-publish-task [data]="data"></diagram-box-publish-task>
          </div>
          <div *ngSwitchDefault>
              <diagram-service-task [data]="data"></diagram-service-task>
          </div>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramContainerServiceTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramContainerServiceTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramGoogleDrivePublishTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramGoogleDrivePublishTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-google-drive-publish-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-google-drive-publish-task [data]="data"></diagram-icon-google-drive-publish-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramGoogleDrivePublishTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramGoogleDrivePublishTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramManualTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
}
DiagramManualTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-manual-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-manual-task [data]="data"></diagram-icon-manual-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramManualTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramManualTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramMuleTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramMuleTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-mule-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-mule-task [data]="data"></diagram-icon-mule-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramMuleTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramMuleTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramReceiveTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
}
DiagramReceiveTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-receive-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-receive-task [data]="data"></diagram-icon-receive-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramReceiveTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramReceiveTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramRestCallTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramRestCallTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-rest-call-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-rest-call-task [data]="data"></diagram-icon-rest-call-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramRestCallTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramRestCallTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramScriptTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
}
DiagramScriptTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-script-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-script-task [data]="data"></diagram-icon-script-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramScriptTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramScriptTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramSendTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramSendTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-send-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-send-task [data]="data"></diagram-icon-send-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramSendTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramSendTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramServiceTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
}
DiagramServiceTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-service-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-service-task [data]="data"></diagram-icon-service-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramServiceTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramServiceTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramTaskComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '', radius: 4 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.rectLeftCorner = { x: this.data.x, y: this.data.y };
        this.textPosition = { x: this.data.x + (this.data.width / 2), y: this.data.y + (this.data.height / 2) };
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.ACTIVITY_STROKE_COLOR);
        this.options.strokeWidth = this.diagramColorService.getBpmnStrokeWidth(this.data);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
    }
}
DiagramTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-task',
                template: `
      <raphael-rect [elementId]="data.id" [leftCorner]="rectLeftCorner" [width]="data.width" [height]="data.height" [radius]="options.radius"
                    [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                    [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-rect>
      <raphael-multiline-text [text]="data.name" [position]="textPosition" [elementWidth]="data.width"></raphael-multiline-text>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramUserTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
}
DiagramUserTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-user-task',
                template: `
      <diagram-task [data]="data"></diagram-task>
      <diagram-icon-user-task [data]="data"></diagram-icon-user-task>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramUserTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramUserTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramBoundaryEventComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 1 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x + (this.data.width / 2);
        this.center.y = this.data.y + (this.data.height / 2);
        this.circleRadiusInner = 12;
        this.circleRadiusOuter = 15;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
        this.signalFillColor = 'none';
    }
}
DiagramBoundaryEventComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-boundary-event',
                template: `
      <raphael-circle [center]="center" [radius]="circleRadiusInner" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <raphael-circle [elementId]="data.id" [center]="center" [radius]="circleRadiusOuter" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <diagram-container-icon-event [data]="data" [type]="data.eventDefinition.type" [fillColor]="signalFillColor"></diagram-container-icon-event>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramBoundaryEventComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramBoundaryEventComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramThrowEventComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 1 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x + (this.data.width / 2);
        this.center.y = this.data.y + (this.data.height / 2);
        this.circleRadiusInner = 12;
        this.circleRadiusOuter = 15;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
        this.signalFillColor = 'black';
    }
}
DiagramThrowEventComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-throw-event',
                template: `
      <raphael-circle [center]="center" [radius]="circleRadiusInner" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <raphael-circle [elementId]="data.id" [center]="center" [radius]="circleRadiusOuter" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <diagram-container-icon-event [data]="data" [type]="data.eventDefinition && data.eventDefinition.type"
                                    [fillColor]="signalFillColor"></diagram-container-icon-event>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramThrowEventComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramThrowEventComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIntermediateCatchingEventComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 1 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x + (this.data.width / 2);
        this.center.y = this.data.y + (this.data.height / 2);
        this.circleRadiusInner = 12;
        this.circleRadiusOuter = 15;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
    }
}
DiagramIntermediateCatchingEventComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-intermediate-catching-event',
                template: `
      <raphael-circle [center]="center" [radius]="circleRadiusInner" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <raphael-circle [elementId]="data.id" [center]="center" [radius]="circleRadiusOuter" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <diagram-container-icon-event [data]="data" [type]="data.eventDefinition.type"></diagram-container-icon-event>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIntermediateCatchingEventComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramIntermediateCatchingEventComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramEventGatewayComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.centerPentagon = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 0.5 };
        this.circleRadiusInner = 10.4;
        this.circleRadiusOuter = 11.7;
        this.pentaStrokeWidth = 1.39999998;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x + (this.data.width / 2);
        this.center.y = this.data.y + (this.data.height / 2);
        this.centerPentagon.x = this.data.x;
        this.centerPentagon.y = this.data.y;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
    }
}
DiagramEventGatewayComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-event-gateway',
                template: `
      <diagram-gateway [data]="data"></diagram-gateway>
      <raphael-circle [center]="center" [radius]="circleRadiusInner" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <raphael-circle [center]="center" [radius]="circleRadiusOuter" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
      <raphael-pentagon [center]="centerPentagon" [strokeWidth]="pentaStrokeWidth" [stroke]="options.stroke"
                        [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-pentagon>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramEventGatewayComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramEventGatewayComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramExclusiveGatewayComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 3 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x;
        this.center.y = this.data.y;
        this.width = this.data.width;
        this.height = this.data.height;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
    }
}
DiagramExclusiveGatewayComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-exclusive-gateway',
                template: `
      <diagram-gateway [data]="data"></diagram-gateway>
      <raphael-cross [center]="center" [width]="width" [height]="height" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                     [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-cross>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramExclusiveGatewayComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramExclusiveGatewayComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramGatewayComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 2 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x;
        this.center.y = this.data.y;
        this.width = this.data.width;
        this.height = this.data.height;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
    }
}
DiagramGatewayComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-gateway',
                template: `
      <raphael-rhombus [elementId]="data.id" [center]="center" [width]="width" [height]="height" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                       [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-rhombus>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramGatewayComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramGatewayComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramInclusiveGatewayComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 2.5, radius: 9.75 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x + (this.data.width / 2);
        this.center.y = this.data.y + (this.data.height / 2);
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
    }
}
DiagramInclusiveGatewayComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-inclusive-gateway',
                template: `
      <diagram-gateway [data]="data"></diagram-gateway>
      <raphael-circle [center]="center" [radius]="options.radius" [strokeWidth]="options.strokeWidth" [stroke]="options.stroke"
                      [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-circle>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramInclusiveGatewayComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramInclusiveGatewayComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramParallelGatewayComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.center = {};
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: 3 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x;
        this.center.y = this.data.y;
        this.width = this.data.width;
        this.height = this.data.height;
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.fillColors = this.diagramColorService.getFillColour(this.data.id);
        this.options.fillOpacity = this.diagramColorService.getFillOpacity();
    }
}
DiagramParallelGatewayComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-parallel-gateway',
                template: `
      <diagram-gateway [data]="data"></diagram-gateway>
      <raphael-plus [center]="center" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                       [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-plus>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramParallelGatewayComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramParallelGatewayComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramSequenceFlowComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramSequenceFlowComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-diagram-sequence-flow, diagram-sequence-flow',
                template: `
      <raphael-flow-arrow [flow]="flow"></raphael-flow-arrow>
      <diagram-tooltip [data]="flow"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramSequenceFlowComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramSequenceFlowComponent.propDecorators = {
    'flow': [{ type: Input },],
    'error': [{ type: Output },],
};

class DiagramElementPropertyModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.name = obj.name;
            this.type = obj.type;
            this.value = obj.value;
        }
    }
}

class DiagramEventDefinitionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.timeCycle = obj.timeCycle;
            this.type = obj.type;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramElementModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.properties = [];
        this.dataType = '';
        this.taskType = '';
        if (obj) {
            this.completed = !!obj.completed;
            this.current = !!obj.current;
            this.height = obj.height || '';
            this.id = obj.id || '';
            this.name = obj.name || '';
            this.type = obj.type || '';
            this.width = obj.width || '';
            this.value = obj.value || '';
            this.x = obj.x || '';
            this.y = obj.y || '';
            this.taskType = obj.taskType || '';
            if (obj.properties) {
                obj.properties.forEach((property) => {
                    this.properties.push(new DiagramElementPropertyModel(property));
                });
            }
            this.dataType = obj.dataType || '';
            if (obj.eventDefinition) {
                this.eventDefinition = new DiagramEventDefinitionModel(obj.eventDefinition);
            }
        }
    }
}

class DiagramWayPointModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.x = obj.x;
            this.y = obj.y;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramFlowElementModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.properties = [];
        this.waypoints = [];
        if (obj) {
            this.completed = !!obj.completed;
            this.current = !!obj.current;
            this.id = obj.id;
            this.properties = obj.properties;
            this.sourceRef = obj.sourceRef;
            this.targetRef = obj.targetRef;
            this.type = obj.type;
            if (obj.waypoints) {
                obj.waypoints.forEach((waypoint) => {
                    this.waypoints.push(new DiagramWayPointModel(waypoint));
                });
            }
        }
    }
}

class DiagramLaneElementModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.height = obj.height;
            this.id = obj.id;
            this.name = obj.name;
            this.width = obj.width;
            this.x = obj.x;
            this.y = obj.y;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramPoolElementModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.lanes = [];
        if (obj) {
            this.height = obj.height;
            this.id = obj.id;
            this.name = obj.name;
            this.properties = obj.properties;
            this.width = obj.width;
            this.x = obj.x;
            this.y = obj.y;
            if (obj.lanes) {
                obj.lanes.forEach((lane) => {
                    this.lanes.push(new DiagramLaneElementModel(lane));
                });
            }
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.elements = [];
        this.flows = [];
        this.pools = [];
        if (obj) {
            this.diagramBeginX = obj.diagramBeginX;
            this.diagramBeginY = obj.diagramBeginY;
            this.diagramHeight = obj.diagramHeight;
            this.diagramWidth = obj.diagramWidth;
            if (obj.elements) {
                obj.elements.forEach((element) => {
                    this.elements.push(new DiagramElementModel(element));
                });
            }
            if (obj.flows) {
                obj.flows.forEach((flow) => {
                    this.flows.push(new DiagramFlowElementModel(flow));
                });
            }
            if (obj.pools) {
                obj.pools.forEach((pool) => {
                    this.pools.push(new DiagramPoolElementModel(pool));
                });
            }
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramsService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @param {?} processDefinitionId
     * @return {?}
     */
    getProcessDefinitionModel(processDefinitionId) {
        return Observable$1.fromPromise(this.apiService.getInstance().
            activiti.modelJsonBpmnApi.getModelJSON(processDefinitionId)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getRunningProcessDefinitionModel(processInstanceId) {
        return Observable$1.fromPromise(this.apiService.getInstance().
            activiti.modelJsonBpmnApi.getModelJSONForProcessDefinition(processInstanceId)).catch(err => this.handleError(err));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
DiagramsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DiagramsService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelService {
    constructor() {
        this.width = 300;
        this.height = 400;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getInstance(element) {
        if (!this.paper) {
            this.ctx = element.nativeElement;
            this.refresh();
        }
        return this.paper;
    }
    /**
     * @return {?}
     */
    refresh() {
        this.ngOnDestroy();
        this.paper = this.getPaperBuilder(this.ctx);
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    getPaperBuilder(ctx) {
        if (typeof Raphael === 'undefined') {
            throw new Error('insights configuration issue: Embedding Chart.js lib is mandatory');
        }
        let /** @type {?} */ paper = new Raphael(ctx, this.width, this.height);
        // paper.setViewBox(0, 0, 583, 344.08374193550003, false);
        // paper.renderfix();
        return paper;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.paper) {
            this.paper.clear();
            this.paper = void 0;
        }
    }
    /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    setting(width, height) {
        this.width = width;
        this.height = height;
    }
    /**
     * @return {?}
     */
    reset() {
        this.ngOnDestroy();
    }
}
RaphaelService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
RaphaelService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramComponent {
    /**
     * @param {?} diagramColorService
     * @param {?} raphaelService
     * @param {?} diagramsService
     */
    constructor(diagramColorService, raphaelService, diagramsService) {
        this.diagramColorService = diagramColorService;
        this.raphaelService = raphaelService;
        this.diagramsService = diagramsService;
        this.metricType = '';
        this.width = 1000;
        this.height = 500;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.PADDING_WIDTH = 60;
        this.PADDING_HEIGHT = 60;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.reset();
        this.diagramColorService.setTotalColors(this.metricColor);
        if (this.processDefinitionId) {
            this.getProcessDefinitionModel(this.processDefinitionId);
        }
        else {
            this.getRunningProcessDefinitionModel(this.processInstanceId);
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getRunningProcessDefinitionModel(processInstanceId) {
        this.diagramsService.getRunningProcessDefinitionModel(processInstanceId).subscribe((res) => {
            this.diagram = new DiagramModel(res);
            this.raphaelService.setting(this.diagram.diagramWidth + this.PADDING_WIDTH, this.diagram.diagramHeight + this.PADDING_HEIGHT);
            this.setMetricValueToDiagramElement(this.diagram, this.metricPercentages, this.metricType);
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} processDefinitionId
     * @return {?}
     */
    getProcessDefinitionModel(processDefinitionId) {
        this.diagramsService.getProcessDefinitionModel(processDefinitionId).subscribe((res) => {
            this.diagram = new DiagramModel(res);
            this.raphaelService.setting(this.diagram.diagramWidth + this.PADDING_WIDTH, this.diagram.diagramHeight + this.PADDING_HEIGHT);
            this.setMetricValueToDiagramElement(this.diagram, this.metricPercentages, this.metricType);
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} diagram
     * @param {?} metrics
     * @param {?} metricType
     * @return {?}
     */
    setMetricValueToDiagramElement(diagram, metrics, metricType) {
        for (let /** @type {?} */ key in metrics) {
            if (metrics.hasOwnProperty(key)) {
                let /** @type {?} */ foundElement = diagram.elements.find((element) => element.id === key);
                if (foundElement) {
                    foundElement.value = metrics[key];
                    foundElement.dataType = metricType;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.raphaelService.reset();
    }
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-diagram',
                styles: [`
      .diagram {
          border: 1px solid lightgray; overflow:auto
      }
    `],
                template: `
      <div *ngIf="diagram" class="diagram">
          <div *ngFor="let element of diagram.elements">
              <div [ngSwitch]="element.type">
                  <div *ngSwitchCase="'StartEvent'">
                      <diagram-start-event [data]="element"></diagram-start-event>
                  </div>
                  <div *ngSwitchCase="'ExclusiveGateway'">
                      <diagram-exclusive-gateway [data]="element"></diagram-exclusive-gateway>
                  </div>
                  <div *ngSwitchCase="'InclusiveGateway'">
                      <diagram-inclusive-gateway [data]="element"></diagram-inclusive-gateway>
                  </div>
                  <div *ngSwitchCase="'EventGateway'">
                      <diagram-event-gateway [data]="element"></diagram-event-gateway>
                  </div>
                  <div *ngSwitchCase="'ParallelGateway'">
                      <diagram-parallel-gateway [data]="element"></diagram-parallel-gateway>
                  </div>
                  <div *ngSwitchCase="'EndEvent'">
                      <diagram-end-event [data]="element"></diagram-end-event>
                  </div>
                  <div *ngSwitchCase="'UserTask'">
                      <diagram-user-task [data]="element"></diagram-user-task>
                  </div>
                  <div *ngSwitchCase="'ManualTask'">
                      <diagram-manual-task [data]="element"></diagram-manual-task>
                  </div>
                  <div *ngSwitchCase="'ServiceTask'">
                      <diagram-container-service-task [data]="element"></diagram-container-service-task>
                  </div>
                  <div *ngSwitchCase="'ReceiveTask'">
                      <diagram-receive-task [data]="element"></diagram-receive-task>
                  </div>
                  <div *ngSwitchCase="'ScriptTask'">
                      <diagram-script-task [data]="element"></diagram-script-task>
                  </div>
                  <div *ngSwitchCase="'BusinessRuleTask'">
                      <diagram-business-rule-task [data]="element"></diagram-business-rule-task>
                  </div>
                  <div *ngSwitchCase="'BoundaryEvent'">
                      <diagram-boundary-event [data]="element"></diagram-boundary-event>
                  </div>
                  <div *ngSwitchCase="'ThrowEvent'">
                      <diagram-throw-event [data]="element"></diagram-throw-event>
                  </div>
                  <div *ngSwitchCase="'IntermediateCatchEvent'">
                      <diagram-intermediate-catching-event [data]="element"></diagram-intermediate-catching-event>
                  </div>
                  <div *ngSwitchCase="'SubProcess'">
                      <diagram-subprocess [data]="element"></diagram-subprocess>
                  </div>
                  <div *ngSwitchCase="'EventSubProcess'">
                      <diagram-event-subprocess [data]="element"></diagram-event-subprocess>
                  </div>
              </div>
          </div>
          <div *ngFor="let flow of diagram.flows">
              <div [ngSwitch]="flow.type">
                  <div *ngSwitchCase="'sequenceFlow'">
                      <diagram-sequence-flow [flow]="flow"></diagram-sequence-flow>
                  </div>
              </div>
          </div>
          <div *ngIf="diagram.pools">
              <diagram-pools [pools]="diagram.pools"></diagram-pools>
          </div>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramComponent.ctorParameters = () => [
    { type: DiagramColorService, },
    { type: RaphaelService, },
    { type: DiagramsService, },
];
DiagramComponent.propDecorators = {
    'processDefinitionId': [{ type: Input },],
    'processInstanceId': [{ type: Input },],
    'metricPercentages': [{ type: Input },],
    'metricColor': [{ type: Input },],
    'metricType': [{ type: Input },],
    'width': [{ type: Input },],
    'height': [{ type: Input },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramContainerIconEventTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
}
DiagramContainerIconEventTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-container-icon-event',
                template: `
      <div [ngSwitch]="type">
          <div *ngSwitchCase="'timer'">
              <diagram-icon-timer [data]="data"></diagram-icon-timer>
          </div>
          <div *ngSwitchCase="'error'">
              <diagram-icon-error [data]="data" [fillColor]="fillColor"></diagram-icon-error>
          </div>
          <div *ngSwitchCase="'signal'">
              <diagram-icon-signal [data]="data" [fillColor]="fillColor"></diagram-icon-signal>
          </div>
          <div *ngSwitchCase="'message'">
              <diagram-icon-message [data]="data"></diagram-icon-message>
          </div>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramContainerIconEventTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramContainerIconEventTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'type': [{ type: Input },],
    'fillColor': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconAlfrescoPublishTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 4 };
        this.options.stroke = 'none';
        this.options.fillColors = '#87C040';
    }
}
DiagramIconAlfrescoPublishTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-alfresco-publish-task',
                template: `
      <raphael-icon-alfresco-publish [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-alfresco-publish>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconAlfrescoPublishTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconAlfrescoPublishTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconBoxPublishTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 6, y: this.data.y + 6 };
    }
}
DiagramIconBoxPublishTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-box-publish-task',
                template: `
      <raphael-icon-box-publish [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-box-publish>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconBoxPublishTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconBoxPublishTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconBusinessRuleTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 4 };
        this.options.stroke = 'none';
        this.options.fillColors = '#72a7d0';
    }
}
DiagramIconBusinessRuleTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-business-rule-task',
                template: `
      <raphael-icon-business-rule [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-business-rule>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconBusinessRuleTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconBusinessRuleTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconCamelTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 8, y: this.data.y + 6 };
        this.options.stroke = 'none';
        this.options.fillColors = '#bd4848';
    }
}
DiagramIconCamelTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-camel-task',
                template: `
      <raphael-icon-camel [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-camel>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconCamelTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconCamelTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconErrorComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x - 1, y: this.data.y - 1 };
        this.options.stroke = 'black';
        this.options.fillColors = this.fillColor;
        this.options.strokeWidth = 1;
    }
}
DiagramIconErrorComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-error',
                template: `
      <raphael-icon-error [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-error>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconErrorComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconErrorComponent.propDecorators = {
    'data': [{ type: Input },],
    'fillColor': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconGoogleDrivePublishTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 6, y: this.data.y + 6 };
    }
}
DiagramIconGoogleDrivePublishTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-google-drive-publish-task',
                template: `
      <raphael-icon-google-drive-publish [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-google-drive-publish>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconGoogleDrivePublishTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconGoogleDrivePublishTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconManualTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 4 };
        this.options.stroke = 'none';
        this.options.fillColors = '#d1b575';
    }
}
DiagramIconManualTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-manual-task',
                template: `
      <raphael-icon-manual [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-manual>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconManualTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconManualTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconMessageComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 6, y: this.data.y + 6 };
        this.options.stroke = 'none';
        this.options.fillColors = '#585858';
        this.options.strokeWidth = 1;
    }
}
DiagramIconMessageComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-message',
                template: `
      <raphael-icon-message [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-message>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconMessageComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconMessageComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconMuleTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 2, y: this.data.y + 2 };
        this.options.stroke = 'none';
        this.options.fillColors = '#bd4848';
    }
}
DiagramIconMuleTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-mule-task',
                template: `
      <raphael-icon-mule [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-mule>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconMuleTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconMuleTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconReceiveTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 2 };
        this.options.stroke = 'none';
        this.options.fillColors = '#16964d';
    }
}
DiagramIconReceiveTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-receive-task',
                template: `
      <raphael-icon-receive [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-receive>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconReceiveTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconReceiveTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconRestCallTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 2, y: this.data.y + 2 };
        this.options.stroke = 'none';
        this.options.fillColors = '#bd4848';
    }
}
DiagramIconRestCallTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-rest-call-task',
                template: `
      <raphael-icon-rest-call [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-rest-call>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconRestCallTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconRestCallTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconScriptTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 4 };
        this.options.stroke = 'none';
        this.options.fillColors = '#72a7d0';
    }
}
DiagramIconScriptTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-script-task',
                template: `
      <raphael-icon-script [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-script>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconScriptTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconScriptTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconSendTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 4 };
        this.options.stroke = 'none';
        this.options.fillColors = '#16964d';
    }
}
DiagramIconSendTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-send-task',
                template: `
      <raphael-icon-send [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-send>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconSendTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconSendTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconServiceTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 4 };
        this.options.stroke = 'none';
        this.options.fillColors = '#72a7d0';
    }
}
DiagramIconServiceTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-service-task',
                template: `
      <raphael-icon-service [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                            [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-service>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconServiceTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconServiceTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconSignalComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x - 1, y: this.data.y - 1 };
        this.options.stroke = 'black';
        this.options.fillColors = this.fillColor;
        this.options.strokeWidth = 1;
    }
}
DiagramIconSignalComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-signal',
                template: `
      <raphael-icon-signal [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-signal>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconSignalComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconSignalComponent.propDecorators = {
    'data': [{ type: Input },],
    'fillColor': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconTimerComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.center = {};
        this.circleOptions = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
        this.timerOptions = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.center.x = this.data.x + (this.data.width / 2);
        this.center.y = this.data.y + (this.data.height / 2);
        this.circleRadius = 10;
        this.position = { x: this.data.x + 5, y: this.data.y + 5 };
        this.circleOptions.stroke = 'black';
        this.circleOptions.fillColors = 'none';
        this.timerOptions.stroke = 'none';
        this.timerOptions.fillColors = '#585858';
    }
}
DiagramIconTimerComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-timer',
                template: `
      <raphael-circle [center]="center" [radius]="circleRadius" [strokeWidth]="circleOptions.strokeWidth" [stroke]="circleOptions.stroke"
                      [fillColors]="circleOptions.fillColors" [fillOpacity]="circleOptions.fillOpacity"></raphael-circle>
      <raphael-icon-timer [position]="position" [stroke]="timerOptions.stroke" [strokeWidth]="timerOptions.strokeWidth"
                            [fillColors]="timerOptions.fillColors" [fillOpacity]="timerOptions.fillOpacity"></raphael-icon-timer>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconTimerComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconTimerComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramIconUserTaskComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.position = { x: this.data.x + 4, y: this.data.y + 4 };
        this.options.stroke = 'none';
        this.options.fillColors = '#d1b575';
    }
}
DiagramIconUserTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-icon-user-task',
                template: `
      <raphael-icon-user [position]="position" [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                         [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-icon-user>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramIconUserTaskComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramIconUserTaskComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramEventSubprocessComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '', radius: 4 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.rectLeftCorner = { x: this.data.x, y: this.data.y };
        this.width = this.data.width;
        this.height = this.data.height;
        this.options.fillColors = 'none';
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.strokeWidth = 1;
    }
}
DiagramEventSubprocessComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-event-subprocess',
                template: `
      <raphael-rect [leftCorner]="rectLeftCorner" [width]="width" [height]="height" [radius]="options.radius"
                    [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                    [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-rect>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramEventSubprocessComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramEventSubprocessComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramSubprocessComponent {
    /**
     * @param {?} elementRef
     * @param {?} diagramColorService
     */
    constructor(elementRef, diagramColorService) {
        this.elementRef = elementRef;
        this.diagramColorService = diagramColorService;
        this.error = new EventEmitter();
        this.options = { stroke: '', fillColors: '', fillOpacity: '', strokeWidth: '', radius: 4 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.rectLeftCorner = { x: this.data.x, y: this.data.y };
        this.width = this.data.width;
        this.height = this.data.height;
        this.options.fillColors = 'none';
        this.options.stroke = this.diagramColorService.getBpmnColor(this.data, DiagramColorService.MAIN_STROKE_COLOR);
        this.options.strokeWidth = 1;
    }
}
DiagramSubprocessComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-subprocess',
                template: `
      <raphael-rect [leftCorner]="rectLeftCorner" [width]="width" [height]="height" [radius]="options.radius"
                    [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                    [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-rect>
      <diagram-tooltip [data]="data"></diagram-tooltip>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramSubprocessComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DiagramColorService, },
];
DiagramSubprocessComponent.propDecorators = {
    'data': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramPoolComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '#000000', fillColors: 'none', fillOpacity: '', strokeWidth: '1', radius: 0 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.rectLeftCorner = { x: this.pool.x, y: this.pool.y };
        this.width = this.pool.width;
        this.height = this.pool.height;
        this.textPosition = { x: this.pool.x + 14, y: this.pool.y + (this.pool.height / 2) };
        this.text = this.pool.name;
        this.textTransform = 'r270';
    }
}
DiagramPoolComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-pool',
                template: `
      <raphael-rect [leftCorner]="rectLeftCorner" [width]="width" [height]="height" [radius]="options.radius"
                    [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                    [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-rect>
      <raphael-text [text]="text" [position]="textPosition" [transform]="textTransform"></raphael-text>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramPoolComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramPoolComponent.propDecorators = {
    'pool': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramPoolsComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramPoolsComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-pools',
                template: `
      <div *ngIf="pools">
          <div *ngFor="let pool of pools">
              <diagram-pool [pool]="pool"></diagram-pool>
              <diagram-lanes [lanes]="pool.lanes"></diagram-lanes>
          </div>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramPoolsComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramPoolsComponent.propDecorators = {
    'pools': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramLaneComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.options = { stroke: '#000000', fillColors: 'none', fillOpacity: '', strokeWidth: '1', radius: 0 };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.rectLeftCorner = { x: this.lane.x, y: this.lane.y };
        this.width = this.lane.width;
        this.height = this.lane.height;
        this.textPosition = { x: this.lane.x + 10, y: this.lane.y + (this.lane.height / 2) };
        this.text = this.lane.name;
        this.textTransform = 'r270';
    }
}
DiagramLaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-lane',
                template: `
      <raphael-rect [leftCorner]="rectLeftCorner" [width]="width" [height]="height" [radius]="options.radius"
                    [stroke]="options.stroke" [strokeWidth]="options.strokeWidth"
                    [fillColors]="options.fillColors" [fillOpacity]="options.fillOpacity"></raphael-rect>
      <raphael-text [text]="text" [position]="textPosition" [transform]="textTransform"></raphael-text>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramLaneComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramLaneComponent.propDecorators = {
    'lane': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class DiagramLanesComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DiagramLanesComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-lanes',
                template: `
      <div *ngIf="lanes">
          <div *ngFor="let lane of lanes">
              <diagram-lane [lane]="lane"></diagram-lane>
          </div>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
DiagramLanesComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DiagramLanesComponent.propDecorators = {
    'lanes': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
const POSITION = { BOTTOM: 'bottom', LEFT: 'left', RIGHT: 'right', TOP: 'top' };
const STRATEGY = { CURSOR: 'cursor', ELEMENT: 'element' };
const IS_ACTIVE_CLASS = 'is-active';
class DiagramTooltipComponent {
    constructor() {
        this.adf = 'adf';
        this.position = 'bottom';
        this.strategy = 'cursor';
    }
    /**
     * Set up event listeners for the target element (defined in the data.id)
     * @return {?}
     */
    ngAfterViewInit() {
        this.tooltipElement = this.tooltipContent.nativeElement;
        if (this.data.id) {
            this.targetElement = document.getElementById(this.data.id);
        }
        if (this.targetElement) {
            if (!this.targetElement.hasAttribute('tabindex')) {
                this.targetElement.setAttribute('tabindex', '0');
            }
            this.boundMouseEnterHandler = this.handleMouseEnter.bind(this);
            this.boundMouseLeaveAndScrollHandler = this.hideTooltip.bind(this);
            this.targetElement.addEventListener('mouseenter', this.boundMouseEnterHandler, false);
            this.targetElement.addEventListener('touchend', this.boundMouseEnterHandler, false);
            this.targetElement.addEventListener('mouseleave', this.boundMouseLeaveAndScrollHandler, false);
            window.addEventListener('scroll', this.boundMouseLeaveAndScrollHandler, true);
            window.addEventListener('touchstart', this.boundMouseLeaveAndScrollHandler);
        }
    }
    /**
     * Clear all bound eventlisteners
     * @return {?}
     */
    ngOnDestroy() {
        window.removeEventListener('scroll', this.boundMouseLeaveAndScrollHandler, true);
        window.removeEventListener('touchstart', this.boundMouseLeaveAndScrollHandler);
    }
    /**
     * Hides the tooltip
     * @return {?}
     */
    hideTooltip() {
        this.tooltipElement.classList.remove(IS_ACTIVE_CLASS);
    }
    /**
     * Shows the tooltip
     * @return {?}
     */
    showTooltip() {
        this.tooltipElement.classList.add(IS_ACTIVE_CLASS);
    }
    /**
     * Calculates the tooltip's position and displays it
     *
     * @param {?} event mouseenter/touchend event
     * @return {?}
     */
    handleMouseEnter(event) {
        let /** @type {?} */ props;
        if (this.strategy === STRATEGY.ELEMENT) {
            props = event.target.getBoundingClientRect();
        }
        else {
            props = { top: (event.pageY - 150), left: event.pageX, width: event.layerX, height: 50 };
        }
        let /** @type {?} */ top = props.top + (props.height / 2);
        let /** @type {?} */ marginLeft = -1 * (this.tooltipElement.offsetWidth / 2);
        let /** @type {?} */ marginTop = -1 * (this.tooltipElement.offsetHeight / 2);
        let /** @type {?} */ left = props.left + (props.width / 2);
        if (this.position === POSITION.LEFT || this.position === POSITION.RIGHT) {
            left = (props.width / 2);
            if (top + marginTop < 0) {
                this.tooltipElement.style.top = '0';
                this.tooltipElement.style.marginTop = '0';
            }
            else {
                this.tooltipElement.style.top = top + 'px';
                this.tooltipElement.style.marginTop = marginTop + 'px';
            }
        }
        else {
            if (left + marginLeft < 0) {
                this.tooltipElement.style.left = '0';
                this.tooltipElement.style.marginLeft = '0';
            }
            else {
                this.tooltipElement.style.left = left + 'px';
                this.tooltipElement.style.marginLeft = marginLeft + 'px';
            }
        }
        if (this.position === POSITION.TOP) {
            this.tooltipElement.style.top = props.top - this.tooltipElement.offsetHeight - 10 + 'px';
        }
        else if (this.position === POSITION.RIGHT) {
            this.tooltipElement.style.left = props.left + props.width + 10 + 'px';
        }
        else if (this.position === POSITION.LEFT) {
            this.tooltipElement.style.left = props.left - this.tooltipElement.offsetWidth - 10 + 'px';
        }
        else {
            this.tooltipElement.style.top = props.top + props.height + 10 + 'px';
        }
        this.showTooltip();
    }
}
DiagramTooltipComponent.decorators = [
    { type: Component, args: [{
                selector: 'diagram-tooltip',
                template: `
      <div #tooltipContent class="{{adf}}-diagram-tooltip">
          <div class="{{adf}}-diagram-tooltip-header">{{ data.type }} {{ data.name || data.id }}</div>
          <div class="{{adf}}-diagram-tooltip-body">
              <div *ngIf="data.name" class="{{adf}}-diagram-name-property">
                  <span class="{{adf}}-diagram-propertyName">Name:</span>
                  <span class="{{adf}}-diagram-propertyValue">{{ data.name }}</span>
              </div>
              <div *ngFor="let property of data.properties" class="{{adf}}-diagram-general-property">
                  <span class="{{adf}}-diagram-propertyName">{{ property.name }}:</span>
                  <span class="{{adf}}-diagram-propertyValue">{{ property.value }}</span>
              </div>
          </div>
      </div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
DiagramTooltipComponent.ctorParameters = () => [];
DiagramTooltipComponent.propDecorators = {
    'tooltipContent': [{ type: ViewChild, args: ['tooltipContent',] },],
    'data': [{ type: Input },],
    'position': [{ type: Input },],
    'strategy': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelBase {
    /**
     * @param {?} element
     * @param {?} raphaelService
     */
    constructor(element, raphaelService) {
        this.raphaelService = raphaelService;
        this.element = element;
        this.paper = this.raphaelService.getInstance(element);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelCircleDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ opts = { 'stroke-width': this.strokeWidth, 'fill': this.fillColors, 'stroke': this.stroke, 'fill-opacity': this.fillOpacity };
        let /** @type {?} */ drawElement = this.draw(this.center, this.radius, opts);
        drawElement.node.id = this.elementId;
    }
    /**
     * @param {?} center
     * @param {?} radius
     * @param {?} opts
     * @return {?}
     */
    draw(center, radius, opts) {
        let /** @type {?} */ circle = this.paper.circle(center.x, center.y, radius).attr(opts);
        return circle;
    }
}
RaphaelCircleDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-circle' },] },
];
/**
 * @nocollapse
 */
RaphaelCircleDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelCircleDirective.propDecorators = {
    'paper': [{ type: Input },],
    'center': [{ type: Input },],
    'radius': [{ type: Input },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
    'elementId': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelCrossDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ opts = { 'stroke-width': this.strokeWidth, 'fill': this.fillColors, 'stroke': this.stroke, 'fill-opacity': this.fillOpacity };
        this.draw(this.center, this.width, this.height, opts);
    }
    /**
     * @param {?} center
     * @param {?} width
     * @param {?} height
     * @param {?=} opts
     * @return {?}
     */
    draw(center, width, height, opts) {
        let /** @type {?} */ quarterWidth = width / 4;
        let /** @type {?} */ quarterHeight = height / 4;
        return this.paper.path('M' + (center.x + quarterWidth + 3) + ' ' + (center.y + quarterHeight + 3) +
            'L' + (center.x + 3 * quarterWidth - 3) + ' ' + (center.y + 3 * quarterHeight - 3) +
            'M' + (center.x + quarterWidth + 3) + ' ' + (center.y + 3 * quarterHeight - 3) +
            'L' + (center.x + 3 * quarterWidth - 3) + ' ' + (center.y + quarterHeight + 3)).attr(opts);
    }
}
RaphaelCrossDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-cross' },] },
];
/**
 * @nocollapse
 */
RaphaelCrossDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelCrossDirective.propDecorators = {
    'center': [{ type: Input },],
    'width': [{ type: Input },],
    'height': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'strokeWidth': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
    'error': [{ type: Output },],
};

class Anchor {
    /**
     * @param {?} uuid
     * @param {?} type
     * @param {?} x
     * @param {?} y
     */
    constructor(uuid, type, x, y) {
        this.uuid = null;
        this.x = 0;
        this.y = 0;
        this.isFirst = false;
        this.isLast = false;
        this.typeIndex = 0;
        this.type = Anchor.ANCHOR_TYPE.main;
        this.uuid = uuid;
        this.x = x;
        this.y = y;
        this.type = (type === Anchor.ANCHOR_TYPE.middle) ? Anchor.ANCHOR_TYPE.middle : Anchor.ANCHOR_TYPE.main;
    }
}
Anchor.ANCHOR_TYPE = {
    main: 'main',
    middle: 'middle',
    first: 'first',
    last: 'last'
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Polyline {
    /**
     * @param {?} uuid
     * @param {?} points
     * @param {?} strokeWidth
     * @param {?} paper
     */
    constructor(uuid, points, strokeWidth, paper) {
        this.id = null;
        this.points = [];
        this.path = [];
        this.anchors = [];
        this.strokeWidth = 1;
        this.radius = 1;
        this.showDetails = false;
        this.paper = null;
        this.element = null;
        this.isDefaultConditionAvailable = false;
        this.closePath = false;
        /* Array on coordinates:
         * points: [{x: 410, y: 110}, 1
         *			{x: 570, y: 110}, 1 2
         *			{x: 620, y: 240},   2 3
         *			{x: 750, y: 270},     3 4
         *			{x: 650, y: 370}];      4
         */
        this.points = points;
        /*
         * path for graph
         * [['M', x1, y1], ['L', x2, y2], ['C', ax, ay, bx, by, x3, y3], ['L', x3, y3]]
         */
        this.path = [];
        this.anchors = [];
        if (strokeWidth) {
            this.strokeWidth = strokeWidth;
        }
        this.paper = paper;
        this.closePath = false;
        this.init();
    }
    /**
     * @return {?}
     */
    init() {
        var /** @type {?} */ linesCount = this.getLinesCount();
        if (linesCount < 1) {
            return;
        }
        this.normalizeCoordinates();
        // create anchors
        this.pushAnchor(Anchor.ANCHOR_TYPE.first, this.getLine(0).x1, this.getLine(0).y1);
        for (var /** @type {?} */ i = 1; i < linesCount; i++) {
            var /** @type {?} */ line1 = this.getLine(i - 1);
            this.pushAnchor(Anchor.ANCHOR_TYPE.main, line1.x2, line1.y2);
        }
        this.pushAnchor(Anchor.ANCHOR_TYPE.last, this.getLine(linesCount - 1).x2, this.getLine(linesCount - 1).y2);
        this.rebuildPath();
    }
    /**
     * @return {?}
     */
    normalizeCoordinates() {
        for (var /** @type {?} */ i = 0; i < this.points.length; i++) {
            this.points[i].x = parseFloat(this.points[i].x);
            this.points[i].y = parseFloat(this.points[i].y);
        }
    }
    /**
     * @return {?}
     */
    getLinesCount() {
        return this.points.length - 1;
    }
    /**
     * @param {?} i
     * @return {?}
     */
    _getLine(i) {
        if (this.points.length > i && this.points[i]) {
            return { x1: this.points[i].x, y1: this.points[i].y, x2: this.points[i + 1].x, y2: this.points[i + 1].y };
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {?} i
     * @return {?}
     */
    getLine(i) {
        var /** @type {?} */ line = this._getLine(i);
        if (line !== undefined) {
            line.angle = this.getLineAngle(i);
        }
        return line;
    }
    /**
     * @param {?} i
     * @return {?}
     */
    getLineAngle(i) {
        var /** @type {?} */ line = this._getLine(i);
        return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    }
    /**
     * @param {?} i
     * @return {?}
     */
    getLineLengthX(i) {
        var /** @type {?} */ line = this.getLine(i);
        return (line.x2 - line.x1);
    }
    /**
     * @param {?} i
     * @return {?}
     */
    getLineLengthY(i) {
        var /** @type {?} */ line = this.getLine(i);
        return (line.y2 - line.y1);
    }
    /**
     * @param {?} i
     * @return {?}
     */
    getLineLength(i) {
        return Math.sqrt(Math.pow(this.getLineLengthX(i), 2) + Math.pow(this.getLineLengthY(i), 2));
    }
    /**
     * @return {?}
     */
    getAnchors() {
        return this.anchors;
    }
    /**
     * @param {?=} type
     * @return {?}
     */
    getAnchorsCount(type = null) {
        if (!type) {
            return this.anchors.length;
        }
        else {
            var /** @type {?} */ count = 0;
            for (var /** @type {?} */ i = 0; i < this.getAnchorsCount(null); i++) {
                var /** @type {?} */ anchor = this.anchors[i];
                if (anchor.getType() === type) {
                    count++;
                }
            }
            return count;
        }
    }
    /**
     * @param {?} type
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    pushAnchor(type, x, y) {
        var /** @type {?} */ index;
        if (type === Anchor.ANCHOR_TYPE.first) {
            index = 0;
        }
        else if (type === Anchor.ANCHOR_TYPE.last) {
            index = this.getAnchorsCount();
        }
        else if (!index) {
            index = this.anchors.length;
        }
        else {
            for (var /** @type {?} */ i = 0; i < this.getAnchorsCount(); i++) {
                var /** @type {?} */ anchor = this.anchors[i];
                if (anchor.index > index) {
                    anchor.index++;
                    anchor.typeIndex++;
                }
            }
        }
        var /** @type {?} */ anchor = new Anchor(this.id, Anchor.ANCHOR_TYPE.main, x, y);
        this.anchors.push(anchor);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    getAnchor(position) {
        return this.anchors[position];
    }
    /**
     * @param {?} type
     * @param {?} position
     * @return {?}
     */
    getAnchorByType(type, position) {
        if (type === Anchor.ANCHOR_TYPE.first) {
            return this.anchors[0];
        }
        if (type === Anchor.ANCHOR_TYPE.last) {
            return this.anchors[this.getAnchorsCount() - 1];
        }
        for (var /** @type {?} */ i = 0; i < this.getAnchorsCount(); i++) {
            var /** @type {?} */ anchor = this.anchors[i];
            if (anchor.type === type) {
                if (position === anchor.position) {
                    return anchor;
                }
            }
        }
        return null;
    }
    /**
     * @param {?} position
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    addNewPoint(position, x, y) {
        //
        for (var /** @type {?} */ i = 0; i < this.getLinesCount(); i++) {
            var /** @type {?} */ line = this.getLine(i);
            if (x > line.x1 && x < line.x2 && y > line.y1 && y < line.y2) {
                this.points.splice(i + 1, 0, { x: x, y: y });
                break;
            }
        }
        this.rebuildPath();
    }
    /**
     * @return {?}
     */
    rebuildPath() {
        var /** @type {?} */ path = [];
        for (var /** @type {?} */ i = 0; i < this.getAnchorsCount(); i++) {
            var /** @type {?} */ anchor = this.getAnchor(i);
            var /** @type {?} */ pathType = '';
            if (i === 0) {
                pathType = 'M';
            }
            else {
                pathType = 'L';
            }
            // TODO: save previous points and calculate new path just if points are updated, and then save currents values as previous
            var /** @type {?} */ targetX = anchor.x, /** @type {?} */ targetY = anchor.y;
            if (i > 0 && i < this.getAnchorsCount() - 1) {
                // get new x,y
                var /** @type {?} */ cx = anchor.x, /** @type {?} */ cy = anchor.y;
                // pivot point of prev line
                var /** @type {?} */ AO = this.getLineLength(i - 1);
                if (AO < this.radius) {
                    AO = this.radius;
                }
                this.isDefaultConditionAvailable = (this.isDefaultConditionAvailable || (i === 1 && AO > 10));
                var /** @type {?} */ ED = this.getLineLengthY(i - 1) * this.radius / AO;
                var /** @type {?} */ OD = this.getLineLengthX(i - 1) * this.radius / AO;
                targetX = anchor.x - OD;
                targetY = anchor.y - ED;
                if (AO < 2 * this.radius && i > 1) {
                    targetX = anchor.x - this.getLineLengthX(i - 1) / 2;
                    targetY = anchor.y - this.getLineLengthY(i - 1) / 2;
                }
                // pivot point of next line
                var /** @type {?} */ AO = this.getLineLength(i);
                if (AO < this.radius) {
                    AO = this.radius;
                }
                var /** @type {?} */ ED = this.getLineLengthY(i) * this.radius / AO;
                var /** @type {?} */ OD = this.getLineLengthX(i) * this.radius / AO;
                var /** @type {?} */ nextSrcX = anchor.x + OD;
                var /** @type {?} */ nextSrcY = anchor.y + ED;
                if (AO < 2 * this.radius && i < this.getAnchorsCount() - 2) {
                    nextSrcX = anchor.x + this.getLineLengthX(i) / 2;
                    nextSrcY = anchor.y + this.getLineLengthY(i) / 2;
                    
                }
                var /** @type {?} */ dx0 = (cx - targetX) / 3, /** @type {?} */ dy0 = (cy - targetY) / 3, /** @type {?} */ ax = cx - dx0, /** @type {?} */ ay = cy - dy0, /** @type {?} */ dx1 = (cx - nextSrcX) / 3, /** @type {?} */ dy1 = (cy - nextSrcY) / 3, /** @type {?} */ bx = cx - dx1, /** @type {?} */ by = cy - dy1, /** @type {?} */ zx = nextSrcX, /** @type {?} */ zy = nextSrcY;
            }
            else if (i === 1 && this.getAnchorsCount() === 2) {
                var /** @type {?} */ AO = this.getLineLength(i - 1);
                if (AO < this.radius) {
                    AO = this.radius;
                }
                this.isDefaultConditionAvailable = (this.isDefaultConditionAvailable || (i === 1 && AO > 10));
            }
            // anti smoothing
            if (this.strokeWidth % 2 === 1) {
                targetX += 0.5;
                targetY += 0.5;
            }
            path.push([pathType, targetX, targetY]);
            if (i > 0 && i < this.getAnchorsCount() - 1) {
                path.push(['C', ax, ay, bx, by, zx, zy]);
            }
        }
        if (this.closePath) {
            path.push(['Z']);
        }
        this.path = path;
    }
    /**
     * @param {?} transformation
     * @return {?}
     */
    transform(transformation) {
        this.element.transform(transformation);
    }
    /**
     * @param {?} attrs
     * @return {?}
     */
    function(attrs) {
        this.element.attr(attrs);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelFlowArrowDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.ARROW_WIDTH = 4;
        this.SEQUENCEFLOW_STROKE = 1.5;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.flow);
    }
    /**
     * @param {?} flow
     * @return {?}
     */
    draw(flow) {
        let /** @type {?} */ line = this.drawLine(flow);
        this.drawArrow(line);
    }
    /**
     * @param {?} flow
     * @return {?}
     */
    drawLine(flow) {
        let /** @type {?} */ polyline = new Polyline(flow.id, flow.waypoints, this.SEQUENCEFLOW_STROKE, this.paper);
        polyline.element = this.paper.path(polyline.path);
        polyline.element.attr({ 'stroke-width': this.SEQUENCEFLOW_STROKE });
        polyline.element.attr({ 'stroke': '#585858' });
        polyline.element.node.id = this.flow.id;
        let /** @type {?} */ lastLineIndex = polyline.getLinesCount() - 1;
        let /** @type {?} */ line = polyline.getLine(lastLineIndex);
        return line;
    }
    /**
     * @param {?} line
     * @return {?}
     */
    drawArrow(line) {
        let /** @type {?} */ doubleArrowWidth = 2 * this.ARROW_WIDTH;
        let /** @type {?} */ width = this.ARROW_WIDTH / 2 + .5;
        let /** @type {?} */ arrowHead = this.paper.path('M0 0L-' + width + '-' + doubleArrowWidth + 'L' + width + ' -' + doubleArrowWidth + 'z');
        arrowHead.transform('t' + line.x2 + ',' + line.y2);
        let /** @type {?} */ angle = Raphael.deg(line.angle - Math.PI / 2);
        arrowHead.transform('...r' + angle + ' 0 0');
        arrowHead.attr('fill', '#585858');
        arrowHead.attr('stroke-width', this.SEQUENCEFLOW_STROKE);
        arrowHead.attr('stroke', '#585858');
    }
}
RaphaelFlowArrowDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-flow-arrow' },] },
];
/**
 * @nocollapse
 */
RaphaelFlowArrowDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelFlowArrowDirective.propDecorators = {
    'paper': [{ type: Input },],
    'flow': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelMultilineTextDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.TEXT_PADDING = 3;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.text === null || this.text === undefined) {
            this.text = '';
        }
        this.draw(this.position, this.text);
    }
    /**
     * @param {?} position
     * @param {?} text
     * @return {?}
     */
    draw(position, text) {
        let /** @type {?} */ textPaper = this.paper.text(position.x + this.TEXT_PADDING, position.y + this.TEXT_PADDING, text).attr({
            'text-anchor': 'middle',
            'font-family': 'Arial',
            'font-size': '11',
            'fill': '#373e48'
        });
        let /** @type {?} */ formattedText = this.formatText(textPaper, text, this.elementWidth);
        textPaper.attr({
            'text': formattedText
        });
        textPaper.transform(this.transform);
        return textPaper;
    }
    /**
     * @param {?} textPaper
     * @param {?} text
     * @param {?} elementWidth
     * @return {?}
     */
    formatText(textPaper, text, elementWidth) {
        let /** @type {?} */ pText = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        textPaper.attr({
            'text': pText
        });
        let /** @type {?} */ letterWidth = textPaper.getBBox().width / text.length;
        let /** @type {?} */ removedLineBreaks = text.split('\n');
        let /** @type {?} */ actualRowLength = 0, /** @type {?} */ formattedText = [];
        removedLineBreaks.forEach(senteces => {
            let /** @type {?} */ words = senteces.split(' ');
            words.forEach(word => {
                let /** @type {?} */ length = word.length;
                if (actualRowLength + (length * letterWidth) > elementWidth) {
                    formattedText.push('\n');
                    actualRowLength = 0;
                }
                actualRowLength += length * letterWidth;
                formattedText.push(word + ' ');
            });
            formattedText.push('\n');
            actualRowLength = 0;
        });
        return formattedText.join('');
    }
}
RaphaelMultilineTextDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-multiline-text' },] },
];
/**
 * @nocollapse
 */
RaphaelMultilineTextDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelMultilineTextDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'transform': [{ type: Input },],
    'text': [{ type: Input },],
    'elementWidth': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelPentagonDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ opts = {
            'stroke-width': this.strokeWidth,
            'fill': this.fillColors,
            'stroke': this.stroke,
            'fill-opacity': this.fillOpacity,
            'stroke-linejoin': 'bevel'
        };
        this.draw(this.center, opts);
    }
    /**
     * @param {?} center
     * @param {?=} opts
     * @return {?}
     */
    draw(center, opts) {
        let /** @type {?} */ penta = this.paper.path('M 20.327514,22.344972 L 11.259248,22.344216 L 8.4577203,13.719549' +
            ' L 15.794545,8.389969 L 23.130481,13.720774 L 20.327514,22.344972 z').attr(opts);
        penta.transform('T' + (center.x + 4) + ',' + (center.y + 4));
    }
}
RaphaelPentagonDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-pentagon' },] },
];
/**
 * @nocollapse
 */
RaphaelPentagonDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelPentagonDirective.propDecorators = {
    'center': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'strokeWidth': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
    'strokeLinejoin': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelPlusDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ opts = { 'stroke-width': this.strokeWidth, 'fill': this.fillColors, 'stroke': this.stroke, 'fill-opacity': this.fillOpacity };
        this.draw(this.center, opts);
    }
    /**
     * @param {?} center
     * @param {?=} opts
     * @return {?}
     */
    draw(center, opts) {
        let /** @type {?} */ path = this.paper.path('M 6.75,16 L 25.75,16 M 16,6.75 L 16,25.75').attr(opts);
        return path.transform('T' + (center.x + 4) + ',' + (center.y + 4));
    }
}
RaphaelPlusDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-plus' },] },
];
/**
 * @nocollapse
 */
RaphaelPlusDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelPlusDirective.propDecorators = {
    'center': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'strokeWidth': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelRectDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.radius = 0;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ opts = {
            'stroke-width': this.strokeWidth,
            'fill': this.fillColors,
            'stroke': this.stroke,
            'fill-opacity': this.fillOpacity
        };
        let /** @type {?} */ elementDraw = this.draw(this.leftCorner, this.width, this.height, this.radius, opts);
        elementDraw.node.id = this.elementId;
    }
    /**
     * @param {?} leftCorner
     * @param {?} width
     * @param {?} height
     * @param {?} radius
     * @param {?} opts
     * @return {?}
     */
    draw(leftCorner, width, height, radius, opts) {
        return this.paper.rect(leftCorner.x, leftCorner.y, width, height, radius).attr(opts);
    }
}
RaphaelRectDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-rect' },] },
];
/**
 * @nocollapse
 */
RaphaelRectDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelRectDirective.propDecorators = {
    'paper': [{ type: Input },],
    'leftCorner': [{ type: Input },],
    'width': [{ type: Input },],
    'height': [{ type: Input },],
    'radius': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'strokeWidth': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
    'elementId': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelRhombusDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ opts = { 'stroke-width': this.strokeWidth, 'fill': this.fillColors, 'stroke': this.stroke, 'fill-opacity': this.fillOpacity };
        let /** @type {?} */ elementDraw = this.draw(this.center, this.width, this.height, opts);
        elementDraw.node.id = this.elementId;
    }
    /**
     * @param {?} center
     * @param {?} width
     * @param {?} height
     * @param {?=} opts
     * @return {?}
     */
    draw(center, width, height, opts) {
        return this.paper.path('M' + center.x + ' ' + (center.y + (height / 2)) +
            'L' + (center.x + (width / 2)) + ' ' + (center.y + height) +
            'L' + (center.x + width) + ' ' + (center.y + (height / 2)) +
            'L' + (center.x + (width / 2)) + ' ' + center.y + 'z').attr(opts);
    }
}
RaphaelRhombusDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-rhombus' },] },
];
/**
 * @nocollapse
 */
RaphaelRhombusDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelRhombusDirective.propDecorators = {
    'center': [{ type: Input },],
    'width': [{ type: Input },],
    'height': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'strokeWidth': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
    'elementId': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelTextDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.text === null || this.text === undefined) {
            this.text = '';
        }
        this.draw(this.position, this.text);
    }
    /**
     * @param {?} position
     * @param {?} text
     * @return {?}
     */
    draw(position, text) {
        let /** @type {?} */ textPaper = this.paper.text(position.x, position.y, text).attr({
            'text-anchor': 'middle',
            'font-family': 'Arial',
            'font-size': '11',
            'fill': '#373e48'
        });
        textPaper.transform(this.transform);
        return textPaper;
    }
}
RaphaelTextDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-text' },] },
];
/**
 * @nocollapse
 */
RaphaelTextDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelTextDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'transform': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconAlfrescoPublishDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ startX = position.x + 2;
        let /** @type {?} */ startY = position.y + 2;
        let /** @type {?} */ path1 = this.paper.path(`M4.11870968,2.12890323 L6.12954839,0.117935484 L3.10993548,0.118064516 L3.10270968,0.118064516
         C1.42941935,0.118064516 0.0729032258,1.47458065 0.0729032258,3.14774194 C0.0729032258,4.82116129 1.42929032,6.17754839
         3.10258065,6.17754839 C3.22967742,6.17754839 3.35470968,6.16877419 3.47767742,6.15354839 C2.8163871,4.85083871
         3.02954839,3.21793548 4.11870968,2.12890323M6.57032258,3.144 L6.57032258,0.300258065 L4.43522581,2.4356129 L4.43006452,2.44064516
         C3.24683871,3.62387097 3.24683871,5.54219355 4.43006452,6.72541935 C5.61329032,7.90864516 7.5316129,7.90864516
         8.71483871,6.72541935 C8.80464516,6.6356129 8.88529032,6.54025806 8.96154839,6.44270968 C7.57341935,5.98864516
         6.57045161,4.68387097 6.57032258,3.144`).attr({
            'stroke': this.stroke,
            'fill': '#87C040',
            'stroke-width': this.strokeWidth
        });
        let /** @type {?} */ startX1 = startX + 1.419355;
        let /** @type {?} */ startY1 = startY + 8.387097;
        path1.transform('T' + startX1 + ',' + startY1);
        path1 = this.paper.path(`M10.4411613,10.5153548 L8.43032258,8.50451613 L8.43032258,11.5313548 C8.43032258,13.2047742 9.78683871,
        14.5611613 11.460129,14.5611613 C13.1334194,14.5611613 14.4899355,13.2047742 14.4899355,11.5314839 C14.4899355,11.4043871
        14.4811613,11.2793548 14.4659355,11.1563871 C13.1632258,11.8178065 11.5303226,11.6045161 10.4411613,10.5153548M15.0376774,
        5.91935484 C14.947871,5.82954839 14.8526452,5.74890323 14.7550968,5.67264516 C14.3010323,7.06064516 12.996129,8.06374194
        11.4563871,8.06374194 L8.61277419,8.06374194 L10.7529032,10.204 C11.936129,11.3872258 13.8545806,11.3872258 15.0376774,10.204
        C16.2209032,9.02077419 16.2209032,7.10245161 15.0376774,5.91935484`).attr({
            'stroke': this.stroke,
            'fill': '#87C040',
            'stroke-width': this.strokeWidth
        });
        path1.transform('T' + startX + ',' + startY);
        path1 = this.paper.path(`M5.9083871,1.5636129 C5.78129032,1.5636129 5.65625806,1.57225806 5.53329032,1.58748387
         C6.19458065,2.89032258 5.98141935,4.52309677 4.89225806,5.61225806 L2.88154839,7.62309677 L5.9083871,7.62309677
         C7.58154839,7.62309677 8.93806452,6.26658065 8.93806452,4.59329032 C8.93819355,2.92 7.58167742,1.5636129
         5.9083871,1.5636129`).attr({
            'stroke': this.stroke,
            'fill': '#ED9A2D',
            'stroke-width': this.strokeWidth
        });
        let /** @type {?} */ startX2 = startX + 5.548387;
        path1.transform('T' + startX2 + ',' + startY);
        path1 = this.paper.path(`M4.58090323,1.0156129 C3.39767742,-0.167483871 1.47935484,-0.167483871 0.296129032,1.01574194
         C0.206451613,1.10554839 0.125806452,1.20077419 0.0495483871,1.29845161 C1.43754839,1.75251613 2.44064516,3.05729032
         2.44064516,4.59703226 L2.44064516,7.44077419 L4.57574194,5.30554839 L4.58090323,5.30051613 C5.76412903,4.11729032
         5.76412903,2.19896774 4.58090323,1.0156129`).attr({
            'stroke': this.stroke,
            'fill': '#5698C6',
            'stroke-width': this.strokeWidth
        });
        path1.transform('T' + startX2 + ',' + startY);
        path1 = this.paper.path(`M5.54051613,5.61432258 L5.62670968,5.70425806 L7.54632258,7.62387097 L7.5483871,7.62387097
         L7.5483871,4.604 L7.5483871,4.59677419 C7.5483871,2.92348387 6.19187097,1.56696774 4.51858065,1.56696774 C2.84529032,1.56696774
         1.48877419,2.92335484 1.48890323,4.59664516 C1.48890323,4.72348387 1.49754839,4.84812903 1.51264516,4.97083871
         C2.81625806,4.30993548 4.45122581,4.52503226 5.54051613,5.61432258M1.23251613,10.4292903 C1.25625806,10.3588387
         1.28180645,10.2894194 1.30980645,10.2210323 C1.31329032,10.2123871 1.3163871,10.2036129 1.32,10.1952258 C1.35070968,10.1216774
         1.38451613,10.0500645 1.42,9.97935484 C1.42774194,9.96374194 1.43574194,9.9483871 1.44387097,9.93277419 C1.4803871,9.86258065
         1.51883871,9.79354839 1.55987097,9.72632258 C1.56425806,9.71909677 1.56903226,9.71225806 1.57341935,9.70529032
         C1.6123871,9.64245161 1.65354839,9.58141935 1.6963871,9.52141935 C1.70516129,9.50903226 1.71380645,9.49651613
         1.72283871,9.48425806 C1.76890323,9.42154839 1.81690323,9.36064516 1.86683871,9.30129032 C1.87703226,9.28916129
         1.88735484,9.27741935 1.89780645,9.26567742 C1.94658065,9.20916129 1.99690323,9.15406452 2.04916129,9.10090323
         C2.05380645,9.09625806 2.05806452,9.09135484 2.06270968,9.08670968 C2.11832258,9.03083871 2.17625806,8.97741935
         2.23548387,8.92554839 C2.2483871,8.91419355 2.26129032,8.90296774 2.27432258,8.89187097 C2.33393548,8.84103226
         2.39496774,8.79212903 2.45780645,8.74529032 C2.46606452,8.73922581 2.47470968,8.73354839 2.48296774,8.7276129
         C2.54167742,8.68490323 2.60180645,8.64412903 2.66322581,8.60503226 C2.67535484,8.59729032 2.68735484,8.58929032
         2.6996129,8.58167742 C2.76593548,8.54064516 2.83380645,8.50206452 2.90296774,8.46541935 C2.91754839,8.45780645
         2.93225806,8.45045161 2.94696774,8.44296774 C3.016,8.40774194 3.08593548,8.37406452 3.15741935,8.34348387 C3.16090323,8.34206452
         3.16425806,8.3403871 3.16774194,8.33883871 C3.24167742,8.30748387 3.31729032,8.27948387 3.39380645,8.25316129
         C3.41032258,8.24748387 3.42670968,8.24180645 3.44335484,8.2363871 C3.51909677,8.21174194 3.59587097,8.18903226
         3.67380645,8.16929032 C3.68567742,8.16645161 3.69793548,8.16387097 3.70980645,8.16116129 C3.78206452,8.14374194
         3.85509677,8.12877419 3.92890323,8.116 C3.94270968,8.11367742 3.9563871,8.11083871 3.97019355,8.10877419 C4.05032258,8.09587097
         4.13148387,8.08619355 4.21329032,8.07896774 C4.23096774,8.07741935 4.24877419,8.07625806 4.26645161,8.07483871
         C4.35109677,8.06877419 4.43612903,8.06451613 4.52232258,8.06451613 L7.36606452,8.0643871 L5.22580645,5.92412903
         C4.04258065,4.74103226 2.12412903,4.74090323 0.941032258,5.92412903 C-0.242193548,7.10735484 -0.242193548,9.02567742
         0.941032258,10.2089032 C1.03070968,10.2985806 1.12464516,10.3814194 1.22206452,10.4575484 C1.22529032,10.448 1.22929032,10.4388387
         1.23251613,10.4292903`).attr({
            'stroke': this.stroke,
            'fill': '#5698C6',
            'stroke-width': this.strokeWidth
        });
        path1.transform('T' + startX + ',' + startY);
        path1 = this.paper.path(`M5.23290323,5.92412903 L6.92748387,7.61870968 L4.64980645,7.61870968 L4.52064516,7.62141935
         C3.13354839,7.62141935 1.96425806,6.68929032 1.60477419,5.41729032 C2.75870968,4.77019355 4.24619355,4.93754839
         5.22787097,5.91909677 L5.23290323,5.92412903M7.54722581,4.59612903 L7.54722581,6.99264516 L5.93664516,5.38206452
         L5.84348387,5.29264516 C4.86258065,4.31187097 4.69483871,2.82580645 5.34012903,1.67225806 C6.61367742,2.03070968
         7.54722581,3.20090323 7.54722581,4.58890323 L7.54722581,4.59612903M10.1385806,5.29819355 L8.444,6.99290323 L8.444,4.71522581
         L8.44129032,4.58606452 C8.44129032,3.19896774 9.37341935,2.02954839 10.6454194,1.67019355 C11.2925161,2.82412903
         11.1251613,4.3116129 10.1436129,5.29316129 L10.1385806,5.29819355`).attr({
            'stroke': this.stroke,
            'fill': '#446BA5',
            'stroke-width': this.strokeWidth
        });
        path1.transform('T' + startX + ',' + startY);
        path1 = this.paper.path(`M11.4548387,7.61677419 L9.05832258,7.61677419 L10.6689032,6.00619355 L10.7583226,5.91303226
         C11.7390968,4.93212903 13.2251613,4.7643871 14.3787097,5.40967742 C14.0202581,6.68322581 12.8500645,7.61677419
         11.4620645,7.61677419 L11.4548387,7.61677419`).attr({
            'stroke': this.stroke,
            'fill': '#FFF101',
            'stroke-width': this.strokeWidth
        });
        path1.transform('T' + startX + ',' + startY);
        path1 = this.paper.path(`M10.7470968,10.192 L9.05251613,8.49741935 L11.3301935,8.49741935 L11.4593548,8.49470968
         C12.8464516,8.49483871 14.0157419,9.42696774 14.3752258,10.6989677 C13.2211613,11.3459355 11.7338065,11.1787097
         10.752129,10.1970323 L10.7470968,10.192M8.43729032,11.5174194 L8.43729032,9.12090323 L10.047871,10.7314839 L10.1411613,10.8209032
         C11.1219355,11.8018065 11.2896774,13.2876129 10.6443871,14.4412903 C9.37083871,14.0828387 8.43729032,12.9127742
         8.43729032,11.5245161 L8.43729032,11.5174194M5.86193548,10.8296774 L7.55651613,9.13496774 L7.55651613,11.4126452
         L7.55922581,11.5418065 C7.55922581,12.9289032 6.62709677,14.0983226 5.35509677,14.4578065 C4.708,13.3036129 4.87535484,11.8162581
         5.85690323,10.8347097 L5.86193548,10.8296774M4.53251613,8.50993548 L6.92903226,8.50993548 L5.31845161,10.1205161
         L5.22903226,10.2136774 C4.24812903,11.1945806 2.76219355,11.3623226 1.60851613,10.7170323 C1.96709677,9.44335484
         3.13716129,8.50993548 4.52529032,8.50993548 L4.53251613,8.50993548`).attr({
            'stroke': this.stroke,
            'fill': '#45AB47',
            'stroke-width': this.strokeWidth
        });
        path1.transform('T' + startX + ',' + startY);
    }
}
RaphaelIconAlfrescoPublishDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-alfresco-publish' },] },
];
/**
 * @nocollapse
 */
RaphaelIconAlfrescoPublishDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconAlfrescoPublishDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconBoxPublishDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ image = this.paper.image();
        image.attr({ 'x': position.x });
        image.attr({ 'y': position.y });
        image.attr({ 'id': 'image3398' });
        image.attr({ 'preserveAspectRatio': 'none' });
        image.attr({ 'height': '16' });
        image.attr({ 'width': '17' });
        image.attr({ 'src': `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAjCAYAAADxG9hnAAAABmJLR0QA/wD/AP+gvaeTAAAACXBI WXMAAA7DAAAO
        wwHHb6hkAAAAB3RJTUUH3wQXDxwCFNe28AAACsdJREFUWMOVmGmMXtV5x3/POfe+ y2yeGc/mwbMZG9tDMGBTKC5GCU4pbYmSRlmowlIFJWnUprSiy4dI/UA/9EsVifZDmy
        ZIxEpo1Cql UKICqbABG+x4X4M9iz2bxzOefXnfee+95zz9cN9Z7NqVeqSje3XPec/5n/Ns//8rAAd6xvj0lmYA VJWTI9fN2d5BikslrDEYY0ABIX0aUBUUUJS1TZB0HZS
        lUsz8fBHF09neKnFU0t964B5trcoqwA8O fsI3HtmW/u7Hx3p5+oHNqCr7DpzLX3dh1+xC4Z7p2dnGKE7UGmOsNTYFIuXtUlQqsgJkGSdrgBRL 8dLCYlRUUTa1NrYXiqWZ
        jqb6q/vPDHz43S/vXHika0Phr984yUufv5/llfnJ0f473z9/7c+P9E8+ 3zdRCAuJR8SU1zUpBhFWL0BATAqhvIqIlCEIqK65JfDOIHgqpUT3HesW9mxreOWejfUvPfPrm6
        de fu8Sgary2sm+5v84NvT9d85P7Z1zhkwmTyZD+dSAKFI2jyAgqQEMkoJFQR1ZC1W5gMowxAgkzlOI HPMlh3ceFUtCjuPXtap3cuSFL9ybdKrq10RkMfi7Nz42g/P+2YP
        9i3sjm6E6a8snS0+ogBcwIki5 g2AkPXGAsqk+z/YNVWxuyLBxXZ66XIbQQimOmSgkDM9G9IwVODda5OpcEc0YYs3xbs/C73z39VMv Ai8FP/rlqG1vafjLGZenusKn121W
        7jr1TxFE0tsQI/iyibbVBTzZvZ6H22vY1lJDQ0WW27Vrs4uc G5vj/d453jw7yWQxomQqwiODs59T1X1yaHh+17dfPXxswuXAWlTBiCcbQmANiVOiRMBabGgJ8YiB xzqre
        W5nM/e31pALLKjiEXTVZW5oxnjAML2UcGJoin86PMbxy9Osr8n3/enu9q8HxVLcsCBVhLkM m+vgs1tquW9DDY1VGUJrSBLPeCHh+Ng8H12Z4+oiPHlXNd9+cANNFVkExTm
        HUvYVuCmg0+a9AVXW ZSyfvrORtroKXj6YZf/lJekfnzNB7EPfWak8/UgLj29dzzoLYRAgxiCSRoDz8FBHFc/c18CV2ZjN 9TmachY0wavBi8Gs2V3XRMvab6Lg1QHQWV/J
        d/ZspCE3zPTEJHJqaPpJE9j/3Lo+g8Ou5AK95QWv 5gu5jS/oTUBuNc+veU4Xo/5LvUPPB1XJXKmtaQOJBy+G5Xwp3L7pmsXkFmM3g+Y2cwxQH0J3SwVB oF5iNXhA8MwWI
        2bmCzTWVJLPhssZ/fZgbtpJ1jirQpqHuPUcRfHe4zwYZy0JDu89onDw3AB/9f23 OdU/jqriVHH+f3fvFbyCu7FrecyV328eT+c4vDq8ehwCJiRQ9ah68EKMUIqU2FuKCTi
        nGFG8rta7 /09bk+XT5Kg3FUgRvFdUlQA1OA9oeiPOe6JE8R7EeMQYAgSngHN4XWN5gdAYjKRm8gqJdxgVQptG W+I9qecp1gjGGiLn0nKhgvfg1BMYsXgVVD1GhSRRojiB
        QBgan2N4bIal2FNRmWFLWwP1VXmiOCaw lmKUcGHkOlOzi6gIrfXVbG5vpFhIOHplmNb6dWxsqsEliljPxGLCJ5eHufuuNirCEJzHe/B4AqVs V1VUDbFXPCH/fbSPn5c8Y
        9MFlhzks8qm5jy/vauL3Xd3cunqJG8e6uHc0CKzxRIiSktVhvs6a7l3 +0b+4d9PcO+2dp7bu536qiyJwr53z3Csd5pvSciD3R2oJqh6BJMC8d7jUcQrSRnUsb4ZjFvioe2
        t 1FXn6RuZ5YPTE4xMR4xMFjk7MMGBs9fobKzm4a2NJAkcPj/I5fEi50fnaaqv5t2TA7TUZXjqM3fz swOXOHB+nHwIHRvW45wDPIpHRctA1OMUrNG0dMdKpS3ywlceYEdH
        E3nxLMbCW0f6eW1/H+NjPRSi iIe33sFzn+2mqTbE43li9xb+9tX36BldYPeWOhpmS7x+qJ/J2QJHL00zO1/gxT94lLqqLN4nqfNq enADoF5RlEQdcaLMLSh7793KrrZGq
        oMAE+aorgj4zQc6aGsMGC0uEeQse3dtoLU5AyHYTEBbfZ4v fuY+xq8vMF8SvvToVqbmIn52ZJSe0SmeeqybHe1VpJGaRov3HlQxKCu5QhWcV6J4kfaWPCYTgkaI i1CvZM
        XQsq6G+SWhtrKC9ZWWRAOs8+ASrEvYvqGK+WKJycWYXXc1cc+mJuYWCmxsruOJnW3ENkS9 T3ORLqcEg1FNP3hVRIR8JsCZkMtjBeKlmIiQJbEk4lmMPSMTc+Airs8sMDn
        nMV6JsSQIkVF6xhZA IGOFU73XOXFpDGOy9A5e54MLw5jYk6zsCd4L6srZ22uaDb1Tupqr6Wqs4Y0PL3Cy9xoLhRgflZiZ KfLeyUGOX54jlw0Znlzg5ycG6RufphTHRMUS
        V8aK7Hv7LLlcnqxVXnnnIpE37OluoKaqgu/962nO DU0ABvW+nIU9Xj32j1/4sztNmH0mNY1j/boKioWYD341wcELw0wvRPSPFXj98BV+8ovztDXV8IXf 6MAay9tHB+i7O
        svkfMzRnkl++NYZLo4ssq1jHQtFz/GeCb766Cb+5Ev3Uygucax3itN9E+zZ0UJF NkiTo+q0c8mbAWVeqmVfMVb53T2bSIzjv45d46f7L7EQRdRVV7Jz60Z+b3c7TzzYydm
        +KSozliMX J/no7AmMtWxsruTzezr5te1NvPTKIR75VCuf29NFzsJTj22l7+oivzh2hV8NTdF4d2vqqGXaKZcu Dz1uK6reiZYLFoKx6ZVdHJpm4FqBQqLUVgTc1VpDZ2sd
        LooIg4Dx2QIXBme5PlPEWENLXYYdXQ0k GA6dHqSjtZbu9lqS2GMtXJ4ocubSKA99qp3mKluWSaaf0tLzcrF/4PFMde07S7HDeY9XA+IRlMBa UmmTclH1CbEvs3hVjBGsT
        TWPR1Dv8c6hCJkgIFGfyohyBbTWYIwldh4rihXBCv2+VHw+ACFOkrI+ AVUHKB5wSZKWt7U0UFZ5qfdpkVzhHivVVSlG0YosWZayPnGIeIwIxhhCa7CizJWWMKoq10avYa1
        d ob5ry7X+HyzNAQkpZ7m5xC9vrrcYMyiBKNnQEEURx48fwyg6MHBlgFwuR2ADjLHp7SzTK13loemp pdxZUX6p8DJrWOqNXcQgRhBjMNZggpBcGOCimJ6+y766pt7Zjs3d
        s9bIsyC1dzTXpYuLsLyskbL2 Lj9FTDpuZGVsZW5ZKouk7+k/CZKaQiAwQmgt+UAIrGFgZJSPD//y9Lee/vL3gj0P7XRDV6/9zcGD B39obEBXexvWeJwX3HJNuNFJVo0js
        sJPV+XoKpsTkbJUNRj1ZeAGj/JJ/xAffvD+bPuGxn8TkUUB +MdX9mUix99fm5r7eldXV9jR3ka+IpdGg9eyxExt4ctJR8vMWVbASJmHKcYuy1NTHhdEPOphYXGR viuDjA
        4Nz9XlzasvfucPXwCQH+z7Kd949il6e3qCt97d/xdjUzNfyVTUbAyy2bwxqWwymBuqpV/z XMtlRTXVyUawYjDWrgDxeESdxHFpJi4sjqyvrXntxT/65ssAR06dSw/zzz/6
        F7753O8D8NHHR9rO nL+wZ2pqYl0cxyoIoqsm0LK49ehKKLNGp3gE1JRF+9qoU3JBIDVVuZGvffWLZ2oa7rgCcPLMBe7f 0c3/APbD8KaWhlC3AAAAAElFTkSuQmCC` });
    }
}
RaphaelIconBoxPublishDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-box-publish' },] },
];
/**
 * @nocollapse
 */
RaphaelIconBoxPublishDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconBoxPublishDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconBusinessRuleDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`m 1,2 0,14 16,0 0,-14 z m 1.45458,5.6000386 2.90906,0 0,2.7999224 -2.90906,0 z m 4.36364,0 8.72718,0
         0,2.7999224 -8.72718,0 z m -4.36364,4.1998844 2.90906,0 0,2.800116 -2.90906,0 z m
         4.36364,0 8.72718,0 0,2.800116 -8.72718,0 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconBusinessRuleDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-business-rule' },] },
];
/**
 * @nocollapse
 */
RaphaelIconBusinessRuleDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconBusinessRuleDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconCamelDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`m 8.1878027,15.383782 c -0.824818,-0.3427 0.375093,-1.1925 0.404055,-1.7743 0.230509,-0.8159
         -0.217173,-1.5329 -0.550642,-2.2283 -0.106244,-0.5273 -0.03299,-1.8886005 -0.747194,-1.7818005 -0.712355,0.3776 -0.9225,1.2309005
         -1.253911,1.9055005 -0.175574,1.0874 -0.630353,2.114 -0.775834,3.2123 -0.244009,0.4224 -1.741203,0.3888 -1.554386,-0.1397
         0.651324,-0.3302 1.13227,-0.9222 1.180246,-1.6705 0.0082,-0.7042 -0.133578,-1.3681 0.302178,-2.0083 0.08617,-0.3202
         0.356348,-1.0224005 -0.218996,-0.8051 -0.694517,0.2372 -1.651062,0.6128 -2.057645,-0.2959005 -0.696769,0.3057005 -1.102947,-0.611
         -1.393127,-1.0565 -0.231079,-0.6218 -0.437041,-1.3041 -0.202103,-1.9476 -0.185217,-0.7514 -0.39751099,-1.5209 -0.35214999,-2.301
         -0.243425,-0.7796 0.86000899,-1.2456 0.08581,-1.8855 -0.76078999,0.1964 -1.41630099,-0.7569 -0.79351899,-1.2877 0.58743,-0.52829998
         1.49031699,-0.242 2.09856399,-0.77049998 0.816875,-0.3212 1.256619,0.65019998 1.923119,0.71939998 0.01194,0.7333 -0.0031,1.5042
         -0.18417,2.2232 -0.194069,0.564 -0.811196,1.6968 0.06669,1.9398 0.738382,-0.173 1.095723,-0.9364 1.659041,-1.3729 0.727298,-0.3962
         1.093982,-1.117 1.344137,-1.8675 0.400558,-0.8287 1.697676,-0.6854 1.955367,0.1758 0.103564,0.5511 0.9073983,1.7538
         1.2472763,0.6846 0.121868,-0.6687 0.785541,-1.4454 1.518183,-1.0431 0.813587,0.4875 0.658233,1.6033 1.285504,2.2454
         0.768715,0.8117 1.745394,1.4801 2.196633,2.5469 0.313781,0.8074 0.568552,1.707 0.496624,2.5733 -0.35485,0.8576005 -1.224508,-0.216
         -0.64725,-0.7284 0.01868,-0.3794 -0.01834,-1.3264 -0.370249,-1.3272 -0.123187,0.7586 -0.152778,1.547 -0.10869,2.3154
         0.270285,0.6662005 1.310741,0.7653005 1.060553,1.6763005 -0.03493,0.9801 0.294343,1.9505 0.148048,2.9272 -0.320479,0.2406
         -0.79575,0.097 -1.185062,0.1512 -0.165725,0.3657 -0.40138,0.921 -1.020848,0.6744 -0.564671,0.1141 -1.246404,-0.266
         -0.578559,-0.7715 0.679736,-0.5602 0.898618,-1.5362 0.687058,-2.3673 -0.529674,-1.108 -1.275984,-2.0954005 -1.839206,-3.1831005
         -0.634619,-0.1004 -1.251945,0.6779 -1.956789,0.7408 -0.6065893,-0.038 -1.0354363,-0.06 -0.8495673,0.6969005 0.01681,0.711
         0.152396,1.3997 0.157345,2.1104 0.07947,0.7464 0.171287,1.4944 0.238271,2.2351 0.237411,1.0076 -0.687542,1.1488 -1.414811,0.8598
         z m 6.8675483,-1.8379 c 0.114364,-0.3658 0.206751,-1.2704 -0.114466,-1.3553 -0.152626,0.5835 -0.225018,1.1888 -0.227537,1.7919
         0.147087,-0.1166 0.265559,-0.2643 0.342003,-0.4366 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconCamelDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-camel' },] },
];
/**
 * @nocollapse
 */
RaphaelIconCamelDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconCamelDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconErrorDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`M 22.820839,11.171502 L 19.36734,24.58992 L 13.54138,14.281819 L 9.3386512,20.071607
        L 13.048949,6.8323057 L 18.996148,16.132659 L 22.820839,11.171502 z`).attr({
            'opacity': 1,
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconErrorDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-error' },] },
];
/**
 * @nocollapse
 */
RaphaelIconErrorDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconErrorDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconGoogleDrivePublishDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ image = this.paper.image();
        image.attr({ 'x': position.x });
        image.attr({ 'y': position.y });
        image.attr({ 'id': 'image3398' });
        image.attr({ 'preserveAspectRatio': 'none' });
        image.attr({ 'height': '16' });
        image.attr({ 'width': '17' });
        image.attr({ 'src': `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBA
        JqcGAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAIHSURBVDiNpVI7a1RREP7mzLl3d+9mScxaiBLFwohxQcXCwjwao/gqFAQhRGOphQgmgs9oGxaV
        gFhpYPUPGMFCCzEqCgETg0uK4CuFoLhZyWNf994zFrqy9xJWwQ+mOB8z33wzZ4D/BIWJppG+plstc+mjK9yttbzALHExcoDaRxdqeRUWcFkGBz7G1s152CCQ7dUAqNOLuZf
        qOmi439MmhifF86e6uLj4MFXoCuVXWPkp2vZkZlkHYvRNAJYwtz79oXdMLfFMSMD2Dd9YdoSGTO9hQLoBQBESQvLpUNaZD1sGsN8d390dFBjpiwooHVBW6tvXCr2H4EFo6L
        wR97pkj9h/BByWfgDrA4lRTWDvHIPOAihVaWO8txCkygu50wBAsbsnWpT2pwHEA/sgXC30Zq4BwJfHHRdY0R4nxp5mbFGEJIB5l2SjVtoMhYsBfC5EikPVh7Z4uFyqnKq43
        hoQFrXCIydCjZbWlyl+79gzCDprq1dPnnyhS8nNZDmvRVmbAIDhKyL5/e2kjKi4pbwxLQZniDAOgAHAybW90aXmncp2xoSsvdVDMWBAAi69sqsvqsLxzARB7vxaMHvJDwcT
        ZCVeClnhIwqC5Pb08Kp3CgBUxT4PINc4u+u54uY8FLfXLQa+sx0dRNV2eXSi6OzryK2c7Wkl0msB5OuG0JVsOvnqL03+DT8BxkC5RkIpSlIAAAAASUVORK5CYII=` });
    }
}
RaphaelIconGoogleDrivePublishDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-google-drive-publish' },] },
];
/**
 * @nocollapse
 */
RaphaelIconGoogleDrivePublishDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconGoogleDrivePublishDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconManualDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c
        0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128
        -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0
        c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15
        C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801
        0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868
        6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394
        8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232
        -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661
        l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z`).attr({
            'opacity': 1,
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconManualDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-manual' },] },
];
/**
 * @nocollapse
 */
RaphaelIconManualDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconManualDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconMessageDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`M 1 3 L 9 11 L 17 3 L 1 3 z M 1 5 L 1 13 L 5 9 L 1 5 z M 17 5 L 13 9 L 17 13 L 17 5 z M 6 10 L 1 15
        L 17 15 L 12 10 L 9 13 L 6 10 z`).attr({
            'opacity': this.fillOpacity,
            'stroke': this.stroke,
            'strokeWidth': this.strokeWidth,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconMessageDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-message' },] },
];
/**
 * @nocollapse
 */
RaphaelIconMessageDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconMessageDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconMuleDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`M 8,0 C 3.581722,0 0,3.5817 0,8 c 0,4.4183 3.581722,8 8,8 4.418278,0 8,-3.5817 8,-8 L 16,7.6562
         C 15.813571,3.3775 12.282847,0 8,0 z M 5.1875,2.7812 8,7.3437 10.8125,2.7812 c 1.323522,0.4299 2.329453,1.5645 2.8125,2.8438
         1.136151,2.8609 -0.380702,6.4569 -3.25,7.5937 -0.217837,-0.6102 -0.438416,-1.2022 -0.65625,-1.8125 0.701032,-0.2274
         1.313373,-0.6949 1.71875,-1.3125 0.73624,-1.2317 0.939877,-2.6305 -0.03125,-4.3125 l -2.75,4.0625 -0.65625,0 -0.65625,0 -2.75,-4
         C 3.5268433,7.6916 3.82626,8.862 4.5625,10.0937 4.967877,10.7113 5.580218,11.1788 6.28125,11.4062 6.063416,12.0165 5.842837,12.6085
         5.625,13.2187 2.755702,12.0819 1.238849,8.4858 2.375,5.625 2.858047,4.3457 3.863978,3.2112 5.1875,2.7812 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconMuleDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-mule' },] },
];
/**
 * @nocollapse
 */
RaphaelIconMuleDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconMuleDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconReceiveDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`m 0.5,2.5 0,13 17,0 0,-13 z M 2,4 6.5,8.5 2,13 z M 4,4 14,4 9,9 z m 12,0 0,9 -4.5,-4.5 z
         M 7.5,9.5 9,11 10.5,9.5 15,14 3,14 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconReceiveDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-receive' },] },
];
/**
 * @nocollapse
 */
RaphaelIconReceiveDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconReceiveDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconRestCallDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`m 16.704699,5.9229055 q 0.358098,0 0.608767,0.2506681 0.250669,0.250668 0.250669,0.6087677 0,0.3580997
         -0.250669,0.6087677 -0.250669,0.2506679 -0.608767,0.2506679 -0.358098,0 -0.608767,-0.2506679 -0.250669,-0.250668
         -0.250669,-0.6087677 0,-0.3580997 0.250669,-0.6087677 0.250669,-0.2506681 0.608767,-0.2506681 z m 2.578308,-2.0053502 q
         -2.229162,0 -3.854034,0.6759125 -1.624871,0.6759067 -3.227361,2.2694472 -0.716197,0.725146 -1.575633,1.7457293 L
         7.2329969,8.7876913 Q 7.0897576,8.8055849 7.000233,8.9309334 L 4.9948821,12.368677 q -0.035811,0.06267 -0.035811,0.143242
         0,0.107426 0.080572,0.205905 l 0.5729577,0.572957 q 0.125334,0.116384 0.2864786,0.07162 l 2.4708789,-0.760963 2.5156417,2.515645
         -0.76096,2.470876 q -0.009,0.02687 -0.009,0.08057 0,0.125338 0.08058,0.205905 l 0.572957,0.572958 q 0.170096,0.152194
         0.349146,0.04476 l 3.437744,-2.005351 q 0.125335,-0.08953 0.143239,-0.232763 l 0.17905,-3.392986 q 1.02058,-0.859435
         1.745729,-1.575629 1.67411,-1.6830612 2.309735,-3.2049805 0.635625,-1.5219191 0.635625,-3.8585111 0,-0.1253369 -0.08505,-0.2148575
         -0.08505,-0.089526 -0.201431,-0.089526 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconRestCallDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-rest-call' },] },
];
/**
 * @nocollapse
 */
RaphaelIconRestCallDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconRestCallDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconScriptDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312
        l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111
        5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconScriptDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-script' },] },
];
/**
 * @nocollapse
 */
RaphaelIconScriptDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconScriptDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconSendDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`M 1 3 L 9 11 L 17 3 L 1 3 z M 1 5 L 1 13 L 5 9 L 1 5 z M 17 5 L 13 9 L 17 13 L 17 5 z M 6 10 L 1 15
            L 17 15 L 12 10 L 9 13 L 6 10 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconSendDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-send' },] },
];
/**
 * @nocollapse
 */
RaphaelIconSendDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconSendDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconServiceDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path('M 8,1 7.5,2.875 c 0,0 -0.02438,0.250763 -0.40625,0.4375 C 7.05724,3.330353 7.04387,3.358818 7,3.375' +
            ' 6.6676654,3.4929791 6.3336971,3.6092802 6.03125,3.78125 6.02349,3.78566 6.007733,3.77681 6,3.78125 5.8811373,3.761018' +
            ' 5.8125,3.71875 5.8125,3.71875 l -1.6875,-1 -1.40625,1.4375 0.96875,1.65625 c 0,0 0.065705,0.068637 0.09375,0.1875' +
            ' 0.002,0.00849 -0.00169,0.022138 0,0.03125 C 3.6092802,6.3336971 3.4929791,6.6676654 3.375,7 3.3629836,7.0338489' +
            ' 3.3239228,7.0596246 3.3125,7.09375 3.125763,7.4756184 2.875,7.5 2.875,7.5 L 1,8 l 0,2 1.875,0.5 c 0,0 0.250763,0.02438' +
            ' 0.4375,0.40625 0.017853,0.03651 0.046318,0.04988 0.0625,0.09375 0.1129372,0.318132 0.2124732,0.646641 0.375,0.9375' +
            ' -0.00302,0.215512 -0.09375,0.34375 -0.09375,0.34375 L 2.6875,13.9375 4.09375,15.34375 5.78125,14.375 c 0,0' +
            ' 0.1229911,-0.09744 0.34375,-0.09375 0.2720511,0.147787 0.5795915,0.23888 0.875,0.34375 0.033849,0.01202 0.059625,0.05108' +
            ' 0.09375,0.0625 C 7.4756199,14.874237 7.5,15.125 7.5,15.125 L 8,17 l 2,0 0.5,-1.875 c 0,0 0.02438,-0.250763 0.40625,-0.4375' +
            ' 0.03651,-0.01785 0.04988,-0.04632 0.09375,-0.0625 0.332335,-0.117979 0.666303,-0.23428 0.96875,-0.40625 0.177303,0.0173' +
            ' 0.28125,0.09375 0.28125,0.09375 l 1.65625,0.96875 1.40625,-1.40625 -0.96875,-1.65625 c 0,0 -0.07645,-0.103947' +
            ' -0.09375,-0.28125 0.162527,-0.290859 0.262063,-0.619368 0.375,-0.9375 0.01618,-0.04387 0.04465,-0.05724 0.0625,-0.09375 C' +
            ' 14.874237,10.52438 15.125,10.5 15.125,10.5 L 17,10 17,8 15.125,7.5 c 0,0 -0.250763,-0.024382 -0.4375,-0.40625 C' +
            ' 14.669647,7.0572406 14.641181,7.0438697 14.625,7 14.55912,6.8144282 14.520616,6.6141566 14.4375,6.4375 c -0.224363,-0.4866' +
            ' 0,-0.71875 0,-0.71875 L 15.40625,4.0625 14,2.625 l -1.65625,1 c 0,0 -0.253337,0.1695664 -0.71875,-0.03125 l -0.03125,0 C' +
            ' 11.405359,3.5035185 11.198648,3.4455201 11,3.375 10.95613,3.3588185 10.942759,3.3303534 10.90625,3.3125 10.524382,3.125763' +
            ' 10.5,2.875 10.5,2.875 L 10,1 8,1 z m 1,5 c 1.656854,0 3,1.3431458 3,3 0,1.656854 -1.343146,3 -3,3 C 7.3431458,12' +
            ' 6,10.656854 6,9 6,7.3431458 7.3431458,6 9,6 z').attr({
            'opacity': 1,
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconServiceDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-service' },] },
];
/**
 * @nocollapse
 */
RaphaelIconServiceDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconServiceDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconSignalDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`M 8.7124971,21.247342 L 23.333334,21.247342 L 16.022915,8.5759512 L 8.7124971,21.247342 z`).attr({
            'opacity': this.fillOpacity,
            'stroke': this.stroke,
            'strokeWidth': this.strokeWidth,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconSignalDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-signal' },] },
];
/**
 * @nocollapse
 */
RaphaelIconSignalDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconSignalDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconTimerDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20
        10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5
        L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217
        15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125
        10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007
        8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5
        L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z`).attr({
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconTimerDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-timer' },] },
];
/**
 * @nocollapse
 */
RaphaelIconTimerDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconTimerDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RaphaelIconUserDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.position);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    draw(position) {
        let /** @type {?} */ path1 = this.paper.path(`m 1,17 16,0 0,-1.7778 -5.333332,-3.5555 0,-1.7778 c 1.244444,0 1.244444,-2.3111 1.244444,-2.3111
        l 0,-3.0222 C 12.555557,0.8221 9.0000001,1.0001 9.0000001,1.0001 c 0,0 -3.5555556,-0.178 -3.9111111,3.5555 l 0,3.0222 c
        0,0 0,2.3111 1.2444443,2.3111 l 0,1.7778 L 1,15.2222 1,17 17,17`).attr({
            'opacity': 1,
            'stroke': this.stroke,
            'fill': this.fillColors
        });
        return path1.transform('T' + position.x + ',' + position.y);
    }
}
RaphaelIconUserDirective.decorators = [
    { type: Directive, args: [{ selector: 'raphael-icon-user' },] },
];
/**
 * @nocollapse
 */
RaphaelIconUserDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: RaphaelService, },
];
RaphaelIconUserDirective.propDecorators = {
    'paper': [{ type: Input },],
    'position': [{ type: Input },],
    'text': [{ type: Input },],
    'error': [{ type: Output },],
    'strokeWidth': [{ type: Input },],
    'fillColors': [{ type: Input },],
    'stroke': [{ type: Input },],
    'fillOpacity': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DiagramsModule {
}
DiagramsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    DiagramComponent,
                    DiagramEventComponent,
                    DiagramStartEventComponent,
                    DiagramEndEventComponent,
                    DiagramContainerServiceTaskComponent,
                    DiagramTaskComponent,
                    DiagramServiceTaskComponent,
                    DiagramSendTaskComponent,
                    DiagramUserTaskComponent,
                    DiagramManualTaskComponent,
                    DiagramCamelTaskComponent,
                    DiagramMuleTaskComponent,
                    DiagramAlfrescoPublishTaskComponent,
                    DiagramRestCallTaskComponent,
                    DiagramGoogleDrivePublishTaskComponent,
                    DiagramBoxPublishTaskComponent,
                    DiagramReceiveTaskComponent,
                    DiagramScriptTaskComponent,
                    DiagramBusinessRuleTaskComponent,
                    DiagramSequenceFlowComponent,
                    DiagramGatewayComponent,
                    DiagramExclusiveGatewayComponent,
                    DiagramInclusiveGatewayComponent,
                    DiagramParallelGatewayComponent,
                    DiagramEventGatewayComponent,
                    DiagramIconServiceTaskComponent,
                    DiagramIconSendTaskComponent,
                    DiagramIconUserTaskComponent,
                    DiagramIconManualTaskComponent,
                    DiagramIconCamelTaskComponent,
                    DiagramIconMuleTaskComponent,
                    DiagramIconAlfrescoPublishTaskComponent,
                    DiagramIconRestCallTaskComponent,
                    DiagramIconGoogleDrivePublishTaskComponent,
                    DiagramIconBoxPublishTaskComponent,
                    DiagramIconReceiveTaskComponent,
                    DiagramIconScriptTaskComponent,
                    DiagramIconBusinessRuleTaskComponent,
                    DiagramContainerIconEventTaskComponent,
                    DiagramIconTimerComponent,
                    DiagramIconErrorComponent,
                    DiagramIconSignalComponent,
                    DiagramIconMessageComponent,
                    DiagramBoundaryEventComponent,
                    DiagramThrowEventComponent,
                    DiagramIntermediateCatchingEventComponent,
                    DiagramSubprocessComponent,
                    DiagramEventSubprocessComponent,
                    DiagramPoolsComponent,
                    DiagramPoolComponent,
                    DiagramLanesComponent,
                    DiagramLaneComponent,
                    DiagramTooltipComponent,
                    RaphaelCircleDirective,
                    RaphaelRectDirective,
                    RaphaelTextDirective,
                    RaphaelMultilineTextDirective,
                    RaphaelFlowArrowDirective,
                    RaphaelCrossDirective,
                    RaphaelPlusDirective,
                    RaphaelRhombusDirective,
                    RaphaelPentagonDirective,
                    RaphaelIconServiceDirective,
                    RaphaelIconSendDirective,
                    RaphaelIconUserDirective,
                    RaphaelIconManualDirective,
                    RaphaelIconCamelDirective,
                    RaphaelIconMuleDirective,
                    RaphaelIconAlfrescoPublishDirective,
                    RaphaelIconRestCallDirective,
                    RaphaelIconGoogleDrivePublishDirective,
                    RaphaelIconBoxPublishDirective,
                    RaphaelIconReceiveDirective,
                    RaphaelIconScriptDirective,
                    RaphaelIconBusinessRuleDirective,
                    RaphaelIconTimerDirective,
                    RaphaelIconErrorDirective,
                    RaphaelIconSignalDirective,
                    RaphaelIconMessageDirective
                ],
                providers: [
                    DiagramsService,
                    DiagramColorService,
                    RaphaelService
                ],
                exports: [
                    DiagramComponent,
                    DiagramEventComponent,
                    DiagramStartEventComponent,
                    DiagramEndEventComponent,
                    DiagramContainerServiceTaskComponent,
                    DiagramTaskComponent,
                    DiagramServiceTaskComponent,
                    DiagramSendTaskComponent,
                    DiagramUserTaskComponent,
                    DiagramManualTaskComponent,
                    DiagramCamelTaskComponent,
                    DiagramMuleTaskComponent,
                    DiagramAlfrescoPublishTaskComponent,
                    DiagramRestCallTaskComponent,
                    DiagramGoogleDrivePublishTaskComponent,
                    DiagramBoxPublishTaskComponent,
                    DiagramReceiveTaskComponent,
                    DiagramScriptTaskComponent,
                    DiagramBusinessRuleTaskComponent,
                    DiagramSequenceFlowComponent,
                    DiagramGatewayComponent,
                    DiagramExclusiveGatewayComponent,
                    DiagramInclusiveGatewayComponent,
                    DiagramParallelGatewayComponent,
                    DiagramEventGatewayComponent,
                    DiagramIconServiceTaskComponent,
                    DiagramIconSendTaskComponent,
                    DiagramIconUserTaskComponent,
                    DiagramIconManualTaskComponent,
                    DiagramIconCamelTaskComponent,
                    DiagramIconMuleTaskComponent,
                    DiagramIconAlfrescoPublishTaskComponent,
                    DiagramIconRestCallTaskComponent,
                    DiagramIconGoogleDrivePublishTaskComponent,
                    DiagramIconBoxPublishTaskComponent,
                    DiagramIconReceiveTaskComponent,
                    DiagramIconScriptTaskComponent,
                    DiagramIconBusinessRuleTaskComponent,
                    DiagramContainerIconEventTaskComponent,
                    DiagramIconTimerComponent,
                    DiagramIconErrorComponent,
                    DiagramIconSignalComponent,
                    DiagramIconMessageComponent,
                    DiagramBoundaryEventComponent,
                    DiagramThrowEventComponent,
                    DiagramIntermediateCatchingEventComponent,
                    DiagramSubprocessComponent,
                    DiagramEventSubprocessComponent,
                    DiagramPoolsComponent,
                    DiagramPoolComponent,
                    DiagramLanesComponent,
                    DiagramLaneComponent,
                    DiagramTooltipComponent,
                    RaphaelCircleDirective,
                    RaphaelRectDirective,
                    RaphaelTextDirective,
                    RaphaelMultilineTextDirective,
                    RaphaelFlowArrowDirective,
                    RaphaelCrossDirective,
                    RaphaelPlusDirective,
                    RaphaelRhombusDirective,
                    RaphaelPentagonDirective,
                    RaphaelIconServiceDirective,
                    RaphaelIconSendDirective,
                    RaphaelIconUserDirective,
                    RaphaelIconManualDirective,
                    RaphaelIconCamelDirective,
                    RaphaelIconMuleDirective,
                    RaphaelIconAlfrescoPublishDirective,
                    RaphaelIconRestCallDirective,
                    RaphaelIconGoogleDrivePublishDirective,
                    RaphaelIconBoxPublishDirective,
                    RaphaelIconReceiveDirective,
                    RaphaelIconScriptDirective,
                    RaphaelIconBusinessRuleDirective,
                    RaphaelIconTimerDirective,
                    RaphaelIconErrorDirective,
                    RaphaelIconSignalDirective,
                    RaphaelIconMessageDirective
                ]
            },] },
];
/**
 * @nocollapse
 */
DiagramsModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatAutocompleteModule, MatButtonModule, MatCardModule, MatDialogModule,
        MatCheckboxModule, MatDatepickerModule, MatGridListModule, MatIconModule, MatInputModule,
        MatListModule, MatOptionModule, MatRadioModule, MatSelectModule, MatSlideToggleModule, MatTableModule,
        MatTabsModule, MatProgressSpinnerModule, MatNativeDateModule, MatRippleModule, MatTooltipModule,
        MatChipsModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: MAT_PLACEHOLDER_GLOBAL_OPTIONS, useValue: { float: 'never' } }
                ],
                imports: modules(),
                exports: modules()
            },] },
];
/**
 * @nocollapse
 */
MaterialModule.ctorParameters = () => [];

class ParameterValueModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id;
        this.name = obj && obj.name || null;
        this.value = obj && obj.value || null;
        this.version = obj && obj.version || null;
    }
    /**
     * @return {?}
     */
    get label() {
        return this.version ? `${this.name} (v ${this.version}) ` : this.name;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ReportParameterDetailsModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id;
        this.name = obj && obj.name || null;
        this.nameKey = obj && obj.nameKey || null;
        this.type = obj && obj.type || null;
        this.value = obj && obj.value || null;
        this.options = obj && obj.options || null;
        this.dependsOn = obj && obj.dependsOn || null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ReportDefinitionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.parameters = [];
        obj.parameters.forEach((params) => {
            let reportParamsModel = new ReportParameterDetailsModel(params);
            this.parameters.push(reportParamsModel);
        });
    }
    /**
     * @param {?} name
     * @return {?}
     */
    findParam(name) {
        this.parameters.forEach((param) => {
            return param.type === name ? param : null;
        });
        return null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ReportParametersModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id;
        this.name = obj && obj.name || null;
        if (obj && obj.definition) {
            this.definition = new ReportDefinitionModel(JSON.parse(obj.definition));
        }
        this.created = obj && obj.created || null;
    }
    /**
     * @return {?}
     */
    hasParameters() {
        return (this.definition && this.definition.parameters && this.definition.parameters.length > 0) ? true : false;
    }
}

class Chart {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id || null;
        if (obj && obj.type) {
            this.type = this.convertType(obj.type);
            this.icon = this.getIconType(this.type);
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    convertType(type) {
        let /** @type {?} */ chartType = '';
        switch (type) {
            case 'pieChart':
                chartType = 'pie';
                break;
            case 'table':
                chartType = 'table';
                break;
            case 'line':
                chartType = 'line';
                break;
            case 'barChart':
                chartType = 'bar';
                break;
            case 'multiBarChart':
                chartType = 'multiBar';
                break;
            case 'processDefinitionHeatMap':
                chartType = 'HeatMap';
                break;
            case 'masterDetailTable':
                chartType = 'masterDetailTable';
                break;
            default:
                chartType = 'table';
                break;
        }
        return chartType;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getIconType(type) {
        let /** @type {?} */ typeIcon = '';
        switch (type) {
            case 'pie':
                typeIcon = 'pie_chart';
                break;
            case 'table':
                typeIcon = 'web';
                break;
            case 'line':
                typeIcon = 'show_chart';
                break;
            case 'bar':
                typeIcon = 'equalizer';
                break;
            case 'multiBar':
                typeIcon = 'poll';
                break;
            case 'HeatMap':
                typeIcon = 'share';
                break;
            case 'masterDetailTable':
                typeIcon = 'subtitles';
                break;
            default:
                typeIcon = 'web';
                break;
        }
        return typeIcon;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BarChart extends Chart {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        super(obj);
        this.labels = [];
        this.datasets = [];
        this.data = [];
        this.options = {
            responsive: true,
            scales: {
                yAxes: [{
                        ticks: {
                            beginAtZero: true,
                            stepSize: 1
                        }
                    }],
                xAxes: [{
                        ticks: {},
                        stacked: false
                    }]
            }
        };
        this.xAxisTickFormatFunction = function (xAxisType) {
            return function (value) {
                if (xAxisType !== null && xAxisType !== undefined) {
                    if ('date_day' === xAxisType) {
                        return moment(new Date(value)).format('DD');
                    }
                    else if ('date_month' === xAxisType) {
                        return moment(new Date(value)).format('MMMM');
                    }
                    else if ('date_year' === xAxisType) {
                        return moment(new Date(value)).format('YYYY');
                    }
                }
                return value;
            };
        };
        this.yAxisTickFormatFunction = function (yAxisType) {
            return function (value) {
                if (yAxisType !== null && yAxisType !== undefined) {
                    if ('count' === yAxisType) {
                        let /** @type {?} */ label = '' + value;
                        if (label.indexOf('.') !== -1) {
                            return '';
                        }
                    }
                }
                return value;
            };
        };
        this.title = obj && obj.title || null;
        this.titleKey = obj && obj.titleKey || null;
        this.xAxisType = obj && obj.xAxisType || null;
        this.yAxisType = obj && obj.yAxisType || null;
        this.options.scales.xAxes[0].ticks.callback = this.xAxisTickFormatFunction(this.xAxisType);
        this.options.scales.yAxes[0].ticks.callback = this.yAxisTickFormatFunction(this.yAxisType);
        if (obj.values) {
            obj.values.forEach((params) => {
                let dataValue = [];
                params.values.forEach((info) => {
                    info.forEach((value, index) => {
                        if (index % 2 === 0) {
                            if (!this.labels.includes(value)) {
                                this.labels.push(value);
                            }
                        }
                        else {
                            dataValue.push(value);
                        }
                    });
                });
                if (dataValue && dataValue.length > 0) {
                    this.datasets.push({ data: dataValue, label: params.key });
                }
            });
        }
    }
    /**
     * @return {?}
     */
    hasDatasets() {
        return this.datasets && this.datasets.length > 0 ? true : false;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TableChart extends Chart {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        super(obj);
        this.labels = [];
        this.datasets = [];
        this.title = obj && obj.title || null;
        this.titleKey = obj && obj.titleKey || null;
        this.labels = obj && obj.columnNames;
        if (obj.rows) {
            this.datasets = obj && obj.rows;
        }
    }
    /**
     * @return {?}
     */
    hasDatasets() {
        return this.datasets && this.datasets.length > 0 ? true : false;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DetailsTableChart extends TableChart {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        super(obj);
        this.showDetails = false;
        if (obj.detailTables) {
            this.detailsTable = new TableChart(obj.detailTables[0]);
        }
    }
    /**
     * @return {?}
     */
    hasDetailsTable() {
        return this.detailsTable ? true : false;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HeatMapChart extends Chart {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        super(obj);
        this.avgTimePercentages = obj && obj.avgTimePercentages || null;
        this.avgTimeValues = obj && obj.avgTimeValues || null;
        this.processDefinitionId = obj && obj.processDefinitionId || null;
        this.totalCountValues = obj && obj.totalCountValues || null;
        this.titleKey = obj && obj.titleKey || null;
        this.totalCountsPercentages = obj && obj.totalCountsPercentages || null;
        this.totalTimePercentages = obj && obj.totalTimePercentages || null;
        this.totalTimeValues = obj && obj.totalTimeValues || null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiBarChart extends BarChart {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        super(obj);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PieChart extends Chart {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        super(obj);
        this.labels = [];
        this.data = [];
        this.title = obj && obj.title || null;
        this.titleKey = obj && obj.titleKey || null;
        if (obj.values) {
            obj.values.forEach((value) => {
                this.add(value.key, value.y);
            });
        }
    }
    /**
     * @param {?} label
     * @param {?} data
     * @return {?}
     */
    add(label, data) {
        this.labels.push(label);
        this.data.push(data);
    }
    /**
     * @return {?}
     */
    hasData() {
        return this.data && this.data.length > 0 ? true : false;
    }
    /**
     * @return {?}
     */
    hasZeroValues() {
        let /** @type {?} */ isZeroValues = false;
        if (this.hasData()) {
            isZeroValues = true;
            this.data.forEach((value) => {
                if (value.toString() !== '0') {
                    isZeroValues = false;
                }
            });
        }
        return isZeroValues;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnalyticsService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Retrive all the Deployed app
     * @param {?} appId
     * @return {?}
     */
    getReportList(appId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.getReportList())
            .map((res) => {
            let /** @type {?} */ reports = [];
            res.forEach((report) => {
                let /** @type {?} */ reportModel = new ReportParametersModel(report);
                if (this.isReportValid(appId, report)) {
                    reports.push(reportModel);
                }
            });
            return reports;
        }).catch(err => this.handleError(err));
    }
    /**
     * Retrive Report by name
     * @param {?} reportName - string - The name of report
     * @return {?}
     */
    getReportByName(reportName) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.getReportList())
            .map((response) => {
            return response.find(report => report.name === reportName);
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} appId
     * @param {?} report
     * @return {?}
     */
    isReportValid(appId, report) {
        let /** @type {?} */ isValid = true;
        if (appId && appId !== 0 && report.name.includes('Process definition overview')) {
            isValid = false;
        }
        return isValid;
    }
    /**
     * @param {?} reportId
     * @return {?}
     */
    getReportParams(reportId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.getReportParams(reportId))
            .map((res) => {
            return new ReportParametersModel(res);
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} type
     * @param {?} appId
     * @param {?=} reportId
     * @param {?=} processDefinitionId
     * @return {?}
     */
    getParamValuesByType(type, appId, reportId, processDefinitionId) {
        if (type === 'status') {
            return this.getProcessStatusValues();
        }
        else if (type === 'processDefinition') {
            if (appId === null || appId === undefined) {
                return this.getProcessDefinitionsValuesNoApp();
            }
            else {
                return this.getProcessDefinitionsValues(appId);
            }
        }
        else if (type === 'dateInterval') {
            return this.getDateIntervalValues();
        }
        else if (type === 'task' && reportId && processDefinitionId) {
            return this.getTasksByProcessDefinitionId(reportId, processDefinitionId);
        }
        else {
            return Observable$1.create(observer => {
                observer.next(null);
                observer.complete();
            });
        }
    }
    /**
     * @return {?}
     */
    getProcessStatusValues() {
        let /** @type {?} */ paramOptions = [];
        paramOptions.push(new ParameterValueModel({ id: 'All', name: 'All' }));
        paramOptions.push(new ParameterValueModel({ id: 'Active', name: 'Active' }));
        paramOptions.push(new ParameterValueModel({ id: 'Complete', name: 'Complete' }));
        return Observable$1.create(observer => {
            observer.next(paramOptions);
            observer.complete();
        });
    }
    /**
     * @return {?}
     */
    getDateIntervalValues() {
        let /** @type {?} */ paramOptions = [];
        paramOptions.push(new ParameterValueModel({ id: 'byHour', name: 'By hour' }));
        paramOptions.push(new ParameterValueModel({ id: 'byDay', name: 'By day' }));
        paramOptions.push(new ParameterValueModel({ id: 'byWeek', name: 'By week' }));
        paramOptions.push(new ParameterValueModel({ id: 'byMonth', name: 'By month' }));
        paramOptions.push(new ParameterValueModel({ id: 'byYear', name: 'By year' }));
        return Observable$1.create(observer => {
            observer.next(paramOptions);
            observer.complete();
        });
    }
    /**
     * @return {?}
     */
    getMetricValues() {
        let /** @type {?} */ paramOptions = [];
        paramOptions.push(new ParameterValueModel({ id: 'totalCount', name: 'Number of times a step is executed' }));
        paramOptions.push(new ParameterValueModel({ id: 'totalTime', name: 'Total time spent in a process step' }));
        paramOptions.push(new ParameterValueModel({ id: 'avgTime', name: 'Average time spent in a process step' }));
        return Observable$1.create(observer => {
            observer.next(paramOptions);
            observer.complete();
        });
    }
    /**
     * @return {?}
     */
    getProcessDefinitionsValuesNoApp() {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.getProcessDefinitions())
            .map((res) => {
            let /** @type {?} */ paramOptions = [];
            res.forEach((opt) => {
                paramOptions.push(new ParameterValueModel(opt));
            });
            return paramOptions;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} appId
     * @return {?}
     */
    getProcessDefinitionsValues(appId) {
        let /** @type {?} */ options = { 'appDefinitionId': appId };
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.processDefinitionsApi.getProcessDefinitions(options))
            .map((res) => {
            let /** @type {?} */ paramOptions = [];
            res.data.forEach((opt) => {
                paramOptions.push(new ParameterValueModel(opt));
            });
            return paramOptions;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} reportId
     * @param {?} processDefinitionId
     * @return {?}
     */
    getTasksByProcessDefinitionId(reportId, processDefinitionId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.getTasksByProcessDefinitionId(reportId, processDefinitionId))
            .map((res) => {
            let /** @type {?} */ paramOptions = [];
            res.forEach((opt) => {
                paramOptions.push(new ParameterValueModel({ id: opt, name: opt }));
            });
            return paramOptions;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} reportId
     * @param {?} paramsQuery
     * @return {?}
     */
    getReportsByParams(reportId, paramsQuery) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.getReportsByParams(reportId, paramsQuery))
            .map((res) => {
            let /** @type {?} */ elements = [];
            res.elements.forEach((chartData) => {
                if (chartData.type === 'pieChart') {
                    elements.push(new PieChart(chartData));
                }
                else if (chartData.type === 'table') {
                    elements.push(new TableChart(chartData));
                }
                else if (chartData.type === 'processDefinitionHeatMap') {
                    elements.push(new HeatMapChart(chartData));
                }
                else if (chartData.type === 'masterDetailTable') {
                    elements.push(new DetailsTableChart(chartData));
                }
                else if (chartData.type === 'barChart') {
                    elements.push(new BarChart(chartData));
                }
                else if (chartData.type === 'multiBarChart') {
                    elements.push(new MultiBarChart(chartData));
                }
            });
            return elements;
        }).catch(err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    createDefaultReports() {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.createDefaultReports())
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} reportId
     * @param {?} name
     * @return {?}
     */
    updateReport(reportId, name) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.updateReport(reportId, name))
            .map((res) => {
            this.logService.info('upload');
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} reportId
     * @param {?} paramsQuery
     * @return {?}
     */
    exportReportToCsv(reportId, paramsQuery) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.exportToCsv(reportId, paramsQuery))
            .map((res) => {
            this.logService.info('export');
            return res;
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} reportId
     * @param {?} paramsQuery
     * @return {?}
     */
    saveReport(reportId, paramsQuery) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.saveReport(reportId, paramsQuery))
            .map(() => {
            this.logService.info('save');
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} reportId
     * @return {?}
     */
    deleteReport(reportId) {
        return Observable$1.fromPromise(this.apiService.getInstance().activiti.reportApi.deleteReport(reportId))
            .map(() => {
            this.logService.info('delete');
        }).catch(err => this.handleError(err));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        return res || {};
    }
}
AnalyticsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AnalyticsService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnalyticsGeneratorComponent {
    /**
     * @param {?} analyticsService
     */
    constructor(analyticsService) {
        this.analyticsService = analyticsService;
        this.reportParamQuery = undefined;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.showDetails = false;
        this.barChartOptions = {
            responsive: true,
            scales: {
                yAxes: [{
                        ticks: {
                            beginAtZero: true,
                            stepSize: 1
                        }
                    }],
                xAxes: [{
                        ticks: {},
                        stacked: true
                    }]
            }
        };
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.reportId && this.reportParamQuery) {
            this.generateReport(this.reportId, this.reportParamQuery);
        }
        else {
            this.reset();
        }
    }
    /**
     * @param {?} reportId
     * @param {?} reportParamQuery
     * @return {?}
     */
    generateReport(reportId, reportParamQuery) {
        if (reportParamQuery === undefined || reportParamQuery === null) {
            reportParamQuery = {};
        }
        this.analyticsService.getReportsByParams(reportId, reportParamQuery).subscribe((res) => {
            this.reports = res;
            if (this.reports) {
                this.selectFirstReport();
            }
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @return {?}
     */
    reset() {
        if (this.reports) {
            this.reports = undefined;
        }
    }
    /**
     * @param {?} report
     * @return {?}
     */
    refresh(report) {
        /**
         * (My guess), for Angular to recognize the change in the dataset
         * it has to change the dataset variable directly,
         * so one way around it, is to clone the data, change it and then
         * assign it;
         */
        let clone = JSON.parse(JSON.stringify(report));
        report.datasets = clone.datasets;
    }
    /**
     * @return {?}
     */
    toggleDetailsTable() {
        this.showDetails = !this.showDetails;
    }
    /**
     * @return {?}
     */
    isShowDetails() {
        return this.showDetails;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    isCurrent(position) {
        return position === this.currentChartPosition ? true : false;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    selectCurrent(position) {
        this.currentChartPosition = position;
    }
    /**
     * @return {?}
     */
    selectFirstReport() {
        this.selectCurrent(0);
    }
}
AnalyticsGeneratorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-analytics-generator',
                template: `
      <div *ngIf="reports">
          <div class="report-icons">
              <button mat-icon-button
                      *ngFor="let report of reports; let idx = index"
                      [matTooltip]="report.title"
                      [color]="isCurrent(idx) ? 'primary' : null"
                      (click)="selectCurrent(idx)">
                  <mat-icon>{{report.icon}}</mat-icon>
              </button>
          </div>
          <div class="clear-both"> </div>
          <div *ngFor="let report of reports; let idx = index">
              <div [ngSwitch]="report.type">
                  <div *ngSwitchCase="'pie'">
                      <div *ngIf="isCurrent(idx)">
                          <h4>{{report.title}}</h4>
                          <div *ngIf="!report.hasData()">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>
                          <div *ngIf="report.hasData()">
                              <div *ngIf="report.hasZeroValues()">{{'ANALYTICS.MESSAGES.ZERO-DATA-FOUND' | translate}}</div>
                              <canvas baseChart *ngIf="!report.hasZeroValues()" class="chart"
                                      [data]="report.data"
                                      [labels]="report.labels"
                                      [chartType]="report.type">
                              </canvas>
                          </div>
                      </div>
                  </div>
                  <div *ngSwitchCase="'table'" >
                      <div *ngIf="isCurrent(idx)">
                          <h4>{{report.title}}</h4>
                          <div *ngIf="!report.hasDatasets()">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>
                          <div [attr.id]="'chart-table-' + report.id" *ngIf="report.hasDatasets()">
                              <table class="table table-responsive table-condensed" class="partial-width">
                                  <tr>
                                      <th *ngFor="let label of report.labels">{{label | translate}}</th>
                                  </tr>
                                  <tr *ngFor="let rows of report.datasets">
                                      <td *ngFor="let row of rows">{{row | translate }}</td>
                                  </tr>
                              </table>
                          </div>
                      </div>
                  </div>
                  <div *ngSwitchCase="'masterDetailTable'" >
                      <div *ngIf="isCurrent(idx)">
                          <h4>{{report.title}}</h4>
                          <div *ngIf="!report.hasDatasets()">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>
                          <div [attr.id]="'chart-master-detail-table-' + report.id" *ngIf="report.hasDatasets()">
                              <table class="table table-responsive table-condensed" class="full-width">
                                  <tr>
                                      <th *ngFor="let label of report.labels">{{label | translate}}</th>
                                  </tr>
                                  <tr *ngFor="let rows of report.datasets" class="analytics-row__entry">
                                      <td *ngFor="let row of rows" (click)="toggleDetailsTable()">{{row | translate }}</td>
                                  </tr>
                              </table>
                          </div>
                          <div [attr.id]="'chart-master-detail-' + report.id" *ngIf="isShowDetails()">
                              <table class="table table-responsive table-condensed" class="full-width">
                                  <tr>
                                      <th *ngFor="let label of report.detailsTable.labels">{{label | translate}}</th>
                                  </tr>
                                  <tr *ngFor="let rows of report.detailsTable.datasets">
                                      <td *ngFor="let row of rows">{{row | translate }}</td>
                                  </tr>
                              </table>
                          </div>
                      </div>
                  </div>
                  <div *ngSwitchCase="'bar'">
                      <div *ngIf="isCurrent(idx)">
                          <h4>{{report.title}}</h4>
                          <div *ngIf="!report.hasDatasets()">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>
                          <canvas baseChart *ngIf="report.hasDatasets()" class="chart"
                                  [datasets]="report.datasets"
                                  [labels]="report.labels"
                                  [options]="report.options"
                                  [chartType]="report.type">
                          </canvas>
                      </div>
                  </div>
                  <div *ngSwitchCase="'multiBar'">
                      <div *ngIf="isCurrent(idx)">
                          <h4>{{report.title}}</h4>
                          <div *ngIf="!report.hasDatasets()">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>
                          <div *ngIf="report.hasDatasets()">
                              <mat-checkbox
                                  color="primary"
                                  [id]="'stacked-id'"
                                  [checked]="report.options.scales.xAxes[0].stacked"
                                  [(ngModel)]="report.options.scales.xAxes[0].stacked"
                                  (change)="refresh(report)">Stacked</mat-checkbox>

                              <canvas baseChart class="chart"
                                      [datasets]="report.datasets"
                                      [labels]="report.labels"
                                      [options]="report.options"
                                      [chartType]="'bar'">
                              </canvas>
                          </div>
                      </div>
                  </div>
                  <div *ngSwitchCase="'HeatMap'">
                      <div *ngIf="isCurrent(idx)">
                          <h4>{{report.title}}</h4>
                          <analytics-report-heat-map [report]="report"></analytics-report-heat-map>
                      </div>
                  </div>
                  <div *ngSwitchDefault>
                      <span>{{'ANALYTICS.MESSAGES.UNKNOWN-WIDGET-TYPE' | translate}}: {{report.type}}</span>
                  </div>
              </div>
          </div>
      </div>
      <br><br><br>
      <div *ngIf="!reports">{{'ANALYTICS.MESSAGES.FILL-PARAMETER' | translate}}</div>
    `,
                styles: [`
      .chart {
        display: block;
        width: 100%; }

      .analytics-row__entry {
        cursor: pointer; }

      .report-icons {
        margin: 20px 0;
        float: left; }

      .full-width {
        width: 100%; }

      .partial-width {
        width: 80%;
        margin-left: 20px; }

      .clear-both {
        clear: both; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AnalyticsGeneratorComponent.ctorParameters = () => [
    { type: AnalyticsService, },
];
AnalyticsGeneratorComponent.propDecorators = {
    'reportId': [{ type: Input },],
    'reportParamQuery': [{ type: Input },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnalyticsReportHeatMapComponent {
    /**
     * @param {?} analyticsService
     * @param {?} formBuilder
     */
    constructor(analyticsService, formBuilder) {
        this.analyticsService = analyticsService;
        this.formBuilder = formBuilder;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.field = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initForm();
        this.field.id = 'metrics';
        this.field.value = 'totalCount';
        this.analyticsService.getMetricValues().subscribe((opts) => {
            this.field.options = opts;
            this.success.emit(opts);
        });
    }
    /**
     * @param {?} field
     * @return {?}
     */
    onMetricChanges(field) {
        if (field.value === 'totalCount') {
            this.currentMetric = this.report.totalCountValues;
            this.currentMetricColors = this.report.totalCountsPercentages;
            this.metricType = 'times';
        }
        else if (field.value === 'totalTime') {
            this.currentMetric = this.report.totalTimeValues;
            this.currentMetricColors = this.report.totalTimePercentages;
            this.metricType = 'hours';
        }
        else if (field.value === 'avgTime') {
            this.currentMetric = this.report.avgTimeValues;
            this.currentMetricColors = this.report.avgTimePercentages;
            this.metricType = 'hours';
        }
    }
    /**
     * @return {?}
     */
    initForm() {
        this.metricForm = this.formBuilder.group({
            metricGroup: new FormGroup({
                metric: new FormControl()
            })
        });
    }
    /**
     * @return {?}
     */
    hasMetric() {
        return (this.report.totalCountsPercentages ||
            this.report.totalTimePercentages ||
            this.report.avgTimePercentages) ? true : false;
    }
}
AnalyticsReportHeatMapComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-analytics-report-heat-map, analytics-report-heat-map',
                template: `
      <h4>Process Heat map</h4>
      <div *ngIf="hasMetric()">
          <form [formGroup]="metricForm" novalidate>
              <analytics-dropdown-widget [field]="field" [group]="metricForm.controls.metricGroup" [controllerName]="'metric'"
                               (fieldChanged)="onMetricChanges(field)" [showDefaultOption]="false"></analytics-dropdown-widget>
          </form>
          <adf-diagram *ngIf="currentMetric" [processDefinitionId]="report.processDefinitionId" [metricPercentages]="currentMetric" [metricColor]="currentMetricColors" [metricType]="metricType"></adf-diagram>
      </div>
      <div *ngIf="!hasMetric()">No metric found</div>
    `
            },] },
];
/**
 * @nocollapse
 */
AnalyticsReportHeatMapComponent.ctorParameters = () => [
    { type: AnalyticsService, },
    { type: FormBuilder, },
];
AnalyticsReportHeatMapComponent.propDecorators = {
    'report': [{ type: Input },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnalyticsReportListComponent {
    /**
     * @param {?} analyticsService
     */
    constructor(analyticsService) {
        this.analyticsService = analyticsService;
        this.layoutType = AnalyticsReportListComponent.LAYOUT_LIST;
        this.selectFirst = false;
        this.reportClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.reports = [];
        this.report$ = new Observable$1(observer => this.reportObserver = observer).share();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initObserver();
        this.getReportList(this.appId);
    }
    /**
     * @return {?}
     */
    initObserver() {
        this.report$.subscribe((report) => {
            this.reports.push(report);
        });
    }
    /**
     * Reload the component
     * @param {?=} reportId
     * @return {?}
     */
    reload(reportId) {
        this.reset();
        this.getReportList(this.appId, reportId);
    }
    /**
     * Get the report list
     * @param {?} appId
     * @param {?=} reportId
     * @return {?}
     */
    getReportList(appId, reportId) {
        this.analyticsService.getReportList(appId).subscribe((res) => {
            if (res && res.length === 0) {
                this.createDefaultReports();
            }
            else {
                res.forEach((report) => {
                    this.reportObserver.next(report);
                });
                if (reportId) {
                    this.selectReportByReportId(reportId);
                }
                if (this.selectFirst) {
                    this.selectFirstReport();
                }
                this.success.emit(res);
            }
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * Create the default reports and return the report list
     * @return {?}
     */
    createDefaultReports() {
        this.analyticsService.createDefaultReports().subscribe(() => {
            this.analyticsService.getReportList(this.appId).subscribe((response) => {
                response.forEach((report) => {
                    this.reportObserver.next(report);
                });
                this.success.emit(response);
            });
        });
    }
    /**
     * Check if the report list is empty
     * @return {?}
     */
    isReportsEmpty() {
        return this.reports === undefined || (this.reports && this.reports.length === 0);
    }
    /**
     * Reset the list
     * @return {?}
     */
    reset() {
        if (!this.isReportsEmpty()) {
            this.reports = [];
        }
    }
    /**
     * Select the current report
     * @param {?} report
     * @return {?}
     */
    selectReport(report) {
        this.currentReport = report;
        this.reportClick.emit(report);
    }
    /**
     * @param {?} reportId
     * @return {?}
     */
    selectReportByReportId(reportId) {
        let /** @type {?} */ reportFound = this.reports.find(report => report.id === reportId);
        if (reportFound) {
            this.currentReport = reportFound;
            this.reportClick.emit(reportFound);
        }
    }
    /**
     * @return {?}
     */
    selectFirstReport() {
        this.selectReport(this.reports[0]);
        this.selectFirst = false;
    }
    /**
     * @param {?} report
     * @return {?}
     */
    isSelected(report) {
        return this.currentReport === report ? true : false;
    }
    /**
     * @return {?}
     */
    isList() {
        return this.layoutType === AnalyticsReportListComponent.LAYOUT_LIST;
    }
    /**
     * @return {?}
     */
    isGrid() {
        return this.layoutType === AnalyticsReportListComponent.LAYOUT_GRID;
    }
}
AnalyticsReportListComponent.LAYOUT_LIST = 'LIST';
AnalyticsReportListComponent.LAYOUT_GRID = 'GRID';
AnalyticsReportListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-analytics-report-list, analytics-report-list',
                template: `
      <div class="adf-analytics-report-list menu-container">
          <mat-nav-list *ngIf="isList()">
              <mat-list-item
                  class="activiti-filters__entry"
                  (click)="selectReport(report)"
                  *ngFor="let report of reports; let idx = index"
                  [class.active]="currentReport === report">
                  <span [attr.id]="'report-list-' + idx" class="activiti-filters__label">
                      <mat-icon mat-list-icon
                          [attr.data-automation-id]="report.name + '_filter'"
                          class="activiti-filters__entry-icon">assignment</mat-icon>
                      <span class="text">{{report.name}}</span>
                  </span>
              </mat-list-item>
          </mat-nav-list>
          <div class="adf-report-card-grids" *ngIf="isGrid()">
              <mat-card (click)="selectReport(report)" class="adf-report-card" *ngFor="let report of reports;">
                  <div class="adf-report-card-logo logo">
                      <mat-icon class="adf-report-card-logo-icon">equalizer</mat-icon>
                  </div>
                  <div mat-card-title class="adf-report-card-title">
                      <h1 class="application-title">{{report.name}}</h1>
                  </div>
                  <div mat-card-content class="adf-report-card-content">
                      <p>{{report.description}}</p>
                  </div>
                  <div mat-card-actions class="adf-report-card-actions">
                      <mat-icon class="adf-report-card-actions-icon" *ngIf="isSelected(report)">done</mat-icon>
                  </div>
              </mat-card>
          </div>
      </div>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AnalyticsReportListComponent.ctorParameters = () => [
    { type: AnalyticsService, },
];
AnalyticsReportListComponent.propDecorators = {
    'layoutType': [{ type: Input },],
    'appId': [{ type: Input },],
    'selectFirst': [{ type: Input },],
    'reportClick': [{ type: Output },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
};

class ReportDateRange {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.startDate = obj && obj.startDate || null;
        this.endDate = obj && obj.endDate || null;
        this.rangeId = obj && obj.rangeId || null;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ReportQuery {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.reportName = obj && obj.reportName || null;
        this.processDefinitionId = obj && obj.processDefinitionId || null;
        this.status = obj && obj.status || null;
        this.taskName = obj && obj.taskName || null;
        this.dateRangeInterval = obj && obj.dateRangeInterval || null;
        this.typeFiltering = obj && (typeof obj.typeFiltering !== 'undefined') ? obj.typeFiltering : true;
        this.slowProcessInstanceInteger = obj && obj.slowProcessInstanceInteger || 0;
        this.duration = obj && obj.duration || 0;
        this.dateRange = new ReportDateRange(obj);
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnalyticsReportParametersComponent {
    /**
     * @param {?} analyticsService
     * @param {?} formBuilder
     * @param {?} logService
     * @param {?} contentService
     * @param {?} dialog
     */
    constructor(analyticsService, formBuilder, logService, contentService, dialog) {
        this.analyticsService = analyticsService;
        this.formBuilder = formBuilder;
        this.logService = logService;
        this.contentService = contentService;
        this.dialog = dialog;
        this.hideComponent = false;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.edit = new EventEmitter();
        this.formValueChanged = new EventEmitter();
        this.saveReportSuccess = new EventEmitter();
        this.deleteReportSuccess = new EventEmitter();
        this.onDropdownChanged = new EventEmitter();
        this.successReportParams = new EventEmitter();
        this.successParamOpt = new EventEmitter();
        this.isEditable = false;
        this.hideParameters = true;
        this.formValidState = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dropDownSub = this.onDropdownChanged.subscribe((field) => {
            let /** @type {?} */ paramDependOn = this.reportParameters.definition.parameters.find(p => p.dependsOn === field.id);
            if (paramDependOn) {
                this.retrieveParameterOptions(this.reportParameters.definition.parameters, this.appId, this.reportId, field.value);
            }
        });
        this.paramOpts = this.successReportParams.subscribe((report) => {
            if (report.hasParameters()) {
                this.retrieveParameterOptions(report.definition.parameters, this.appId);
                this.generateFormGroupFromParameter(report.definition.parameters);
            }
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.isEditable = false;
        if (this.reportForm) {
            this.reportForm.reset();
        }
        let /** @type {?} */ reportId = changes['reportId'];
        if (reportId && reportId.currentValue) {
            this.getReportParams(reportId.currentValue);
        }
        let /** @type {?} */ appId = changes['appId'];
        if (appId && (appId.currentValue || appId.currentValue === null)) {
            this.getReportParams(this.reportId);
        }
    }
    /**
     * @param {?} parameters
     * @return {?}
     */
    generateFormGroupFromParameter(parameters) {
        let /** @type {?} */ formBuilderGroup = {};
        parameters.forEach((param) => {
            switch (param.type) {
                case 'dateRange':
                    formBuilderGroup.dateRange = new FormGroup({}, Validators.required);
                    break;
                case 'processDefinition':
                    formBuilderGroup.processDefGroup = new FormGroup({
                        processDefinitionId: new FormControl(null, Validators.required, null)
                    }, Validators.required);
                    break;
                case 'duration':
                    formBuilderGroup.durationGroup = new FormGroup({
                        duration: new FormControl(null, Validators.required, null)
                    }, Validators.required);
                    break;
                case 'dateInterval':
                    formBuilderGroup.dateIntervalGroup = new FormGroup({
                        dateRangeInterval: new FormControl(null, Validators.required, null)
                    }, Validators.required);
                    break;
                case 'boolean':
                    formBuilderGroup.typeFilteringGroup = new FormGroup({
                        typeFiltering: new FormControl(null, Validators.required, null)
                    }, Validators.required);
                    break;
                case 'task':
                    formBuilderGroup.taskGroup = new FormGroup({
                        taskName: new FormControl(null, Validators.required, null)
                    }, Validators.required);
                    break;
                case 'integer':
                    formBuilderGroup.processInstanceGroup = new FormGroup({
                        slowProcessInstanceInteger: new FormControl(null, Validators.required, null)
                    }, Validators.required);
                    break;
                case 'status':
                    formBuilderGroup.statusGroup = new FormGroup({
                        status: new FormControl(null, Validators.required, null)
                    }, Validators.required);
                    break;
                default:
                    return;
            }
        });
        this.reportForm = this.formBuilder.group(formBuilderGroup);
        this.reportForm.valueChanges.subscribe(data => this.onValueChanged(data));
        this.reportForm.statusChanges.subscribe(data => this.onStatusChanged(data));
    }
    /**
     * @param {?} reportId
     * @return {?}
     */
    getReportParams(reportId) {
        this.reportParamsSub = this.analyticsService.getReportParams(reportId).subscribe((res) => {
            this.reportParameters = res;
            if (this.reportParameters.hasParameters()) {
                this.successReportParams.emit(res);
            }
            else {
                this.reportForm = this.formBuilder.group({});
                this.success.emit();
            }
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} parameters
     * @param {?} appId
     * @param {?=} reportId
     * @param {?=} processDefinitionId
     * @return {?}
     */
    retrieveParameterOptions(parameters, appId, reportId, processDefinitionId) {
        parameters.forEach((param) => {
            this.analyticsService.getParamValuesByType(param.type, appId, reportId, processDefinitionId).subscribe((opts) => {
                param.options = opts;
                this.successParamOpt.emit(opts);
            }, (err) => {
                this.error.emit(err);
            });
        });
    }
    /**
     * @param {?} field
     * @return {?}
     */
    onProcessDefinitionChanges(field) {
        if (field.value) {
            this.onDropdownChanged.emit(field);
        }
    }
    /**
     * @param {?} values
     * @return {?}
     */
    submit(values) {
        this.reportParamQuery = this.convertFormValuesToReportParamQuery(values);
        this.success.emit(this.reportParamQuery);
    }
    /**
     * @param {?} values
     * @return {?}
     */
    onValueChanged(values) {
        this.formValueChanged.emit(values);
        if (this.reportForm && this.reportForm.valid) {
            this.submit(values);
        }
    }
    /**
     * @param {?} status
     * @return {?}
     */
    onStatusChanged(status) {
        if (this.reportForm && !this.reportForm.pending && this.reportForm.dirty) {
            this.formValidState = this.reportForm.valid;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    convertMomentDate(date) {
        return moment(date, AnalyticsReportParametersComponent.FORMAT_DATE_ACTIVITI, true)
            .format(AnalyticsReportParametersComponent.FORMAT_DATE_ACTIVITI) + 'T00:00:00.000Z';
    }
    /**
     * @return {?}
     */
    getTodayDate() {
        return moment().format(AnalyticsReportParametersComponent.FORMAT_DATE_ACTIVITI);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    convertNumber(value) {
        return value != null ? parseInt(value, 10) : 0;
    }
    /**
     * @param {?} values
     * @return {?}
     */
    convertFormValuesToReportParamQuery(values) {
        let /** @type {?} */ reportParamQuery = new ReportQuery();
        if (values.dateRange) {
            reportParamQuery.dateRange.startDate = this.convertMomentDate(values.dateRange.startDate);
            reportParamQuery.dateRange.endDate = this.convertMomentDate(values.dateRange.endDate);
        }
        if (values.statusGroup) {
            reportParamQuery.status = values.statusGroup.status;
        }
        if (values.processDefGroup) {
            reportParamQuery.processDefinitionId = values.processDefGroup.processDefinitionId;
        }
        if (values.taskGroup) {
            reportParamQuery.taskName = values.taskGroup.taskName;
        }
        if (values.durationGroup) {
            reportParamQuery.duration = values.durationGroup.duration;
        }
        if (values.dateIntervalGroup) {
            reportParamQuery.dateRangeInterval = values.dateIntervalGroup.dateRangeInterval;
        }
        if (values.processInstanceGroup) {
            reportParamQuery.slowProcessInstanceInteger = this.convertNumber(values.processInstanceGroup.slowProcessInstanceInteger);
        }
        if (values.typeFilteringGroup) {
            reportParamQuery.typeFiltering = values.typeFilteringGroup.typeFiltering;
        }
        return reportParamQuery;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dropDownSub.unsubscribe();
        this.paramOpts.unsubscribe();
        if (this.reportParamsSub) {
            this.reportParamsSub.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    editEnable() {
        this.isEditable = true;
    }
    /**
     * @return {?}
     */
    editDisable() {
        this.isEditable = false;
    }
    /**
     * @return {?}
     */
    editTitle() {
        this.reportParamsSub = this.analyticsService.updateReport(this.reportParameters.id, this.reportParameters.name).subscribe((res) => {
            this.editDisable();
            this.edit.emit(this.reportParameters.name);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    showDialog(event) {
        this.dialog.open(this.reportNameDialog, { width: '500px' });
        this.action = event;
        this.reportName = this.reportParameters.name + ' ( ' + this.getTodayDate() + ' )';
    }
    /**
     * @return {?}
     */
    closeDialog() {
        this.dialog.closeAll();
    }
    /**
     * @param {?} action
     * @param {?} reportParamQuery
     * @return {?}
     */
    performAction(action, reportParamQuery) {
        reportParamQuery.reportName = this.reportName;
        this.closeDialog();
        if (action === 'Save') {
            this.doSave(reportParamQuery);
        }
        else if (action === 'Export') {
            this.doExport(reportParamQuery);
        }
        this.resetActions();
    }
    /**
     * @return {?}
     */
    resetActions() {
        this.action = '';
        this.reportName = '';
    }
    /**
     * @return {?}
     */
    isSaveAction() {
        return this.action === 'Save';
    }
    /**
     * @return {?}
     */
    isFormValid() {
        return this.reportForm && this.reportForm.dirty && this.reportForm.valid;
    }
    /**
     * @param {?} paramQuery
     * @return {?}
     */
    doExport(paramQuery) {
        this.analyticsService.exportReportToCsv(this.reportId, paramQuery).subscribe((data) => {
            let /** @type {?} */ blob = new Blob([data], { type: 'text/csv' });
            this.contentService.downloadBlob(blob, paramQuery.reportName + '.csv');
        });
    }
    /**
     * @param {?} paramQuery
     * @return {?}
     */
    doSave(paramQuery) {
        this.analyticsService.saveReport(this.reportId, paramQuery).subscribe(() => {
            this.saveReportSuccess.emit(this.reportId);
        });
    }
    /**
     * @param {?} reportId
     * @return {?}
     */
    deleteReport(reportId) {
        this.analyticsService.deleteReport(reportId).subscribe(() => {
            this.deleteReportSuccess.emit(reportId);
        }, error => this.logService.error(error));
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        if (this.reportForm && this.reportForm.valid) {
            this.reportForm.markAsDirty();
        }
    }
    /**
     * @return {?}
     */
    toggleParameters() {
        this.hideParameters = !this.hideParameters;
    }
    /**
     * @return {?}
     */
    isParametersHide() {
        return this.hideParameters;
    }
}
AnalyticsReportParametersComponent.FORMAT_DATE_ACTIVITI = 'YYYY-MM-DD';
AnalyticsReportParametersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-analytics-report-parameters, analytics-report-parameters',
                template: `
      <div [class.hide]="hideComponent">
          <div class="adf-report-report-container">
              <div *ngIf="reportParameters">
                  <form [formGroup]="reportForm" novalidate>
                      <adf-toolbar>
                          <adf-toolbar-title class="adf-report-title-container">
                              <div *ngIf="isEditable">
                                  <mat-form-field class="adf-full-width-input">
                                      <input
                                          matInput
                                          type="text"
                                          class="adf-edit-report-title"
                                          id="reportName"
                                          autofocus
                                          data-automation-id="reportName"
                                          [value]="reportParameters.name"
                                          (input)="reportParameters.name=$event.target.value"
                                          (blur)="editTitle($event)"
                                          (keyup.enter)="editTitle($event)"
                                      />
                                  </mat-form-field>
                              </div>
                              <div class="adf-report-title" *ngIf="!isEditable" (click)="editEnable()">
                                  <mat-icon class="adf-report-icon" >mode_edit</mat-icon>
                                  <h4>{{reportParameters.name}}</h4>
                              </div>
                          </adf-toolbar-title>
                          <div *ngIf="!isEditable">
                              <button mat-button matTooltip="{{'ANALYTICS.MESSAGES.ICON-SETTING' | translate}}"
                                      (click)="toggleParameters()">
                                  <mat-icon>settings</mat-icon>
                              </button>
                              <button mat-button id="delete-button" (click)="deleteReport(reportId)"
                                      matTooltip="{{'ANALYTICS.MESSAGES.ICON-DELETE' | translate}}">
                                  <mat-icon>delete</mat-icon>
                              </button>
                              <span *ngIf="isFormValid()">
                                  <button mat-button id="export-button" (click)="showDialog('Export')"
                                          matTooltip="{{'ANALYTICS.MESSAGES.ICON-EXPORT-CSV' | translate}}">
                                      <mat-icon>file_download</mat-icon>
                                  </button>
                                  <button mat-button id="save-button" (click)="showDialog('Save')"
                                          matTooltip="{{'ANALYTICS.MESSAGES.ICON-SAVE' | translate}}">
                                      <mat-icon>save</mat-icon>
                                  </button>
                              </span>
                          </div>
                      </adf-toolbar>
                      <div *ngFor="let field of reportParameters.definition.parameters"
                              [class.is-hide]="isParametersHide()">
                          <div [ngSwitch]="field.type">
                              <div *ngSwitchCase="'integer'">
                                  <br>
                                  <analytics-number-widget [field]="field" [group]="reportForm.controls.processInstanceGroup"
                                                  [controllerName]="'slowProcessInstanceInteger'"
                                                  [required]="true"></analytics-number-widget>
                              </div>
                              <div *ngSwitchCase="'duration'">
                                  <br>
                                  <duration-widget [field]="field" [group]="reportForm.controls.durationGroup"
                                                      [controllerName]="'duration'"></duration-widget>
                              </div>
                              <div *ngSwitchCase="'boolean'">
                                  <br>
                                  <analytics-checkbox-widget [field]="field" [group]="reportForm.controls.typeFilteringGroup"
                                                      [controllerName]="'typeFiltering'"></analytics-checkbox-widget>
                              </div>
                              <div *ngSwitchCase="'status'">
                                  <br>
                                  <analytics-dropdown-widget [field]="field" [group]="reportForm.controls.statusGroup"
                                                      [controllerName]="'status'"
                                                      [required]="true"></analytics-dropdown-widget>
                              </div>
                              <div *ngSwitchCase="'processDefinition'">
                                  <br>
                                  <analytics-dropdown-widget [field]="field" [group]="reportForm.controls.processDefGroup"
                                                      [controllerName]="'processDefinitionId'"
                                                      [required]="true"
                                                      (fieldChanged)="onProcessDefinitionChanges(field)"></analytics-dropdown-widget>
                              </div>
                              <div *ngSwitchCase="'task'">
                                  <br>
                                  <analytics-dropdown-widget [field]="field" [group]="reportForm.controls.taskGroup"
                                                      [controllerName]="'taskName'"
                                                      [required]="true"></analytics-dropdown-widget>
                              </div>
                              <div *ngSwitchCase="'dateRange'">
                                  <br>
                                  <adf-date-range-widget [field]="field"
                                                          [group]="reportForm.controls.dateRange"></adf-date-range-widget>
                              </div>
                              <div *ngSwitchCase="'dateInterval'">
                                  <br>
                                  <analytics-dropdown-widget [field]="field" [group]="reportForm.controls.dateIntervalGroup"
                                                      [controllerName]="'dateRangeInterval'"
                                                      [required]="true" [showDefaultOption]="false"></analytics-dropdown-widget>
                              </div>
                              <div *ngSwitchDefault>
                                  <span>{{'ANALYTICS.MESSAGES.UNKNOWN-WIDGET-TYPE' | translate}}: {{field.type}}</span>
                              </div>
                          </div>
                      </div>
                      <ng-template #reportNameDialog>
                          <div id="report-dialog" class="adf-report-dialog">
                              <h5 matDialogTitle id="report-dialog-title">{{action}} report</h5>
                              <div mat-dialog-content>
                                  <div *ngIf="isSaveAction()" id="save-title-submessage" class="export-message">
                                      {{'DIALOG.SAVE_MESSAGE' | translate}}
                                  </div>
                                  <div class="save-export-input">
                                      <mat-form-field class="example-full-width" floatPlaceholder="always">
                                          <input matInput
                                              type="text"
                                              id="repName"
                                              placeholder="Report Name"
                                              [value]="reportName"
                                              [(ngModel)]="reportName"
                                              [ngModelOptions]="{standalone: true}">
                                      </mat-form-field>
                                  </div>
                              </div>
                              <div mat-dialog-actions>
                                  <button mat-button
                                      color="accent"
                                      type="button"
                                      id="close-dialog-button"
                                      (click)="closeDialog()">Close</button>
                                  <button mat-button
                                      color="primary"
                                      type="button"
                                      id="action-dialog-button"
                                      (click)="performAction(action, reportParamQuery)">{{action}}</button>
                              </div>
                          </div>
                      </ng-template>
                  </form>
              </div>
          </div>
      </div>
    `,
                styles: [`
      .dropdown-widget {
        width: 100%; }

      .dropdown-widget__select {
        width: 100%; }

      .dropdown-widget__invalid .dropdown-widget__select {
        border-color: #d50000; }

      .dropdown-widget__invalid .dropdown-widget__label {
        color: #d50000; }

      .dropdown-widget__invalid .dropdown-widget__label:after {
        background-color: #d50000; }

      .adf-edit-report-title {
        float: left;
        font-size: 20px !important;
        padding-top: 19px; }

      .adf-report-icon {
        float: left;
        padding: 5px 5px 0 0;
        visibility: hidden; }

      .adf-report-title-container {
        cursor: pointer;
        width: 100%;
        margin-bottom: 12px; }
        .adf-report-title-container :hover .adf-report-icon {
          color: #448aff;
          visibility: visible; }

      .adf-report-title {
        padding-top: 10px; }

      .adf-full-width-input {
        width: 100%; }

      .is-hide {
        height: 0;
        overflow: hidden;
        -webkit-transition: height 0.5s;
        transition: height 0.5s; }

      .adf-report-report-container {
        border-bottom: solid 1px #d4d4d4;
        padding-top: 10px; }
        .adf-report-report-container .mat-toolbar {
          border: 0 !important;
          padding: 0 !important; }

      .report-container-setting {
        padding-left: 10px; }

      .option_button_details {
        padding-top: 20px; }

      .export-message {
        background-color: lightgray; }

      .save-export-input {
        width: 100%; }

      .delete-parameter {
        position: absolute;
        margin-left: 60%;
        padding-top: 5px; }

      .hide {
        display: none; }

      .adf-report-dialog .mat-form-field {
        width: 100%; }

      .adf-report-dialog .mat-dialog-actions {
        -webkit-box-pack: end;
            -ms-flex-pack: end;
                justify-content: flex-end; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AnalyticsReportParametersComponent.ctorParameters = () => [
    { type: AnalyticsService, },
    { type: FormBuilder, },
    { type: LogService, },
    { type: ContentService, },
    { type: MatDialog, },
];
AnalyticsReportParametersComponent.propDecorators = {
    'appId': [{ type: Input },],
    'reportId': [{ type: Input },],
    'hideComponent': [{ type: Input },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'edit': [{ type: Output },],
    'formValueChanged': [{ type: Output },],
    'saveReportSuccess': [{ type: Output },],
    'deleteReportSuccess': [{ type: Output },],
    'reportNameDialog': [{ type: ViewChild, args: ['reportNameDialog',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnalyticsComponent {
    constructor() {
        this.hideParameters = false;
        this.editReport = new EventEmitter();
        this.reportSaved = new EventEmitter();
        this.reportDeleted = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.analyticsgenerator.reset();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    showReport($event) {
        this.analyticsgenerator.generateReport(this.reportId, $event);
    }
    /**
     * @return {?}
     */
    reset() {
        this.analyticsgenerator.reset();
    }
    /**
     * @param {?} name
     * @return {?}
     */
    onEditReport(name) {
        this.editReport.emit(name);
    }
    /**
     * @param {?} reportId
     * @return {?}
     */
    onSaveReportSuccess(reportId) {
        this.reportSaved.emit(reportId);
    }
    /**
     * @return {?}
     */
    onDeleteReportSuccess() {
        this.reportDeleted.emit();
    }
}
AnalyticsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-analytics',
                template: `
      <div class="adf-analytics-container">
          <analytics-report-parameters [appId]="appId" [reportId]="reportId"
                                       [hideComponent]="hideParameters"
                                       (formValueChanged)="reset()"
                                       (success)="showReport($event)"
                                       (saveReportSuccess)="onSaveReportSuccess($event)"
                                       (deleteReportSuccess)="onDeleteReportSuccess()"
                                       (edit)="onEditReport($event)">
          </analytics-report-parameters>

          <adf-analytics-generator [reportId]="reportId"
                                        [reportParamQuery]="reportParamQuery"
                                        #analyticsgenerator>
          </adf-analytics-generator>
      </div>
    `,
                styles: [`
      .chart {
        display: block;
        width: 100%; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
AnalyticsComponent.ctorParameters = () => [];
AnalyticsComponent.propDecorators = {
    'appId': [{ type: Input },],
    'reportId': [{ type: Input },],
    'hideParameters': [{ type: Input },],
    'editReport': [{ type: Output },],
    'reportSaved': [{ type: Output },],
    'reportDeleted': [{ type: Output },],
    'analyticsgenerator': [{ type: ViewChild, args: ['analyticsgenerator',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WidgetComponent {
    constructor() {
        this.fieldChanged = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ field = changes['field'];
        if (field && field.currentValue) {
            this.fieldChanged.emit(field.currentValue.value);
            return;
        }
    }
    /**
     * @return {?}
     */
    hasField() {
        return this.field ? true : false;
    }
    /**
     * @return {?}
     */
    hasValue() {
        return this.field &&
            this.field.value !== null &&
            this.field.value !== undefined;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    changeValue(field) {
        this.fieldChanged.emit(field);
    }
}
WidgetComponent.propDecorators = {
    'field': [{ type: Input },],
    'fieldChanged': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
/* tslint:disable:no-access-missing-member */
class CheckboxWidgetAanalyticsComponent extends WidgetComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        super();
        this.elementRef = elementRef;
    }
}
CheckboxWidgetAanalyticsComponent.decorators = [
    { type: Component, args: [{
                selector: 'analytics-checkbox-widget',
                template: `
      <div [formGroup]="formGroup">
              <mat-checkbox
              color="primary"
              formControlName="{{controllerName}}"
              [id]="field.id"
              [checked]="field.value"
              [(ngModel)]="field.value"
              (ngModelChange)="changeValue(field)">{{field.nameKey | translate}}</mat-checkbox>
      </div>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
CheckboxWidgetAanalyticsComponent.ctorParameters = () => [
    { type: ElementRef, },
];
CheckboxWidgetAanalyticsComponent.propDecorators = {
    'field': [{ type: Input },],
    'formGroup': [{ type: Input, args: ['group',] },],
    'controllerName': [{ type: Input, args: ['controllerName',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DateRangeWidgetComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} preferences
     */
    constructor(dateAdapter, preferences) {
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.FORMAT_DATE_ACTIVITI = 'YYYY-MM-DD';
        this.SHOW_FORMAT = 'DD/MM/YYYY';
        this.dateRangeChanged = new EventEmitter();
        this.startDatePicker = moment();
        this.endDatePicker = moment();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        let /** @type {?} */ momentDateAdapter = (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.SHOW_FORMAT;
        if (this.field) {
            if (this.field.value && this.field.value.startDate) {
                this.startDatePicker = moment(this.field.value.startDate, this.FORMAT_DATE_ACTIVITI);
            }
            if (this.field.value && this.field.value.endDate) {
                this.endDatePicker = moment(this.field.value.endDate, this.FORMAT_DATE_ACTIVITI);
            }
        }
        let /** @type {?} */ startDateControl = new FormControl(this.startDatePicker);
        startDateControl.setValidators(Validators.required);
        this.dateRange.addControl('startDate', startDateControl);
        let /** @type {?} */ endDateControl = new FormControl(this.endDatePicker);
        endDateControl.setValidators(Validators.required);
        this.dateRange.addControl('endDate', endDateControl);
        this.dateRange.setValidators(this.dateCheck);
        this.dateRange.valueChanges.subscribe(() => this.onGroupValueChanged());
    }
    /**
     * @return {?}
     */
    onGroupValueChanged() {
        if (this.dateRange.valid) {
            let /** @type {?} */ dateStart = this.convertToMomentDateWithTime(this.dateRange.controls.startDate.value);
            let /** @type {?} */ endStart = this.convertToMomentDateWithTime(this.dateRange.controls.endDate.value);
            this.dateRangeChanged.emit({ startDate: dateStart, endDate: endStart });
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    convertToMomentDateWithTime(date) {
        return moment(date, this.FORMAT_DATE_ACTIVITI, true).format(this.FORMAT_DATE_ACTIVITI) + 'T00:00:00.000Z';
    }
    /**
     * @param {?} formControl
     * @return {?}
     */
    dateCheck(formControl) {
        let /** @type {?} */ startDate = moment(formControl.get('startDate').value);
        let /** @type {?} */ endDate = moment(formControl.get('endDate').value);
        let /** @type {?} */ result = startDate.isAfter(endDate);
        return result ? { 'greaterThan': true } : null;
    }
    /**
     * @return {?}
     */
    isStartDateGreaterThanEndDate() {
        return this.dateRange && this.dateRange.errors && this.dateRange.errors.greaterThan;
    }
    /**
     * @return {?}
     */
    isStartDateEmpty() {
        return this.dateRange && this.dateRange.controls.startDate && !this.dateRange.controls.startDate.valid;
    }
}
DateRangeWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-range-widget',
                template: `
      <label>{{field.nameKey | translate}}</label><br>
      <div [formGroup]="dateRange">
          <small *ngIf="isStartDateGreaterThanEndDate()" class="adf-date-range-analytics-text-danger">
             {{'DATE-WIDGET.MESSAGES.START-LESS-THAN-END-DATE' | translate}}
          </small>
          <small *ngIf="isStartDateEmpty()" class="adf-date-range-analytics-text-danger">
             {{'DATE-WIDGET.MESSAGES.START-DATE-REQUIRED' | translate}}
          </small>

                  <mat-grid-list cols="2" rowHeight="80px">
                      <mat-grid-tile>
                          <mat-form-field>
                              <input
                                  matInput
                                  [min]="minDate"
                                  [max]="maxDate"
                                  formControlName="startDate"
                                  [matDatepicker]="startDate"
                                  [value]="startDatePicker"
                                  (keydown)="true"
                                  (dateChange)="onGroupValueChanged()"
                                  placeholder="{{'DATE-WIDGET.START-DATE' | translate}}"
                                  id="startDate_id"
                                  required>
                              <mat-datepicker-toggle matSuffix [for]="startDate" ></mat-datepicker-toggle>
                          </mat-form-field>
                          <mat-datepicker
                              #startDate
                              [touchUi]="true">
                          </mat-datepicker>
                      </mat-grid-tile>
                      <mat-grid-tile>
                          <mat-form-field>
                              <input
                                  matInput
                                  [min]="minDate"
                                  [max]="maxDate"
                                  formControlName="endDate"
                                  [matDatepicker]="endDate"
                                  [value]="endDatePicker"
                                  (keydown)="true"
                                  (dateChange)="onGroupValueChanged()"
                                  placeholder="{{'DATE-WIDGET.END-DATE' | translate}}"
                                  id="endDate_id"
                                  required>
                              <mat-datepicker-toggle matSuffix [for]="endDate" ></mat-datepicker-toggle>
                          </mat-form-field>
                          <mat-datepicker
                              #endDate
                              [touchUi]="true">
                          </mat-datepicker>
                      </mat-grid-tile>
                  </mat-grid-list>
      </div>
    `,
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: MOMENT_DATE_FORMATS }
                ],
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DateRangeWidgetComponent.ctorParameters = () => [
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];
DateRangeWidgetComponent.propDecorators = {
    'dateRange': [{ type: Input, args: ['group',] },],
    'field': [{ type: Input },],
    'dateRangeChanged': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
/* tslint:disable::no-access-missing-member */
class DropdownWidgetAanalyticsComponent extends WidgetComponent {
    constructor() {
        super();
        this.fieldChanged = new EventEmitter();
        this.showDefaultOption = true;
        this.required = false;
        this.defaultOptionText = 'Choose One';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.required) {
            this.formGroup.get(this.controllerName).setValidators(Validators.compose(this.buildValidatorList()));
        }
    }
    /**
     * @param {?} controller
     * @return {?}
     */
    validateDropDown(controller) {
        return controller.value !== 'null' ? null : { controllerName: false };
    }
    /**
     * @return {?}
     */
    buildValidatorList() {
        let /** @type {?} */ validatorList = [];
        validatorList.push(Validators.required);
        if (this.showDefaultOption) {
            validatorList.push(this.validateDropDown);
        }
        return validatorList;
    }
}
DropdownWidgetAanalyticsComponent.decorators = [
    { type: Component, args: [{
                selector: 'analytics-dropdown-widget',
                template: `
      <div class="adf-dropdown-widget" [formGroup]="formGroup">
          <label class="adf-dropdown-widget__label" [attr.for]="field.id">{{field.nameKey | translate}}</label>
          <select [formControlName]="controllerName"
                  [attr.id]="'select-' + field.id"
                  class="adf-dropdown-widget__select"
                  [(ngModel)]="field.value"
                  (ngModelChange)="changeValue($event)">
              <option *ngIf="showDefaultOption" value="null">{{defaultOptionText}}</option>
              <option *ngFor="let opt of field.options" [value]="opt.id">{{opt.label}}</option>
          </select>
      </div>
    `,
                styles: [`
      .adf-dropdown-widget {
        width: 100%; }

      .adf-dropdown-widget__select {
        width: 100%; }

      .adf-dropdown-widget__invalid .adf-dropdown-widget__select {
        border-color: #d50000; }

      .adf-dropdown-widget__invalid .adf-dropdown-widget__label {
        color: #d50000; }

      .adf-dropdown-widget__invalid .adf-dropdown-widget__label:after {
        background-color: #d50000; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DropdownWidgetAanalyticsComponent.ctorParameters = () => [];
DropdownWidgetAanalyticsComponent.propDecorators = {
    'field': [{ type: Input },],
    'formGroup': [{ type: Input, args: ['group',] },],
    'controllerName': [{ type: Input, args: ['controllerName',] },],
    'fieldChanged': [{ type: Output },],
    'showDefaultOption': [{ type: Input },],
    'required': [{ type: Input },],
    'defaultOptionText': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
/* tslint:disable::no-access-missing-member */
class NumberWidgetAanlyticsComponent extends WidgetComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        super();
        this.elementRef = elementRef;
        this.required = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.required) {
            this.formGroup.get(this.controllerName).setValidators(Validators.required);
        }
    }
}
NumberWidgetAanlyticsComponent.decorators = [
    { type: Component, args: [{
                selector: 'analytics-number-widget',
                template: `
      <div class="adf-number-widget" [formGroup]="formGroup">
          <mat-form-field class="example-full-width" floatPlaceholder="always">
              <input matInput
                  placeholder="{{field.nameKey | translate}}"
                  formControlName="{{controllerName}}"
                  type="text"
                  pattern="-?[0-9]*(\\.[0-9]+)?"
                  [id]="field.id"
                  [value]="field.value"
                  [(ngModel)]="field.value"
                  (ngModelChange)="changeValue(field)">
          </mat-form-field>
      </div>
    `,
                styles: [`
      .adf-number-widget {
        width: 100%; }
        .adf-number-widget .mat-form-field {
          width: 100%; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
NumberWidgetAanlyticsComponent.ctorParameters = () => [
    { type: ElementRef, },
];
NumberWidgetAanlyticsComponent.propDecorators = {
    'field': [{ type: Input },],
    'formGroup': [{ type: Input, args: ['group',] },],
    'controllerName': [{ type: Input, args: ['controllerName',] },],
    'required': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
/* tslint:disable::no-access-missing-member */
class DurationWidgetComponent extends NumberWidgetAanlyticsComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        super(elementRef);
        this.elementRef = elementRef;
        this.required = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ timeType = new FormControl();
        this.formGroup.addControl('timeType', timeType);
        if (this.required) {
            this.formGroup.get(this.controllerName).setValidators(Validators.required);
        }
        if (this.field.value === null) {
            this.field.value = 0;
        }
        let /** @type {?} */ paramOptions = [];
        paramOptions.push(new ParameterValueModel({ id: '1', name: 'Seconds' }));
        paramOptions.push(new ParameterValueModel({ id: '60', name: 'Minutes' }));
        paramOptions.push(new ParameterValueModel({ id: '3600', name: 'Hours' }));
        paramOptions.push(new ParameterValueModel({ id: '86400', name: 'Days', selected: true }));
        this.duration = new ReportParameterDetailsModel({ id: 'duration', name: 'duration', options: paramOptions });
        this.duration.value = paramOptions[0].id;
    }
    /**
     * @return {?}
     */
    calculateDuration() {
        if (this.field && this.duration.value) {
            this.currentValue = parseInt(this.field.value, 10) * parseInt(this.duration.value, 10);
            this.formGroup.get(this.controllerName).setValue(this.currentValue);
            this.fieldChanged.emit({ value: this.currentValue });
        }
    }
}
DurationWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'duration-widget',
                template: `
      <div class="adf-duration-widget-grid">
          <div class="adf-duration-widget-cell">
              <div class="adf-number-widget">
                  <mat-form-field class="example-full-width" floatPlaceholder="always">
                      <input matInput
                          placeholder="{{field.nameKey | translate}}"
                          type="text"
                          pattern="-?[0-9]*(\\.[0-9]+)?"
                          [id]="field.id"
                          [value]="field.value"
                          [(ngModel)]="field.value"
                          (ngModelChange)="calculateDuration()">
                   </mat-form-field>
              </div>
          </div>
          <div class="adf-duration-widget-cell">
              <div class="dropdown-container">
                  <analytics-dropdown-widget  [field]="duration" [group]="formGroup" [controllerName]="'timeType'"
                                   [showDefaultOption]="false"
                                   (fieldChanged)="calculateDuration()"></analytics-dropdown-widget>
              </div>
          </div>
      </div>
    `,
                styles: [`
      .adf-duration-widget-grid {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-pack: justify;
            -ms-flex-pack: justify;
                justify-content: space-between; }

      .adf-duration-widget-cell {
        width: 49%; }

      .adf-number-widget {
        width: 100%; }
        .adf-number-widget .mat-form-field {
          width: 100%; }

      .dropdown-container {
        margin-top: 30px; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DurationWidgetComponent.ctorParameters = () => [
    { type: ElementRef, },
];
DurationWidgetComponent.propDecorators = {
    'field': [{ type: Input },],
    'formGroup': [{ type: Input, args: ['group',] },],
    'controllerName': [{ type: Input, args: ['controllerName',] },],
    'required': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AnalyticsProcessModule {
}
AnalyticsProcessModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    ChartsModule,
                    DiagramsModule,
                    MaterialModule,
                    TranslateModule,
                    ToolbarModule
                ],
                declarations: [
                    AnalyticsComponent,
                    AnalyticsReportListComponent,
                    AnalyticsReportParametersComponent,
                    AnalyticsGeneratorComponent,
                    AnalyticsReportHeatMapComponent,
                    DropdownWidgetAanalyticsComponent,
                    NumberWidgetAanlyticsComponent,
                    DurationWidgetComponent,
                    CheckboxWidgetAanalyticsComponent,
                    DateRangeWidgetComponent
                ],
                providers: [
                    AnalyticsService
                ],
                exports: [
                    AnalyticsComponent,
                    AnalyticsReportListComponent,
                    AnalyticsReportParametersComponent,
                    AnalyticsGeneratorComponent,
                    AnalyticsReportHeatMapComponent,
                    DropdownWidgetAanalyticsComponent,
                    NumberWidgetAanlyticsComponent,
                    DurationWidgetComponent,
                    CheckboxWidgetAanalyticsComponent,
                    DateRangeWidgetComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
AnalyticsProcessModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InsightsModule {
}
InsightsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    BrowserAnimationsModule,
                    MaterialModule,
                    DiagramsModule,
                    AnalyticsProcessModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: {
                            name: 'adf-insights',
                            source: 'assets/adf-insights'
                        }
                    }
                ],
                exports: [
                    CoreModule,
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    BrowserAnimationsModule,
                    MaterialModule,
                    DiagramsModule,
                    AnalyticsProcessModule
                ]
            },] },
];
/**
 * @nocollapse
 */
InsightsModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { InsightsModule, AnalyticsProcessModule, AnalyticsComponent, AnalyticsGeneratorComponent, AnalyticsReportListComponent, AnalyticsReportParametersComponent, AnalyticsService, AnalyticsGeneratorComponent as ɵdm, AnalyticsReportHeatMapComponent as ɵdn, AnalyticsReportListComponent as ɵdj, AnalyticsReportParametersComponent as ɵdl, AnalyticsComponent as ɵdi, CheckboxWidgetAanalyticsComponent as ɵds, DateRangeWidgetComponent as ɵdt, DropdownWidgetAanalyticsComponent as ɵdo, DurationWidgetComponent as ɵdr, NumberWidgetAanlyticsComponent as ɵdq, WidgetComponent as ɵdp, AnalyticsService as ɵdk, DiagramAlfrescoPublishTaskComponent as ɵs, DiagramBoxPublishTaskComponent as ɵv, DiagramBusinessRuleTaskComponent as ɵy, DiagramCamelTaskComponent as ɵq, DiagramContainerServiceTaskComponent as ɵk, DiagramGoogleDrivePublishTaskComponent as ɵu, DiagramManualTaskComponent as ɵp, DiagramMuleTaskComponent as ɵr, DiagramReceiveTaskComponent as ɵw, DiagramRestCallTaskComponent as ɵt, DiagramScriptTaskComponent as ɵx, DiagramSendTaskComponent as ɵn, DiagramServiceTaskComponent as ɵm, DiagramTaskComponent as ɵl, DiagramUserTaskComponent as ɵo, DiagramBoundaryEventComponent as ɵbx, DiagramThrowEventComponent as ɵby, DiagramSequenceFlowComponent as ɵz, DiagramComponent as ɵd, DiagramEndEventComponent as ɵj, DiagramEventComponent as ɵh, DiagramStartEventComponent as ɵi, DiagramEventGatewayComponent as ɵbe, DiagramExclusiveGatewayComponent as ɵbb, DiagramGatewayComponent as ɵba, DiagramInclusiveGatewayComponent as ɵbc, DiagramParallelGatewayComponent as ɵbd, DiagramContainerIconEventTaskComponent as ɵbs, DiagramIconAlfrescoPublishTaskComponent as ɵbl, DiagramIconBoxPublishTaskComponent as ɵbo, DiagramIconBusinessRuleTaskComponent as ɵbr, DiagramIconCamelTaskComponent as ɵbj, DiagramIconErrorComponent as ɵbu, DiagramIconGoogleDrivePublishTaskComponent as ɵbn, DiagramIconManualTaskComponent as ɵbi, DiagramIconMessageComponent as ɵbw, DiagramIconMuleTaskComponent as ɵbk, DiagramIconReceiveTaskComponent as ɵbp, DiagramIconRestCallTaskComponent as ɵbm, DiagramIconScriptTaskComponent as ɵbq, DiagramIconSendTaskComponent as ɵbg, DiagramIconServiceTaskComponent as ɵbf, DiagramIconSignalComponent as ɵbv, DiagramIconTimerComponent as ɵbt, DiagramIconUserTaskComponent as ɵbh, DiagramIntermediateCatchingEventComponent as ɵbz, RaphaelIconAlfrescoPublishDirective as ɵcx, RaphaelIconBoxPublishDirective as ɵda, RaphaelIconBusinessRuleDirective as ɵdd, RaphaelIconCamelDirective as ɵcv, RaphaelIconErrorDirective as ɵdf, RaphaelIconGoogleDrivePublishDirective as ɵcz, RaphaelIconManualDirective as ɵcu, RaphaelIconMessageDirective as ɵdh, RaphaelIconMuleDirective as ɵcw, RaphaelIconReceiveDirective as ɵdb, RaphaelIconRestCallDirective as ɵcy, RaphaelIconScriptDirective as ɵdc, RaphaelIconSendDirective as ɵcs, RaphaelIconServiceDirective as ɵcr, RaphaelIconSignalDirective as ɵdg, RaphaelIconTimerDirective as ɵde, RaphaelIconUserDirective as ɵct, RaphaelBase as ɵci, RaphaelCircleDirective as ɵch, RaphaelCrossDirective as ɵcn, RaphaelFlowArrowDirective as ɵcm, RaphaelMultilineTextDirective as ɵcl, RaphaelPentagonDirective as ɵcq, RaphaelPlusDirective as ɵco, RaphaelRectDirective as ɵcj, RaphaelRhombusDirective as ɵcp, RaphaelTextDirective as ɵck, RaphaelService as ɵf, DiagramEventSubprocessComponent as ɵcb, DiagramSubprocessComponent as ɵca, DiagramLaneComponent as ɵcf, DiagramLanesComponent as ɵce, DiagramPoolComponent as ɵcd, DiagramPoolsComponent as ɵcc, DiagramTooltipComponent as ɵcg, DiagramsModule as ɵc, DiagramColorService as ɵe, DiagramsService as ɵg, MaterialModule as ɵb, modules as ɵa };
//# sourceMappingURL=adf-insights.js.map
