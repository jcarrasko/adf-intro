import { CommonModule, DatePipe } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, HostListener, Inject, Injectable, Input, NgModule, NgZone, Optional, Output, TemplateRef, ViewChild, ViewChildren, ViewEncapsulation, forwardRef } from '@angular/core';
import { FormBuilder, FormControl, FormsModule, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validators } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { AlfrescoApiService, AppConfigService, AuthenticationService, BaseEvent, CardViewDateItemModel, CardViewModule, CardViewTextItemModel, CardViewUpdateService, ContentService, CoreModule, DataColumnListComponent, DataSorting, DataTableComponent, DataTableModule, DirectiveModule, EXTENDIBLE_COMPONENT, FileModel, FileSizePipe, FileUploadStatus, FileUtils, HighlightDirective, LogService, NodesApiService, NotificationService, ObjectDataColumn, ObjectDataTableAdapter, ObjectUtils, PaginationModule, PipeModule, SearchService, SiteModel, SitesService, TRANSLATION_PROVIDER, ThumbnailService, TimeAgoPipe, ToolbarModule, TranslationService, UploadService, UserPreferencesService } from '@alfresco/adf-core';
import { MAT_DIALOG_DATA, MatButtonModule, MatCardModule, MatChipsModule, MatDialog, MatDialogModule, MatDialogRef, MatIconModule, MatInputModule, MatListItem, MatListModule, MatMenuModule, MatOptionModule, MatProgressBarModule, MatProgressSpinnerModule, MatRippleModule, MatSelect, MatSelectModule } from '@angular/material';
import { Observable as Observable$1 } from 'rxjs/Observable';
import 'rxjs/add/observable/throw';
import { TranslateModule } from '@ngx-translate/core';
import { FlexLayoutModule } from '@angular/flex-layout';
import 'rxjs/add/observable/merge';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { DOCUMENT } from '@angular/platform-browser';
import { fromEvent as fromEvent$1 } from 'rxjs/observable/fromEvent';
import { merge as merge$2 } from 'rxjs/observable/merge';
import { animate, state, style, transition, trigger } from '@angular/animations';

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatButtonModule,
        MatChipsModule,
        MatDialogModule,
        MatIconModule,
        MatCardModule,
        MatInputModule,
        MatListModule,
        MatProgressSpinnerModule,
        MatProgressBarModule,
        MatRippleModule,
        MatMenuModule,
        MatOptionModule,
        MatSelectModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] },
];
/**
 * @nocollapse
 */
MaterialModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RatingService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * @param {?} nodeId
     * @param {?} ratingType
     * @return {?}
     */
    getRating(nodeId, ratingType) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.ratingsApi.getRating(nodeId, ratingType))
            .map(res => res)
            .catch(this.handleError);
    }
    /**
     * @param {?} nodeId
     * @param {?} ratingType
     * @param {?} vote
     * @return {?}
     */
    postRating(nodeId, ratingType, vote) {
        let /** @type {?} */ ratingBody = {
            'id': ratingType,
            'myRating': vote
        };
        return Observable$1.fromPromise(this.apiService.getInstance().core.ratingsApi.rate(nodeId, ratingBody))
            .map(res => res)
            .catch(this.handleError);
    }
    /**
     * @param {?} nodeId
     * @param {?} ratingType
     * @return {?}
     */
    deleteRating(nodeId, ratingType) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.ratingsApi.removeRating(nodeId, ratingType))
            .map(res => res)
            .catch(this.handleError);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
RatingService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
RatingService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LikeComponent {
    /**
     * @param {?} ratingService
     */
    constructor(ratingService) {
        this.ratingService = ratingService;
        this.changeVote = new EventEmitter();
        this.likesCounter = 0;
        this.ratingType = 'likes';
        this.isLike = false;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.clean();
        this.ratingService.getRating(this.nodeId, this.ratingType).subscribe((data) => {
            if (data.entry.aggregate) {
                this.likesCounter = data.entry.aggregate.numberOfRatings;
                if (data.entry.ratedAt) {
                    this.isLike = true;
                }
            }
        });
    }
    /**
     * @return {?}
     */
    likeClick() {
        if (this.isLike) {
            this.ratingService.deleteRating(this.nodeId, this.ratingType).subscribe(() => {
                this.likesCounter -= 1;
                this.isLike = false;
                this.changeVote.emit(this.likesCounter);
            });
        }
        else {
            this.ratingService.postRating(this.nodeId, this.ratingType, true).subscribe((data) => {
                this.likesCounter = data.entry.aggregate.numberOfRatings;
                this.isLike = true;
                this.changeVote.emit(this.likesCounter);
            });
        }
    }
    /**
     * @return {?}
     */
    clean() {
        this.isLike = false;
        this.likesCounter = 0;
    }
}
LikeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-like',
                styles: [`
      .adf-like-container {
        overflow: hidden;
        width: 100%; }
        .adf-like-container .adf-like {
          padding: 5px;
          cursor: pointer;
          float: left;
          margin: 5px 0px 5px 5px; }
        .adf-like-container .adf-like-select {
          cursor: pointer;
          color: #2196f3; }
        .adf-like-container .adf-like-select:hover {
          cursor: pointer;
          color: #808080; }
        .adf-like-container .adf-like-grey {
          cursor: pointer;
          color: #808080; }
        .adf-like-container .adf-like-grey:hover {
          cursor: pointer;
          color: #2196f3; }
        .adf-like-container .adf-like-counter {
          float: left;
          padding: 13px 0 0 0; }
        .adf-like-container .adf-left {
          float: left;
          padding: 13px 0 0 4px; }
    `],
                template: `
      <div id="adf-like-container" class="adf-like-container">
          <div class="adf-like">
              <span id="adf-like-{{nodeId}}" [ngClass]="{'adf-like-select': isLike ,'adf-like-grey': !isLike  }"
                    (click)="likeClick()">
                  <mat-icon>thumb_up</mat-icon>
              </span>
          </div>
          <div id="adf-like-counter" class="adf-like-counter">{{likesCounter}}</div>
          <div class="adf-left" *ngIf="likesCounter<=1">Like</div>
          <div class="adf-left" *ngIf="likesCounter>1">Likes</div>
      </div>
    `,
                providers: [RatingService],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
LikeComponent.ctorParameters = () => [
    { type: RatingService, },
];
LikeComponent.propDecorators = {
    'nodeId': [{ type: Input },],
    'changeVote': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RatingComponent {
    /**
     * @param {?} ratingService
     */
    constructor(ratingService) {
        this.ratingService = ratingService;
        this.average = 0;
        this.ratingType = 'fiveStar';
        this.changeVote = new EventEmitter();
        this.stars = [];
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        let /** @type {?} */ ratingObserver = this.ratingService.getRating(this.nodeId, this.ratingType);
        ratingObserver.subscribe((data) => {
            if (data.entry.aggregate) {
                this.average = data.entry.aggregate.average;
                this.calculateStars();
            }
        });
        return ratingObserver;
    }
    /**
     * @return {?}
     */
    calculateStars() {
        this.stars = [];
        for (let /** @type {?} */ i = 0; i < 5; i++) {
            if (i < this.average) {
                this.stars.push({ fill: true });
            }
            else {
                this.stars.push({ fill: false });
            }
        }
        this.changeVote.emit(this.average);
    }
    /**
     * @param {?} vote
     * @return {?}
     */
    updateVote(vote) {
        this.ratingService.postRating(this.nodeId, this.ratingType, vote).subscribe((data) => {
            if (data.entry.aggregate) {
                if (this.average !== data.entry.aggregate.average) {
                    this.average = data.entry.aggregate.average;
                    this.calculateStars();
                }
            }
        });
    }
}
RatingComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-rating',
                styles: [`
      .adf-rating-container {
        overflow: hidden;
        width: 100%; }
        .adf-rating-container .adf-rating-star {
          float: left;
          -webkit-transition: all .3s;
          transition: all .3s;
          padding: 1px;
          cursor: pointer; }
          .adf-rating-container .adf-rating-star .mat-list-item-content {
            padding: 0 2px !important; }
        .adf-rating-container .adf-colored-star {
          color: #ffe944; }
        .adf-rating-container .adf-grey-star {
          color: #808080; }
        .adf-rating-container .adf-stars-container {
          padding: 0 !important;
          margin: 0 !important;
          display: inline-block; }
        .adf-rating-container .adf-rating-star:hover {
          -webkit-transform: rotate(13deg) scale(1.2);
                  transform: rotate(13deg) scale(1.2); }
    `],
                template: `
      <mat-list id="adf-rating-container" class="adf-rating-container">
          <mat-list-item class="adf-rating-star" *ngFor="let currentRate of stars; let idx = index">
                  <span id="adf-rate-{{idx}}">
                      <mat-icon id="adf-grey-star-{{idx}}" *ngIf="currentRate.fill" class="adf-colored-star"
                               (click)="updateVote(idx + 1)">star_rate
                      </mat-icon>
                      <mat-icon id="adf-colored-star-{{idx}}" *ngIf="!currentRate.fill" class="adf-grey-star"
                               (click)="updateVote(idx + 1)">star_border
                      </mat-icon>
                  </span>
          </mat-list-item>
      </mat-list>
    `,
                providers: [RatingService],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
RatingComponent.ctorParameters = () => [
    { type: RatingService, },
];
RatingComponent.propDecorators = {
    'nodeId': [{ type: Input },],
    'changeVote': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SocialModule {
}
SocialModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                exports: [
                    RatingComponent,
                    LikeComponent
                ],
                declarations: [
                    RatingComponent,
                    LikeComponent
                ],
                providers: [
                    RatingService
                ]
            },] },
];
/**
 * @nocollapse
 */
SocialModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TagService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.refresh = new EventEmitter();
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    getTagsByNodeId(nodeId) {
        return Observable$1.fromPromise(this.apiService.getInstance().core.tagsApi.getNodeTags(nodeId))
            .catch(err => this.handleError(err));
    }
    /**
     * @return {?}
     */
    getAllTheTags() {
        return Observable$1.fromPromise(this.apiService.getInstance().core.tagsApi.getTags())
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} nodeId
     * @param {?} tagName
     * @return {?}
     */
    addTag(nodeId, tagName) {
        let /** @type {?} */ alfrescoApi = this.apiService.getInstance();
        let /** @type {?} */ tagBody = new alfrescoApi.core.TagBody();
        tagBody.tag = tagName;
        let /** @type {?} */ promiseAdd = Observable$1.fromPromise(this.apiService.getInstance().core.tagsApi.addTag(nodeId, tagBody));
        promiseAdd.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseAdd;
    }
    /**
     * @param {?} nodeId
     * @param {?} tag
     * @return {?}
     */
    removeTag(nodeId, tag) {
        let /** @type {?} */ promiseRemove = Observable$1.fromPromise(this.apiService.getInstance().core.tagsApi.removeTag(nodeId, tag));
        promiseRemove.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseRemove;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
TagService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
TagService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];
TagService.propDecorators = {
    'refresh': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * This component, provide a list of the tags relative a node with actions button to add or remove new tag
 *
 */
class TagActionsComponent {
    /**
     * @param {?} tagService
     * @param {?} translateService
     */
    constructor(tagService, translateService) {
        this.tagService = tagService;
        this.translateService = translateService;
        this.successAdd = new EventEmitter();
        this.error = new EventEmitter();
        this.result = new EventEmitter();
        this.disableAddTag = true;
        this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        });
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        return this.refreshTag();
    }
    /**
     * @return {?}
     */
    refreshTag() {
        this.tagService.getTagsByNodeId(this.nodeId).subscribe((data) => {
            this.tagsEntries = data.list.entries;
            this.disableAddTag = false;
            this.result.emit(this.tagsEntries);
        }, () => {
            this.tagsEntries = null;
            this.disableAddTag = true;
            this.result.emit(this.tagsEntries);
        });
    }
    /**
     * @return {?}
     */
    addTag() {
        if (this.searchTag(this.newTagName)) {
            this.translateService.get('TAG.MESSAGES.EXIST').subscribe((error) => {
                this.errorMsg = error;
            });
            this.error.emit(this.errorMsg);
        }
        else {
            this.tagService.addTag(this.nodeId, this.newTagName).subscribe(() => {
                this.newTagName = '';
                this.successAdd.emit(this.nodeId);
            });
        }
    }
    /**
     * @param {?} searchTagName
     * @return {?}
     */
    searchTag(searchTagName) {
        if (this.tagsEntries) {
            return this.tagsEntries.find((currentTag) => {
                return (searchTagName === currentTag.entry.tag);
            });
        }
    }
    /**
     * @return {?}
     */
    cleanErrorMsg() {
        this.errorMsg = '';
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag);
    }
}
TagActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-actions-list',
                template: `
      <mat-list>
          <mat-list-item *ngFor="let currentEntry of tagsEntries; let idx = index">
              <div class="adf-tag-actions-container" id="tag_delete_{{idx}}" (click)="removeTag(currentEntry.entry.id)">
                  <div class="adf-tag-actions-delete-text" id="tag_name_{{idx}}">
                      {{currentEntry.entry.tag}}
                  </div>
                  <mat-icon class="adf-tag-actions-delete-icon">delete</mat-icon>
              </div>
          </mat-list-item>
      </mat-list>
      <table class="adf-full-width" cellspacing="0">
          <tr>
              <td>
                  <mat-form-field class="adf-full-width">
                      <input matInput placeholder="{{'TAG.LABEL.NEWTAG' | translate }}"
                             type="text"
                             (keypress)="cleanErrorMsg()"
                             [(ngModel)]="newTagName"
                             id="new-tag-text"/>
                      <mat-hint *ngIf="error" [ngStyle]="{'color': 'red'}" align="start">{{errorMsg}}</mat-hint>
                  </mat-form-field>
              </td>
              <td>
                  <button class="adf-full-width" color="primary" id="add-tag" (click)="addTag()" [disabled]="disableAddTag"
                          mat-raised-button>
                      {{'TAG.BUTTON.ADD' | translate }}
                  </button>
              </td>
          </tr>
      </table>
    `,
                styles: [`
      .adf-full-width {
        width: 100%; }

      .adf-tag-actions-delete-icon {
        float: right;
        cursor: pointer; }

      .adf-tag-actions-delete-text {
        font-size: 16px;
        float: left; }

      .adf-tag-actions-container {
        padding: 8px 0 8px 0;
        height: 20px; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TagActionsComponent.ctorParameters = () => [
    { type: TagService, },
    { type: TranslationService, },
];
TagActionsComponent.propDecorators = {
    'nodeId': [{ type: Input },],
    'successAdd': [{ type: Output },],
    'error': [{ type: Output },],
    'result': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * This component provide a list of all the tag inside the ECM
 *
 */
class TagListComponent {
    /**
     * Constructor
     * @param {?} tagService
     */
    constructor(tagService) {
        this.tagService = tagService;
        this.result = new EventEmitter();
        this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        return this.refreshTag();
    }
    /**
     * @return {?}
     */
    refreshTag() {
        this.tagService.getAllTheTags().subscribe((data) => {
            this.tagsEntries = data.list.entries;
            this.result.emit(this.tagsEntries);
        });
    }
}
TagListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-list',
                template: `
      <mat-list>
          <mat-list-item *ngFor="let currentEntry of tagsEntries; let idx = index">
              <div class="adf-list-tag" id="tag_name_{{idx}}">{{currentEntry.entry.tag}}</div>
          </mat-list-item>
      </mat-list>
    `,
                styles: [`
      .adf-list-tag {
        padding: 16px;
        font-size: 16px; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TagListComponent.ctorParameters = () => [
    { type: TagService, },
];
TagListComponent.propDecorators = {
    'result': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * This component, ShowNodeTag a list of the tag on relative a node
 *
 */
class TagNodeListComponent {
    /**
     * Constructor
     * @param {?} tagService
     */
    constructor(tagService) {
        this.tagService = tagService;
        this.results = new EventEmitter();
        this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        });
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        return this.refreshTag();
    }
    /**
     * @return {?}
     */
    refreshTag() {
        this.tagService.getTagsByNodeId(this.nodeId).subscribe((data) => {
            this.tagsEntries = data.list.entries;
            this.results.emit(this.tagsEntries);
        });
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag).subscribe(() => {
            this.refreshTag();
        });
    }
}
TagNodeListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-list',
                template: `
      <mat-chip-list>
          <mat-chip class="adf-tag-chips adf-primary-background-color" *ngFor="let currentEntry of tagsEntries; let idx = index">
              <span id="tag_name_{{idx}}">{{currentEntry.entry.tag}}</span>
              <button class="adf-tag-chips-delete" id="tag_delete_{{idx}}" type="button" (click)="removeTag(currentEntry.entry.id)">
                  <mat-icon class="adf-tag-chips-delete-icon adf-primary-contrast-text-color" matChipRemove>cancel</mat-icon>
              </button>
          </mat-chip>
      </mat-chip-list>
    `,
                styles: [`
      .adf-tag-chips-delete {
        overflow: visible;
        cursor: pointer;
        height: 17px;
        width: 20px;
        float: right;
        border: 0;
        background: none;
        padding: 0;
        margin: -1px 0px 0px 10px; }

      .adf-tag-chips-delete-icon {
        font-size: 20px;
        background-repeat: no-repeat;
        display: inline-block;
        fill: currentColor;
        height: 20px;
        width: 20px; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
TagNodeListComponent.ctorParameters = () => [
    { type: TagService, },
];
TagNodeListComponent.propDecorators = {
    'nodeId': [{ type: Input },],
    'results': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TagModule {
}
TagModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                exports: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                declarations: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                providers: [
                    TagService
                ]
            },] },
];
/**
 * @nocollapse
 */
TagModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <adf-webscript-get [scriptPath]="string"
 *                         [scriptArgs]="Object"
 *                         [contextRoot]="string"
 *                         [servicePath]="string"
 *                         [contentType]="JSON|HTML|DATATABLE"
 *                         (success)="customMethod($event)>
 * </adf-webscript-get>
 *
 * This component, provide a get webscript viewer
 *
 * \@InputParam {string} scriptPath path to Web Script (as defined by Web Script)
 * \@InputParam {Object} scriptArgs arguments to pass to Web Script
 * \@InputParam {string} contextRoot path where application is deployed default value 'alfresco'
 * \@InputParam {string} servicePath path where Web Script service is mapped default value 'service'
 * \@InputParam {string} contentType JSON | HTML | DATATABLE | TEXT
 *
 * \@Output - success - The event is emitted when the data are recived
 *
 */
class WebscriptComponent {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.showData = true;
        this.contextRoot = 'alfresco';
        this.servicePath = 'service';
        this.contentType = 'TEXT';
        this.success = new EventEmitter();
        this.data = undefined;
        this.showError = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.showData) {
            this.clean();
        }
        return new Promise((resolve, reject) => {
            this.apiService.getInstance().webScript.executeWebScript('GET', this.scriptPath, this.scriptArgs, this.contextRoot, this.servicePath).then((webScriptdata) => {
                this.data = webScriptdata;
                if (this.showData) {
                    if (this.contentType === 'DATATABLE') {
                        this.data = this.showDataAsDataTable(webScriptdata);
                    }
                }
                this.success.emit(this.data);
                resolve();
            }, (error) => {
                this.logService.log('Error' + error);
                reject();
            });
        });
    }
    /**
     * show the data in a ng2-alfresco-datatable
     *
     * \@retutns the data as datatable
     * @param {?} data
     *
     * @return {?}
     */
    showDataAsDataTable(data) {
        let /** @type {?} */ datatableData = null;
        try {
            if (!data.schema) {
                data.schema = ObjectDataTableAdapter.generateSchema(data.data);
            }
            if (data.schema && data.schema.length > 0) {
                this.data = new ObjectDataTableAdapter(data.data, data.schema);
            }
        }
        catch (e) {
            this.logService.error('error during the cast as datatable');
        }
        return datatableData;
    }
    /**
     * @return {?}
     */
    clean() {
        this.data = undefined;
    }
    /**
     * @return {?}
     */
    isDataTableContent() {
        return this.contentType === 'DATATABLE';
    }
}
WebscriptComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-webscript-get',
                template: `
      <div *ngIf="showData">
          <div *ngIf="contentType === 'JSON'" id="webscript-data-JSON">{{data | json}}</div>
          <div *ngIf="contentType === 'HTML'" id="webscript-data-HTML" [innerHTML]="data"></div>
          <div *ngIf="contentType === 'TEXT'" id="webscript-data-TEXT">{{data}}</div>
          <div *ngIf="isDataTableContent()">
              <adf-datatable id="webscript-datatable-wrapper" [data]="data"></adf-datatable>
              <div>
                  <div *ngIf="showError" id="error">{{'WEBSCRIPT.ERROR' | translate: {
                      data: data,
                      contentType: contentType
                      }
                      }}
                  </div>
              </div>
          </div>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
WebscriptComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];
WebscriptComponent.propDecorators = {
    'scriptPath': [{ type: Input },],
    'scriptArgs': [{ type: Input },],
    'showData': [{ type: Input },],
    'contextRoot': [{ type: Input },],
    'servicePath': [{ type: Input },],
    'contentType': [{ type: Input },],
    'success': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WebScriptModule {
}
WebScriptModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PipeModule,
                    MaterialModule,
                    DataTableModule,
                    TranslateModule
                ],
                exports: [
                    WebscriptComponent
                ],
                declarations: [
                    WebscriptComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
WebScriptModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUploadingListComponent {
    /**
     * @param {?} uploadService
     * @param {?} nodesApi
     * @param {?} notificationService
     * @param {?} translateService
     */
    constructor(uploadService, nodesApi, notificationService, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.notificationService = notificationService;
        this.translateService = translateService;
        this.FileUploadStatus = FileUploadStatus;
        this.files = [];
    }
    /**
     * Cancel file upload
     *
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file
     * @return {?}
     */
    cancelFile(file) {
        this.uploadService.cancelUpload(file);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    removeFile(file) {
        this.deleteNode(file)
            .subscribe(() => {
            if (file.status === FileUploadStatus.Error) {
                this.notifyError(file);
            }
            this.uploadService.cancelUpload(file);
        });
    }
    /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    cancelAllFiles() {
        this.getUploadingFiles()
            .forEach((file) => this.uploadService.cancelUpload(file));
        const /** @type {?} */ deletedFiles = this.files
            .filter((file) => file.status === FileUploadStatus.Complete)
            .map((file) => this.deleteNode(file));
        Observable$1.forkJoin(...deletedFiles)
            .subscribe((files) => {
            const /** @type {?} */ errors = files
                .filter((file) => file.status === FileUploadStatus.Error);
            if (errors.length) {
                this.notifyError(...errors);
            }
            this.uploadService.cancelUpload(...files);
        });
    }
    /**
     * Checks if all the files are uploaded
     * @return {?}
     */
    isUploadCompleted() {
        return !this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files
                .some(({ status }) => status === FileUploadStatus.Starting ||
                status === FileUploadStatus.Progress ||
                status === FileUploadStatus.Pending);
    }
    /**
     * Check if all the files are Cancelled | Aborted | Error.
     * @return {?}
     */
    isUploadCancelled() {
        return !!this.files.length &&
            this.files
                .every(({ status }) => status === FileUploadStatus.Aborted ||
                status === FileUploadStatus.Cancelled ||
                status === FileUploadStatus.Deleted);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    deleteNode(file) {
        const { id } = file.data.entry;
        return this.nodesApi
            .deleteNode(id, { permanent: true })
            .map(() => {
            file.status = FileUploadStatus.Deleted;
            return file;
        })
            .catch((error) => {
            file.status = FileUploadStatus.Error;
            return Observable$1.of(file);
        });
    }
    /**
     * @param {...?} files
     * @return {?}
     */
    notifyError(...files) {
        let /** @type {?} */ translateSubscription = null;
        if (files.length === 1) {
            translateSubscription = this.translateService
                .get('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            translateSubscription = this.translateService
                .get('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        translateSubscription
            .subscribe(message => this.notificationService.openSnackMessage(message, 4000));
    }
    /**
     * @return {?}
     */
    getUploadingFiles() {
        return this.files.filter((item) => {
            if (item.status === FileUploadStatus.Pending ||
                item.status === FileUploadStatus.Progress ||
                item.status === FileUploadStatus.Starting) {
                return item;
            }
        });
    }
}
FileUploadingListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list',
                template: `
      <div class="upload-list">
          <ng-template
              ngFor
              [ngForOf]="files"
              [ngForTemplate]="template">
          </ng-template>
      </div>
    `,
                styles: [`
      :host {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column; }
    `]
            },] },
];
/**
 * @nocollapse
 */
FileUploadingListComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: NodesApiService, },
    { type: NotificationService, },
    { type: TranslationService, },
];
FileUploadingListComponent.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
    'files': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUploadingDialogComponent {
    /**
     * @param {?} uploadService
     * @param {?} changeDetecor
     */
    constructor(uploadService, changeDetecor) {
        this.uploadService = uploadService;
        this.changeDetecor = changeDetecor;
        this.position = 'right';
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.isDialogMinimized = false;
        this.isConfirmation = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.listSubscription = this.uploadService
            .queueChanged.subscribe((fileList) => {
            this.filesUploadingList = fileList;
            if (this.filesUploadingList.length) {
                this.isDialogActive = true;
            }
        });
        this.counterSubscription = Observable$1
            .merge(this.uploadService.fileUploadComplete, this.uploadService.fileUploadDeleted)
            .subscribe((event) => {
            this.totalCompleted = event.totalComplete;
            this.changeDetecor.detectChanges();
        });
        this.errorSubscription = this.uploadService.fileUploadError
            .subscribe((event) => {
            this.totalErrors = event.totalError;
            this.changeDetecor.detectChanges();
        });
        this.fileUploadSubscription = this.uploadService
            .fileUpload.subscribe(() => {
            this.changeDetecor.detectChanges();
        });
        this.uploadService.fileDeleted.subscribe((objId) => {
            if (this.filesUploadingList) {
                let /** @type {?} */ file = this.filesUploadingList.find((item) => {
                    return item.data.entry.id === objId;
                });
                if (file) {
                    file.status = FileUploadStatus.Cancelled;
                    this.changeDetecor.detectChanges();
                }
            }
        });
    }
    /**
     * Toggle confirmation message.
     * @return {?}
     */
    toggleConfirmation() {
        this.isConfirmation = !this.isConfirmation;
        if (this.isDialogMinimized) {
            this.isDialogMinimized = false;
        }
    }
    /**
     * Cancel uploads and hide confiramtion
     * @return {?}
     */
    cancelAllUploads() {
        this.toggleConfirmation();
        this.uploadList.cancelAllFiles();
    }
    /**
     * Toggle dialog minimized state.
     * @return {?}
     */
    toggleMinimized() {
        this.isDialogMinimized = !this.isDialogMinimized;
        this.changeDetecor.detectChanges();
    }
    /**
     * Dismiss dialog
     * @return {?}
     */
    close() {
        this.isConfirmation = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.isDialogMinimized = false;
        this.uploadService.clearQueue();
        this.changeDetecor.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.uploadService.clearQueue();
        this.listSubscription.unsubscribe();
        this.counterSubscription.unsubscribe();
        this.fileUploadSubscription.unsubscribe();
        this.errorSubscription.unsubscribe();
    }
}
FileUploadingDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-dialog, file-uploading-dialog',
                template: `
      <div *ngIf="isDialogActive"
           class="upload-dialog"
           [class.upload-dialog--minimized]="isDialogMinimized"
           [class.upload-dialog--position-left]="position === 'left'"
           [class.upload-dialog--position-right]="position === 'right'">
          <header class="upload-dialog__header">
              <button
                  mat-button
                  color="secondary"
                  [disabled]="isConfirmation"
                  (click)="toggleMinimized()">
                  <mat-icon
                      mat-list-icon
                      title="{{ (isDialogMinimized ? 'ADF_FILE_UPLOAD.BUTTON.MAXIMIZE': 'ADF_FILE_UPLOAD.BUTTON.MINIMIZE') | translate }}">
                          {{ isDialogMinimized ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}
                  </mat-icon>
              </button>

              <span
                  class="upload-dialog__title"
                  *ngIf="!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()">
                  {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_PROGRESS'
                      | translate: {
                          completed: totalCompleted,
                          total: filesUploadingList.length
                      }
                  }}
              </span>

              <span
                  class="upload-dialog__title"
                  *ngIf="uploadList.isUploadCompleted()">
                  {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_COMPLETED'
                      | translate: {
                          completed: totalCompleted,
                          total: filesUploadingList.length
                      }
                  }}
              </span>

              <span
                  class="upload-dialog__title"
                  *ngIf="uploadList.isUploadCancelled()">
                  {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_CANCELED' | translate }}
              </span>
          </header>

          <section
              class="upload-dialog__info"
              *ngIf="totalErrors">
              {{
                  (totalErrors > 1
                       ? 'FILE_UPLOAD.MESSAGES.UPLOAD_ERRORS'
                       : 'FILE_UPLOAD.MESSAGES.UPLOAD_ERROR')
                       | translate: { total: totalErrors }
              }}
          </section>

          <section
              class="upload-dialog__content"
              [class.upload-dialog--padding]="isConfirmation">
              <adf-file-uploading-list
                  [class.upload-dialog--hide]="isConfirmation"
                  #uploadList
                  [files]="filesUploadingList">
                      <ng-template let-file="$implicit">
                           <adf-file-uploading-list-row
                              [file]="file"
                              (remove)="uploadList.removeFile(file)"
                              (cancel)="uploadList.cancelFile(file)">
                          </adf-file-uploading-list-row>
                      </ng-template>
              </adf-file-uploading-list>

              <div
                  class="upload-dialog__confirmation"
                  [class.upload-dialog--hide]="!isConfirmation">
                      <p class="upload-dialog__confirmation--title">
                          {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TITLE' | translate }}
                      </p>

                      <p class="upload-dialog__confirmation--text">
                          {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TEXT' | translate }}
                      </p>
              </div>
          </section>

          <footer
              class="upload-dialog__actions"
              [class.upload-dialog--hide]="isConfirmation">
              <button
                  color="primary"
                  mat-button
                  *ngIf="!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()"
                  (click)="toggleConfirmation()">
                  {{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_ALL' | translate }}
              </button>

              <button
                  *ngIf="uploadList.isUploadCompleted() || uploadList.isUploadCancelled()"
                  mat-button
                  color="primary"
                  (click)="close($event)">
                  {{ 'ADF_FILE_UPLOAD.BUTTON.CLOSE' | translate }}
              </button>
          </footer>

          <footer
              class="upload-dialog__actions"
              [class.upload-dialog--hide]="!isConfirmation">
              <button
                  color="secondary"
                  mat-button
                  (click)="cancelAllUploads()">
                  {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CANCEL' | translate }}
              </button>

              <button
                  mat-button
                  color="primary"
                  (click)="toggleConfirmation()">
                  {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CONTINUE' | translate }}
              </button>
          </footer>
      </div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
FileUploadingDialogComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: ChangeDetectorRef, },
];
FileUploadingDialogComponent.propDecorators = {
    'uploadList': [{ type: ViewChild, args: [FileUploadingListComponent,] },],
    'position': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUploadingListRowComponent {
    constructor() {
        this.cancel = new EventEmitter();
        this.remove = new EventEmitter();
        this.FileUploadStatus = FileUploadStatus;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onCancel(file) {
        this.cancel.emit(file);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onRemove(file) {
        this.remove.emit(file);
    }
}
FileUploadingListRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list-row',
                template: `
      <div class="adf-file-uploading-row">
          <mat-icon
              mat-list-icon
              class="adf-file-uploading-row__type">
              insert_drive_file
          </mat-icon>

          <span
              class="adf-file-uploading-row__name"
              title="{{ file.name }}">
              {{ file.name }}
          </span>

          <div
              *ngIf="file.status === FileUploadStatus.Progress || file.status === FileUploadStatus.Starting"
              (click)="onCancel(file)"
              class="adf-file-uploading-row__group adf-file-uploading-row__group--toggle"
              title="{{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_FILE' | translate }}">
              <span class="adf-file-uploading-row__status">
                  {{ file.progress.loaded | adfFileSize }} / {{ file.progress.total | adfFileSize }}
              </span>

              <mat-icon
                  mat-list-icon
                  class="adf-file-uploading-row__action adf-file-uploading-row__action--cancel">
                  clear
              </mat-icon>
          </div>

          <div
              *ngIf="file.status === FileUploadStatus.Complete"
              (click)="onRemove(file)"
              class="adf-file-uploading-row__group adf-file-uploading-row__group--toggle"
              title="{{ 'ADF_FILE_UPLOAD.BUTTON.REMOVE_FILE' | translate }}">
              <mat-icon
                  mat-list-icon
                  class="adf-file-uploading-row__status adf-file-uploading-row__status--done">
                  check_circle
              </mat-icon>

              <mat-icon
                  mat-list-icon
                  class="adf-file-uploading-row__action adf-file-uploading-row__action--remove">
                  remove_circle
              </mat-icon>
          </div>

          <div
              *ngIf="file.status === FileUploadStatus.Pending"
              (click)="onCancel(file)"
              class="adf-file-uploading-row__group adf-file-uploading-row__group--toggle">
              <mat-icon
                  mat-list-icon
                  class="adf-file-uploading-row__status adf-file-uploading-row__status--pending">
                  schedule
              </mat-icon>

              <mat-icon
                  mat-list-icon
                  class="adf-file-uploading-row__action adf-file-uploading-row__action--remove">
                  remove_circle
              </mat-icon>
          </div>

          <div
              *ngIf="file.status === FileUploadStatus.Error"
              class="adf-file-uploading-row__block adf-file-uploading-row__status--error"
              title="{{ file.response }}">
              <mat-icon mat-list-icon>
                  report_problem
              </mat-icon>
          </div>

          <div
              *ngIf="file.status === FileUploadStatus.Cancelled  ||
                  file.status === FileUploadStatus.Aborted ||
                  file.status === FileUploadStatus.Deleted"
              class="adf-file-uploading-row__block adf-file-uploading-row__status--cancelled">
              {{ 'ADF_FILE_UPLOAD.STATUS.FILE_CANCELED_STATUS' | translate }}
          </div>
      <div>
    `,
                styles: [`

    `]
            },] },
];
/**
 * @nocollapse
 */
FileUploadingListRowComponent.ctorParameters = () => [];
FileUploadingListRowComponent.propDecorators = {
    'file': [{ type: Input },],
    'cancel': [{ type: Output },],
    'remove': [{ type: Output },],
};

class PermissionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.type = obj.type || null;
            this.action = obj.action || null;
            this.permission = obj.permission || null;
        }
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadButtonComponent {
    /**
     * @param {?} uploadService
     * @param {?} translateService
     * @param {?} logService
     * @param {?} apiService
     */
    constructor(uploadService, translateService, logService, apiService) {
        this.uploadService = uploadService;
        this.translateService = translateService;
        this.logService = logService;
        this.apiService = apiService;
        this.disabled = false;
        this.uploadFolders = false;
        this.multipleFiles = false;
        this.versioning = false;
        this.acceptedFilesType = '*';
        this.tooltip = null;
        this.rootFolderId = '-root-';
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.createFolder = new EventEmitter();
        this.permissionEvent = new EventEmitter();
        this.hasPermission = false;
        this.permissionValue = new Subject$1();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.permissionValue.subscribe((permission) => {
            this.hasPermission = permission;
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ rootFolderId = changes['rootFolderId'];
        if (rootFolderId && rootFolderId.currentValue) {
            this.checkPermission();
        }
    }
    /**
     * @return {?}
     */
    isButtonDisabled() {
        return this.disabled ? true : undefined;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFilesAdded($event) {
        let /** @type {?} */ files = FileUtils.toFileArray($event.currentTarget.files);
        if (this.hasPermission) {
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDirectoryAdded($event) {
        if (this.hasPermission) {
            let /** @type {?} */ files = FileUtils.toFileArray($event.currentTarget.files);
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    }
    /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    uploadFiles(files) {
        const /** @type {?} */ latestFilesAdded = files
            .map(this.createFileModel.bind(this))
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        if (latestFilesAdded.length > 0) {
            this.uploadService.addToQueue(...latestFilesAdded);
            this.uploadService.uploadFilesInTheQueue(this.success);
        }
    }
    /**
     * Creates FileModel from File
     *
     * @param {?} file
     * @return {?}
     */
    createFileModel(file) {
        return new FileModel(file, {
            newVersion: this.versioning,
            parentId: this.rootFolderId,
            path: (file.webkitRelativePath || '').replace(/\/[^\/]*$/, '')
        });
    }
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @param {?} file FileModel
     * @return {?}
     */
    isFileAcceptable(file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        const /** @type {?} */ allowedExtensions = this.acceptedFilesType
            .split(',')
            .map(ext => ext.replace(/^\./, ''));
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    }
    /**
     * Checks if the given file is an acceptable size
     *
     * @param {?} file FileModel
     * @return {?}
     */
    isFileSizeAcceptable(file) {
        let /** @type {?} */ acceptableSize = true;
        if ((this.maxFilesSize !== undefined && this.maxFilesSize !== null) && (this.maxFilesSize <= 0 || file.size > this.maxFilesSize)) {
            acceptableSize = false;
            this.translateService.get('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name }).subscribe((message) => {
                this.error.emit(message);
            });
        }
        return acceptableSize;
    }
    /**
     * @return {?}
     */
    checkPermission() {
        if (this.rootFolderId) {
            this.getFolderNode(this.rootFolderId).subscribe(res => this.permissionValue.next(this.hasCreatePermission(res)), error => this.error.emit(error));
        }
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    getFolderNode(nodeId) {
        let /** @type {?} */ opts = {
            includeSource: true,
            include: ['allowableOperations']
        };
        return Observable$1.fromPromise(this.apiService.getInstance().nodes.getNodeInfo(nodeId, opts))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // in a real world app, we may send the error to some remote logging infrastructure
        // instead of just logging it to the console
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
    /**
     * @param {?} node
     * @return {?}
     */
    hasCreatePermission(node) {
        if (node && node.allowableOperations) {
            return node.allowableOperations.find(permission => permission === 'create') ? true : false;
        }
        return false;
    }
}
UploadButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-button',
                template: `
      <form class="adf-upload-button-file-container">
          <!--Files Upload-->
          <a *ngIf="!uploadFolders"
              [disabled]="isButtonDisabled()"
              mat-raised-button color="primary">
              <mat-icon>file_upload</mat-icon>

              <!--Multiple Files Upload-->
              <span *ngIf="multipleFiles">
                  <label
                      id="upload-multiple-file-label"
                      *ngIf="!staticTitle"
                      for="upload-multiple-files">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>
                  <label
                      id="upload-multiple-file-label-static"
                      *ngIf="staticTitle"
                      for="upload-multiple-files">{{ staticTitle }}</label>
                  <input #uploadFiles
                      id="upload-multiple-files"
                      data-automation-id="upload-multiple-files"
                      type="file"
                      name="uploadFiles"
                      multiple="multiple"
                      accept="{{acceptedFilesType}}"
                      [attr.disabled]="isButtonDisabled()"
                      [title]="tooltip"
                      (change)="onFilesAdded($event)">
              </span>

              <!--Single Files Upload-->
              <span *ngIf="!multipleFiles">
                  <label
                      id="upload-single-file-label"
                      *ngIf="!staticTitle"
                      for="upload-single-file">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>
                  <label
                      id="upload-single-file-label-static"
                      *ngIf="staticTitle"
                      for="upload-single-file">{{ staticTitle }}</label>
                  <input #uploadFiles
                      id="upload-single-file"
                      data-automation-id="upload-single-file"
                      type="file"
                      name="uploadFiles"
                      accept="{{acceptedFilesType}}"
                      [attr.disabled]="isButtonDisabled()"
                      [title]="tooltip"
                      (change)="onFilesAdded($event)">
              </span>
          </a>

          <!--Folders Upload-->
          <a *ngIf="uploadFolders"
              [disabled]="isButtonDisabled()" mat-raised-button color="primary">
              <mat-icon>file_upload</mat-icon>
              <label
                  id="uploadFolder-label"
                  *ngIf="!staticTitle"
                  for="uploadFolder">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>
              <label
                  id="uploadFolder-label-static"
                  *ngIf="staticTitle"
                  for="uploadFolder">{{ staticTitle }}</label>
              <input #uploadFolders
                  id="uploadFolder"
                  data-automation-id="uploadFolder"
                  type="file"
                  name="uploadFiles"
                  multiple="multiple"
                  accept="{{acceptedFilesType}}"
                  webkitdirectory directory
                  [attr.disabled]="isButtonDisabled()"
                  [title]="tooltip"
                  (change)="onDirectoryAdded($event)">
          </a>
      </form>
    `,
                styles: [`
      .adf-upload-button-file-container input {
        cursor: pointer;
        height: 100%;
        right: 0;
        opacity: 0;
        position: absolute;
        top: 0;
        width: 300px;
        z-index: 4; }
    `],
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadButtonComponent) }
                ],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
UploadButtonComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: TranslationService, },
    { type: LogService, },
    { type: AlfrescoApiService, },
];
UploadButtonComponent.propDecorators = {
    'disabled': [{ type: Input },],
    'uploadFolders': [{ type: Input },],
    'multipleFiles': [{ type: Input },],
    'versioning': [{ type: Input },],
    'acceptedFilesType': [{ type: Input },],
    'maxFilesSize': [{ type: Input },],
    'staticTitle': [{ type: Input },],
    'tooltip': [{ type: Input },],
    'rootFolderId': [{ type: Input },],
    'success': [{ type: Output },],
    'error': [{ type: Output },],
    'createFolder': [{ type: Output },],
    'permissionEvent': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadDragAreaComponent {
    /**
     * @param {?} uploadService
     * @param {?} translateService
     * @param {?} notificationService
     */
    constructor(uploadService, translateService, notificationService) {
        this.uploadService = uploadService;
        this.translateService = translateService;
        this.notificationService = notificationService;
        this.disabled = false;
        this.versioning = false;
        this.success = new EventEmitter();
    }
    /**
     * Method called when files are dropped in the drag area.
     *
     * @param {?} files
     * @return {?}
     */
    onFilesDropped(files) {
        if (!this.disabled && files.length) {
            const /** @type {?} */ fileModels = files.map(file => new FileModel(file, {
                newVersion: this.versioning,
                path: '/',
                parentId: this.parentId
            }));
            this.uploadService.addToQueue(...fileModels);
            this.uploadService.uploadFilesInTheQueue(this.success);
        }
    }
    /**
     * Called when the file are dropped in the drag area
     *
     * @param {?} item - FileEntity
     * @return {?}
     */
    onFilesEntityDropped(item) {
        if (!this.disabled) {
            item.file((file) => {
                const /** @type {?} */ fileModel = new FileModel(file, {
                    newVersion: this.versioning,
                    parentId: this.parentId,
                    path: item.fullPath.replace(item.name, '')
                });
                this.uploadService.addToQueue(fileModel);
                this.uploadService.uploadFilesInTheQueue(this.success);
            });
        }
    }
    /**
     * Called when a folder are dropped in the drag area
     *
     * @param {?} folder - name of the dropped folder
     * @return {?}
     */
    onFolderEntityDropped(folder) {
        if (!this.disabled && folder.isDirectory) {
            FileUtils.flattern(folder).then(entries => {
                let /** @type {?} */ files = entries.map(entry => {
                    return new FileModel(entry.file, {
                        newVersion: this.versioning,
                        parentId: this.parentId,
                        path: entry.relativeFolder
                    });
                });
                this.uploadService.addToQueue(...files);
                this.uploadService.uploadFilesInTheQueue(this.success);
            });
        }
    }
    /**
     * Show undo notification bar.
     *
     * @param {?} latestFilesAdded
     * @return {?}
     */
    showUndoNotificationBar(latestFilesAdded) {
        let /** @type {?} */ messageTranslate, /** @type {?} */ actionTranslate;
        messageTranslate = this.translateService.get('FILE_UPLOAD.MESSAGES.PROGRESS');
        actionTranslate = this.translateService.get('FILE_UPLOAD.ACTION.UNDO');
        this.notificationService.openSnackMessageAction(messageTranslate.value, actionTranslate.value, 3000).onAction().subscribe(() => {
            this.uploadService.cancelUpload(...latestFilesAdded);
        });
    }
    /**
     * Show the error inside Notification bar
     *
     * @param {?} errorMessage
     * @return {?}
     */
    showErrorNotificationBar(errorMessage) {
        this.notificationService.openSnackMessage(errorMessage, 3000);
    }
    /**
     * Returns true or false considering the component options and node permissions
     * @return {?}
     */
    isDroppable() {
        return !this.disabled;
    }
    /**
     * Handles 'upload-files' events raised by child components.
     *
     * @param {?} event DOM event
     * @return {?}
     */
    onUploadFiles(event) {
        event.stopPropagation();
        event.preventDefault();
        let /** @type {?} */ isAllowed = this.hasCreatePermission(event.detail.data.obj.entry);
        if (isAllowed) {
            let /** @type {?} */ files = event.detail.files;
            if (files && files.length > 0) {
                let /** @type {?} */ parentId = this.parentId;
                if (event.detail.data && event.detail.data.obj.entry.isFolder) {
                    parentId = event.detail.data.obj.entry.id || this.parentId;
                }
                const /** @type {?} */ fileModels = files.map(fileInfo => new FileModel(fileInfo.file, {
                    newVersion: this.versioning,
                    path: fileInfo.relativeFolder,
                    parentId: parentId
                }));
                this.uploadFiles(fileModels);
            }
        }
    }
    /**
     * Does the actual file uploading and show the notification
     *
     * @param {?} files
     * @return {?}
     */
    uploadFiles(files) {
        if (files.length) {
            this.uploadService.addToQueue(...files);
            this.uploadService.uploadFilesInTheQueue(this.success);
        }
    }
    /**
     * Check if "create" permission is present on the given node
     *
     * @param {?} node
     * @return {?}
     */
    hasCreatePermission(node) {
        let /** @type {?} */ isPermitted = false;
        if (node && node['allowableOperations']) {
            let /** @type {?} */ permFound = node['allowableOperations'].find(element => element === 'create');
            isPermitted = permFound ? true : false;
        }
        return isPermitted;
    }
}
UploadDragAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-drag-area',
                template: `
      <div [file-draggable]="isDroppable()" id="UploadBorder" class="upload-border"
           (filesDropped)="onFilesDropped($event)"
           (filesEntityDropped)="onFilesEntityDropped($event)"
           (folderEntityDropped)="onFolderEntityDropped($event)"
           (upload-files)="onUploadFiles($event)"
           dropzone="" webkitdropzone="*" #droparea>
          <ng-content></ng-content>
      </div>
    `,
                styles: [`
      .upload-border {
          vertical-align: middle;
          text-align: center;
      }

      .file-draggable__input-focus {
          color: #2196F3;
          border: 1px dashed #2196F3;
      }
    `],
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadDragAreaComponent) }
                ],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
UploadDragAreaComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: TranslationService, },
    { type: NotificationService, },
];
UploadDragAreaComponent.propDecorators = {
    'disabled': [{ type: Input },],
    'versioning': [{ type: Input },],
    'parentId': [{ type: Input },],
    'success': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileDraggableDirective {
    /**
     * @param {?} el
     * @param {?} ngZone
     */
    constructor(el, ngZone) {
        this.ngZone = ngZone;
        this.enabled = true;
        this.filesDropped = new EventEmitter();
        this.filesEntityDropped = new EventEmitter();
        this.folderEntityDropped = new EventEmitter();
        this.cssClassName = 'file-draggable__input-focus';
        this.element = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
            this.element.addEventListener('dragover', this.onDragOver.bind(this));
            this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
            this.element.addEventListener('drop', this.onDropFiles.bind(this));
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDropFiles);
    }
    /**
     * Method called when files is dropped in the drag and drop area.
     * @param {?} event DOM event.
     * @return {?}
     */
    onDropFiles(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            let /** @type {?} */ items = event.dataTransfer.items;
            if (items) {
                for (let /** @type {?} */ i = 0; i < items.length; i++) {
                    if (typeof items[i].webkitGetAsEntry !== 'undefined') {
                        let /** @type {?} */ item = items[i].webkitGetAsEntry();
                        if (item) {
                            if (item.isFile) {
                                this.filesEntityDropped.emit(item);
                            }
                            else if (item.isDirectory) {
                                this.folderEntityDropped.emit(item);
                            }
                        }
                    }
                    else {
                        let /** @type {?} */ files = FileUtils.toFileArray(event.dataTransfer.files);
                        this.filesDropped.emit(files);
                    }
                }
            }
            else {
                // safari or FF
                let /** @type {?} */ files = FileUtils.toFileArray(event.dataTransfer.files);
                this.filesDropped.emit(files);
            }
            this.element.classList.remove(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file drag in.
     *
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file drag out.
     *
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.remove(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file is over the drag area.
     *
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    /**
     * Prevent default and stop propagation of the DOM event.
     *
     * @param {?} event
     * @return {?}
     */
    preventDefault(event) {
        event.stopPropagation();
        event.preventDefault();
    }
}
FileDraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[file-draggable]'
            },] },
];
/**
 * @nocollapse
 */
FileDraggableDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
];
FileDraggableDirective.propDecorators = {
    'enabled': [{ type: Input, args: ['file-draggable',] },],
    'filesDropped': [{ type: Output },],
    'filesEntityDropped': [{ type: Output },],
    'folderEntityDropped': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadModule {
}
UploadModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    PipeModule
                ],
                declarations: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ],
                exports: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
UploadModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let presetsDefaultModel = {
    '-trashcan-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'archivedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'archivedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_BY',
            sortable: true
        }
    ],
    '-sites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-mysites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-favorites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ],
    '-recent-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        }
    ],
    '-sharedlinks-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        },
        {
            key: 'sharedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SHARED_BY',
            sortable: true
        }
    ],
    'default': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ]
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ShareDataRow {
    /**
     * @param {?} obj
     * @param {?} documentListService
     * @param {?} permissionsStyle
     */
    constructor(obj, documentListService, permissionsStyle) {
        this.obj = obj;
        this.documentListService = documentListService;
        this.permissionsStyle = permissionsStyle;
        this.cache = {};
        this.isSelected = false;
        this.cssClass = '';
        if (!obj) {
            throw new Error(ShareDataRow.ERR_OBJECT_NOT_FOUND);
        }
        this.isDropTarget = this.isFolderAndHasPermissionToUpload(obj);
        if (permissionsStyle) {
            this.cssClass = this.getPermissionClass(obj);
        }
    }
    /**
     * @return {?}
     */
    get node() {
        return this.obj;
    }
    /**
     * @param {?} nodeEntity
     * @return {?}
     */
    getPermissionClass(nodeEntity) {
        let /** @type {?} */ permissionsClasses = '';
        this.permissionsStyle.forEach((currentPermissionsStyle) => {
            if (this.applyPermissionStyleToFolder(nodeEntity.entry, currentPermissionsStyle) || this.applyPermissionStyleToFile(nodeEntity.entry, currentPermissionsStyle)) {
                if (this.documentListService.hasPermission(nodeEntity.entry, currentPermissionsStyle.permission)) {
                    permissionsClasses += ` ${currentPermissionsStyle.css}`;
                }
            }
        });
        return permissionsClasses;
    }
    /**
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    applyPermissionStyleToFile(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFile && node.isFile);
    }
    /**
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    applyPermissionStyleToFolder(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFolder && node.isFolder);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isFolderAndHasPermissionToUpload(obj) {
        return this.isFolder(obj) && this.documentListService.hasPermission(obj.entry, 'create');
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isFolder(obj) {
        return obj.entry && obj.entry.isFolder;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    cacheValue(key, value) {
        this.cache[key] = value;
        return value;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getValue(key) {
        if (this.cache[key] !== undefined) {
            return this.cache[key];
        }
        return ObjectUtils.getValue(this.obj.entry, key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
}
ShareDataRow.ERR_OBJECT_NOT_FOUND = 'Object source not found';

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ShareDataTableAdapter {
    /**
     * @param {?} documentListService
     * @param {?=} schema
     * @param {?=} sorting
     */
    constructor(documentListService, schema = [], sorting) {
        this.documentListService = documentListService;
        this.ERR_ROW_NOT_FOUND = 'Row not found';
        this.ERR_COL_NOT_FOUND = 'Column not found';
        this.thumbnails = false;
        this.rows = [];
        this.columns = schema || [];
        this.sorting = sorting;
    }
    /**
     * @return {?}
     */
    getRows() {
        return this.rows;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    setRows(rows) {
        this.rows = rows || [];
        this.sort();
    }
    /**
     * @return {?}
     */
    getColumns() {
        return this.columns;
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    setColumns(columns) {
        this.columns = columns || [];
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getValue(row, col) {
        if (!row) {
            throw new Error(this.ERR_ROW_NOT_FOUND);
        }
        if (!col) {
            throw new Error(this.ERR_COL_NOT_FOUND);
        }
        let /** @type {?} */ dataRow = (row);
        let /** @type {?} */ value = row.getValue(col.key);
        if (dataRow.cache[col.key] !== undefined) {
            return dataRow.cache[col.key];
        }
        if (col.type === 'date') {
            try {
                const /** @type {?} */ result = this.formatDate(col, value);
                return dataRow.cacheValue(col.key, result);
            }
            catch (err) {
                console.error(`Error parsing date ${value} to format ${col.format}`);
                return 'Error';
            }
        }
        if (col.key === '$thumbnail') {
            if (this.imageResolver) {
                let /** @type {?} */ resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
            const /** @type {?} */ node = ((row)).node;
            if (node.entry.isFolder) {
                return this.documentListService.getMimeTypeIcon('folder');
            }
            if (node.entry.isFile) {
                if (this.thumbnails) {
                    return this.documentListService.getDocumentThumbnailUrl(node);
                }
            }
            if (node.entry.content) {
                const /** @type {?} */ mimeType = node.entry.content.mimeType;
                if (mimeType) {
                    return this.documentListService.getMimeTypeIcon(mimeType);
                }
            }
            return this.documentListService.getDefaultMimeTypeIcon();
        }
        if (col.type === 'image') {
            if (this.imageResolver) {
                let /** @type {?} */ resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
        }
        return dataRow.cacheValue(col.key, value);
    }
    /**
     * @param {?} col
     * @param {?} value
     * @return {?}
     */
    formatDate(col, value) {
        if (col.type === 'date') {
            const /** @type {?} */ format = col.format || 'medium';
            if (format === 'timeAgo') {
                const /** @type {?} */ timeAgoPipe = new TimeAgoPipe();
                return timeAgoPipe.transform(value);
            }
            else {
                const /** @type {?} */ datePipe = new DatePipe('en-US');
                return datePipe.transform(value, format);
            }
        }
        return value;
    }
    /**
     * @return {?}
     */
    getSorting() {
        return this.sorting;
    }
    /**
     * @param {?} sorting
     * @return {?}
     */
    setSorting(sorting) {
        this.sorting = sorting;
        this.sortRows(this.rows, this.sorting);
    }
    /**
     * @param {?=} key
     * @param {?=} direction
     * @return {?}
     */
    sort(key, direction) {
        let /** @type {?} */ sorting = this.sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    setFilter(filter) {
        this.filter = filter;
    }
    /**
     * @param {?} resolver
     * @return {?}
     */
    setImageResolver(resolver) {
        this.imageResolver = resolver;
    }
    /**
     * @param {?} rows
     * @param {?} sorting
     * @return {?}
     */
    sortRows(rows, sorting) {
        const /** @type {?} */ options = {};
        if (sorting && sorting.key && rows && rows.length > 0) {
            if (sorting.key.includes('sizeInBytes') || sorting.key === 'name') {
                options.numeric = true;
            }
            rows.sort((a, b) => {
                if (a.node.entry.isFolder !== b.node.entry.isFolder) {
                    return a.node.entry.isFolder ? -1 : 1;
                }
                let /** @type {?} */ left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                let /** @type {?} */ right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right, undefined, options)
                    : right.localeCompare(left, undefined, options);
            });
        }
    }
    /**
     * @param {?} page
     * @param {?=} merge
     * @return {?}
     */
    loadPage(page, merge$$1 = false) {
        let /** @type {?} */ rows = [];
        if (page && page.list) {
            let /** @type {?} */ data = page.list.entries;
            if (data && data.length > 0) {
                rows = data.map(item => new ShareDataRow(item, this.documentListService, this.permissionsStyle));
                if (this.filter) {
                    rows = rows.filter(this.filter);
                }
                // Sort by first sortable or just first column
                if (this.columns && this.columns.length > 0) {
                    let /** @type {?} */ sorting = this.getSorting();
                    if (sorting) {
                        this.sortRows(rows, sorting);
                    }
                    else {
                        let /** @type {?} */ sortable = this.columns.filter(c => c.sortable);
                        if (sortable.length > 0) {
                            this.sort(sortable[0].key, 'asc');
                        }
                        else {
                            this.sort(this.columns[0].key, 'asc');
                        }
                    }
                }
            }
        }
        if (merge$$1) {
            this.rows = this.rows.concat(rows);
        }
        else {
            this.rows = rows;
        }
    }
}

class ContentActionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.disableWithNoPermission = false;
        this.disabled = false;
        if (obj) {
            this.icon = obj.icon;
            this.title = obj.title;
            this.handler = obj.handler;
            this.execute = obj.execute;
            this.target = obj.target;
            this.permission = obj.permission;
            this.disableWithNoPermission = obj.disableWithNoPermission;
            this.disabled = obj.disabled;
        }
    }
}
class DocumentActionModel extends ContentActionModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.target = 'document';
    }
}
class FolderActionModel extends ContentActionModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.target = 'folder';
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentListService {
    /**
     * @param {?} authService
     * @param {?} contentService
     * @param {?} apiService
     * @param {?} logService
     * @param {?} thumbnailService
     */
    constructor(authService, contentService, apiService, logService, thumbnailService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
    }
    /**
     * @param {?} folder
     * @param {?=} opts
     * @return {?}
     */
    getNodesPromise(folder, opts) {
        let /** @type {?} */ rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        let /** @type {?} */ params = {
            includeSource: true,
            include: ['path', 'properties', 'allowableOperations']
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
        }
        return this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params);
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    deleteNode(nodeId) {
        return Observable$1.fromPromise(this.apiService.getInstance().nodes.deleteNode(nodeId));
    }
    /**
     * Copy a node to destination node
     *
     * @param {?} nodeId The id of the node to be copied
     * @param {?} targetParentId The id of the folder-node where the node have to be copied to
     * @return {?}
     */
    copyNode(nodeId, targetParentId) {
        return Observable$1.fromPromise(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId }))
            .catch(err => this.handleError(err));
    }
    /**
     * Move a node to destination node
     *
     * @param {?} nodeId The id of the node to be moved
     * @param {?} targetParentId The id of the folder-node where the node have to be moved to
     * @return {?}
     */
    moveNode(nodeId, targetParentId) {
        return Observable$1.fromPromise(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId }))
            .catch(err => this.handleError(err));
    }
    /**
     * Create a new folder in the path.
     * @param {?} name Folder name
     * @param {?} parentId Parent folder ID
     * @return {?}
     */
    createFolder(name, parentId) {
        return Observable$1.fromPromise(this.apiService.getInstance().nodes.createFolder(name, '/', parentId))
            .catch(err => this.handleError(err));
    }
    /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param {?} folder Path to folder.
     * @param {?=} opts Options.
     * @return {?}
     */
    getFolder(folder, opts) {
        return Observable$1.fromPromise(this.getNodesPromise(folder, opts))
            .map(res => /** @type {?} */ (res))
            .catch(err => this.handleError(err));
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    getFolderNode(nodeId) {
        let /** @type {?} */ opts = {
            includeSource: true,
            include: ['path', 'properties', 'allowableOperations']
        };
        let /** @type {?} */ nodes = this.apiService.getInstance().nodes;
        return nodes.getNodeInfo(nodeId, opts);
    }
    /**
     * Get thumbnail URL for the given document node.
     * @param {?} node Node to get URL for.
     * @return {?}
     */
    getDocumentThumbnailUrl(node) {
        return this.thumbnailService.getDocumentThumbnailUrl(node);
    }
    /**
     * @param {?} mimeType
     * @return {?}
     */
    getMimeTypeIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * @return {?}
     */
    getDefaultMimeTypeIcon() {
        return this.thumbnailService.getDefaultMimeTypeIcon();
    }
    /**
     * @param {?} node
     * @param {?} permission
     * @return {?}
     */
    hasPermission(node, permission) {
        return this.contentService.hasPermission(node, permission);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // in a real world app, we may send the error to some remote logging infrastructure
        // instead of just logging it to the console
        this.logService.error(error);
        return Observable$1.throw(error || 'Server error');
    }
}
DocumentListService.ROOT_ID = '-root-';
DocumentListService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DocumentListService.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: ContentService, },
    { type: AlfrescoApiService, },
    { type: LogService, },
    { type: ThumbnailService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeEntityEvent extends BaseEvent {
    /**
     * @param {?} entity
     */
    constructor(entity) {
        super();
        this.value = entity;
    }
}
class NodeEntryEvent extends BaseEvent {
    /**
     * @param {?} entity
     */
    constructor(entity) {
        super();
        this.value = entity;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let PaginationStrategy = {};
PaginationStrategy.Finite = 0;
PaginationStrategy.Infinite = 1;
PaginationStrategy[PaginationStrategy.Finite] = "Finite";
PaginationStrategy[PaginationStrategy.Infinite] = "Infinite";
class DocumentListComponent {
    /**
     * @param {?} documentListService
     * @param {?} ngZone
     * @param {?} elementRef
     * @param {?} apiService
     * @param {?} appConfig
     * @param {?} preferences
     */
    constructor(documentListService, ngZone, elementRef, apiService, appConfig, preferences) {
        this.documentListService = documentListService;
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.apiService = apiService;
        this.appConfig = appConfig;
        this.preferences = preferences;
        this.permissionsStyle = [];
        this.locationFormat = '/';
        this.navigate = true;
        this.navigationMode = DocumentListComponent.DOUBLE_CLICK_NAVIGATION; // click|dblclick
        this.thumbnails = false;
        this.selectionMode = 'single'; // null|single|multiple
        this.multiselect = false;
        this.contentActions = false;
        this.contentActionsPosition = 'right'; // left|right
        this.contextMenuActions = false;
        this.emptyFolderImageUrl = './assets/images/empty_doc_lib.svg';
        this.allowDropFiles = false;
        this.loading = false;
        this.rowFilter = null;
        this.imageResolver = null;
        // The identifier of a node. You can also use one of these well-known aliases: -my- | -shared- | -root-
        this.currentFolderId = null;
        this.folderNode = null;
        this.node = null;
        this.skipCount = 0;
        this.enableInfiniteScrolling = false;
        this.nodeClick = new EventEmitter();
        this.nodeDblClick = new EventEmitter();
        this.folderChange = new EventEmitter();
        this.preview = new EventEmitter();
        this.ready = new EventEmitter();
        this.error = new EventEmitter();
        this.actions = [];
        this.contextActionHandler = new Subject$1();
        this.infiniteLoading = false;
        this.noPermission = false;
        this.selection = new Array();
        this.pagination = new Subject$1();
        this.layoutPresets = {};
        this.currentNodeAllowableOperations = [];
        this.CREATE_PERMISSION = 'create';
        this.maxItems = this.preferences.paginationSize;
        this.pagination.next({
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            totalItems: 0,
            hasMoreItems: false
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getContextActions(node) {
        if (node && node.entry) {
            let /** @type {?} */ actions = this.getNodeActions(node);
            if (actions && actions.length > 0) {
                return actions.map((currentAction) => {
                    return {
                        model: currentAction,
                        node: node,
                        subject: this.contextActionHandler
                    };
                });
            }
        }
        return null;
    }
    /**
     * @param {?} action
     * @return {?}
     */
    contextActionCallback(action) {
        if (action) {
            this.executeContentAction(action.node, action.model);
        }
    }
    /**
     * @return {?}
     */
    get hasCustomLayout() {
        return this.columnList && this.columnList.columns && this.columnList.columns.length > 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.loadLayoutPresets();
        this.data = new ShareDataTableAdapter(this.documentListService, null, this.getDefaultSorting());
        this.data.thumbnails = this.thumbnails;
        this.data.permissionsStyle = this.permissionsStyle;
        if (this.rowFilter) {
            this.data.setFilter(this.rowFilter);
        }
        if (this.imageResolver) {
            this.data.setImageResolver(this.imageResolver);
        }
        this.contextActionHandlerSubscription = this.contextActionHandler.subscribe(val => this.contextActionCallback(val));
        this.enforceSingleClickNavigationForMobile();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        let /** @type {?} */ schema = [];
        if (this.hasCustomLayout) {
            schema = this.columnList.columns.map(c => /** @type {?} */ (c));
        }
        if (!this.data) {
            this.data = new ShareDataTableAdapter(this.documentListService, schema, this.getDefaultSorting());
        }
        else if (schema && schema.length > 0) {
            this.data.setColumns(schema);
        }
        let /** @type {?} */ columns = this.data.getColumns();
        if (!columns || columns.length === 0) {
            this.setupDefaultColumns(this.currentFolderId);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isSkipCountChanged(changes) ||
            this.isMaxItemsChanged(changes)) {
            this.reload(this.enableInfiniteScrolling);
        }
        if (changes.folderNode && changes.folderNode.currentValue) {
            this.loadFolder();
        }
        else if (changes.currentFolderId && changes.currentFolderId.currentValue) {
            if (changes.currentFolderId.previousValue !== changes.currentFolderId.currentValue) {
                this.folderNode = null;
            }
            if (!this.hasCustomLayout) {
                this.setupDefaultColumns(changes.currentFolderId.currentValue);
            }
            this.loadFolderByNodeId(changes.currentFolderId.currentValue);
        }
        else if (this.data) {
            if (changes.node && changes.node.currentValue) {
                this.resetSelection();
                this.data.loadPage(changes.node.currentValue);
                this.pagination.next(changes.node.currentValue.list.pagination);
            }
            else if (changes.rowFilter) {
                this.data.setFilter(changes.rowFilter.currentValue);
                if (this.currentFolderId) {
                    this.loadFolderNodesByFolderNodeId(this.currentFolderId, this.maxItems, this.skipCount);
                }
            }
            else if (changes.imageResolver) {
                this.data.setImageResolver(changes.imageResolver.currentValue);
            }
        }
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    reload(merge$$1 = false) {
        this.ngZone.run(() => {
            this.resetSelection();
            if (this.folderNode) {
                this.loadFolder(merge$$1);
            }
            else if (this.currentFolderId) {
                this.loadFolderByNodeId(this.currentFolderId, merge$$1);
            }
            else if (this.node) {
                this.data.loadPage(this.node);
                this.onDataReady(this.node);
            }
        });
    }
    /**
     * @return {?}
     */
    isEmptyTemplateDefined() {
        if (this.dataTable) {
            if (this.emptyFolderTemplate) {
                return true;
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    isNoPermissionTemplateDefined() {
        if (this.dataTable) {
            if (this.noPermissionTemplate) {
                return true;
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    isMobile() {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return !this.data || this.data.getRows().length === 0;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNodeActions(node) {
        let /** @type {?} */ target = null;
        if (node && node.entry) {
            if (node.entry.isFile) {
                target = 'document';
            }
            if (node.entry.isFolder) {
                target = 'folder';
            }
            if (target) {
                let /** @type {?} */ ltarget = target.toLowerCase();
                let /** @type {?} */ actionsByTarget = this.actions.filter(entry => {
                    return entry.target.toLowerCase() === ltarget;
                }).map(action => new ContentActionModel(action));
                actionsByTarget.forEach((action) => {
                    this.checkPermission(node, action);
                });
                return actionsByTarget;
            }
        }
        return [];
    }
    /**
     * @param {?} node
     * @param {?} action
     * @return {?}
     */
    checkPermission(node, action) {
        if (action.permission) {
            if (this.hasPermissions(node)) {
                let /** @type {?} */ permissions = node.entry.allowableOperations;
                let /** @type {?} */ findPermission = permissions.find(permission => permission === action.permission);
                if (!findPermission && action.disableWithNoPermission === true) {
                    action.disabled = true;
                }
            }
        }
        return action;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    hasPermissions(node) {
        return node.entry.allowableOperations ? true : false;
    }
    /**
     * @param {?=} e
     * @return {?}
     */
    onShowContextMenu(e) {
        if (e && this.contextMenuActions) {
            e.preventDefault();
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    performNavigation(node) {
        if (this.canNavigateFolder(node)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    performCustomSourceNavigation(node) {
        if (this.isCustomSource(this.currentFolderId)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    updateFolderData(node) {
        this.currentFolderId = node.entry.id;
        this.folderNode = node.entry;
        this.skipCount = 0;
        this.currentNodeAllowableOperations = node.entry['allowableOperations'] ? node.entry['allowableOperations'] : [];
        this.loadFolder();
        this.folderChange.emit(new NodeEntryEvent(node.entry));
    }
    /**
     * Invoked when executing content action for a document or folder.
     * @param {?} node Node to be the context of the execution.
     * @param {?} action Action to be executed against the context.
     * @return {?}
     */
    executeContentAction(node, action) {
        if (node && node.entry && action) {
            let /** @type {?} */ handlerSub;
            if (typeof action.handler === 'function') {
                handlerSub = action.handler(node, this, action.permission);
            }
            else {
                handlerSub = Observable$1.of(true);
            }
            if (typeof action.execute === 'function') {
                handlerSub.subscribe(() => {
                    action.execute(node);
                });
            }
        }
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    loadFolder(merge$$1 = false) {
        if (merge$$1) {
            this.infiniteLoading = true;
        }
        else {
            this.loading = true;
        }
        let /** @type {?} */ nodeId = this.folderNode ? this.folderNode.id : this.currentFolderId;
        if (!this.hasCustomLayout) {
            this.setupDefaultColumns(nodeId);
        }
        if (nodeId) {
            this.loadFolderNodesByFolderNodeId(nodeId, this.maxItems, this.skipCount, merge$$1).catch(err => this.error.emit(err));
        }
    }
    /**
     * @param {?} nodeId
     * @param {?=} merge
     * @return {?}
     */
    loadFolderByNodeId(nodeId, merge$$1 = false) {
        this.loading = true;
        this.resetSelection();
        if (nodeId === '-trashcan-') {
            this.loadTrashcan(merge$$1);
        }
        else if (nodeId === '-sharedlinks-') {
            this.loadSharedLinks(merge$$1);
        }
        else if (nodeId === '-sites-') {
            this.loadSites(merge$$1);
        }
        else if (nodeId === '-mysites-') {
            this.loadMemberSites(merge$$1);
        }
        else if (nodeId === '-favorites-') {
            this.loadFavorites(merge$$1);
        }
        else if (nodeId === '-recent-') {
            this.loadRecent(merge$$1);
        }
        else {
            this.documentListService
                .getFolderNode(nodeId)
                .then(node => {
                this.folderNode = node;
                this.currentFolderId = node.id;
                this.skipCount = 0;
                this.currentNodeAllowableOperations = node['allowableOperations'] ? node['allowableOperations'] : [];
                return this.loadFolderNodesByFolderNodeId(node.id, this.maxItems, this.skipCount, merge$$1);
            })
                .catch(err => {
                if (JSON.parse(err.message).error.statusCode === 403) {
                    this.loading = false;
                    this.noPermission = true;
                }
                this.error.emit(err);
            });
        }
    }
    /**
     * @param {?} id
     * @param {?} maxItems
     * @param {?} skipCount
     * @param {?=} merge
     * @return {?}
     */
    loadFolderNodesByFolderNodeId(id, maxItems, skipCount, merge$$1 = false) {
        return new Promise((resolve, reject) => {
            this.resetSelection();
            this.documentListService
                .getFolder(null, {
                maxItems: maxItems,
                skipCount: skipCount,
                rootFolderId: id
            })
                .subscribe(val => {
                this.data.loadPage(/** @type {?} */ (val), merge$$1);
                this.loading = false;
                this.infiniteLoading = false;
                this.onDataReady(val);
                resolve(true);
            }, error => {
                reject(error);
            });
        });
    }
    /**
     * @return {?}
     */
    resetSelection() {
        this.dataTable.resetSelection();
        this.selection = [];
    }
    /**
     * @param {?} changePage
     * @return {?}
     */
    isSkipCountChanged(changePage) {
        return changePage.skipCount &&
            changePage.skipCount.currentValue !== null &&
            changePage.skipCount.currentValue !== undefined &&
            changePage.skipCount.currentValue !== changePage.skipCount.previousValue;
    }
    /**
     * @param {?} changePage
     * @return {?}
     */
    isMaxItemsChanged(changePage) {
        return changePage.maxItems &&
            changePage.maxItems.currentValue &&
            changePage.maxItems.currentValue !== changePage.maxItems.previousValue;
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    loadTrashcan(merge$$1 = false) {
        const /** @type {?} */ options = {
            include: ['path', 'properties'],
            maxItems: this.maxItems,
            skipCount: this.skipCount
        };
        this.apiService.nodesApi.getDeletedNodes(options)
            .then((page) => this.onPageLoaded(page, merge$$1))
            .catch(error => this.error.emit(error));
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    loadSharedLinks(merge$$1 = false) {
        const /** @type {?} */ options = {
            include: ['properties', 'allowableOperations', 'path'],
            maxItems: this.maxItems,
            skipCount: this.skipCount
        };
        this.apiService.sharedLinksApi.findSharedLinks(options)
            .then((page) => this.onPageLoaded(page, merge$$1))
            .catch(error => this.error.emit(error));
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    loadSites(merge$$1 = false) {
        const /** @type {?} */ options = {
            include: ['properties'],
            maxItems: this.maxItems,
            skipCount: this.skipCount
        };
        this.apiService.sitesApi.getSites(options)
            .then((page) => this.onPageLoaded(page, merge$$1))
            .catch(error => this.error.emit(error));
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    loadMemberSites(merge$$1 = false) {
        const /** @type {?} */ options = {
            include: ['properties'],
            maxItems: this.maxItems,
            skipCount: this.skipCount
        };
        this.apiService.peopleApi.getSiteMembership('-me-', options)
            .then((result) => {
            let /** @type {?} */ page = {
                list: {
                    entries: result.list.entries
                        .map(({ entry: { site } }) => {
                        site.allowableOperations = site.allowableOperations ? site.allowableOperations : [this.CREATE_PERMISSION];
                        return {
                            entry: site
                        };
                    }),
                    pagination: result.list.pagination
                }
            };
            this.onPageLoaded(page, merge$$1);
        })
            .catch(error => this.error.emit(error));
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    loadFavorites(merge$$1 = false) {
        const /** @type {?} */ options = {
            maxItems: this.maxItems,
            skipCount: this.skipCount,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: ['properties', 'allowableOperations', 'path']
        };
        this.apiService.favoritesApi.getFavorites('-me-', options)
            .then((result) => {
            let /** @type {?} */ page = {
                list: {
                    entries: result.list.entries
                        .map(({ entry: { target } }) => ({
                        entry: target.file || target.folder
                    }))
                        .map(({ entry }) => {
                        entry.properties = {
                            'cm:title': entry.title,
                            'cm:description': entry.description
                        };
                        return { entry };
                    }),
                    pagination: result.list.pagination
                }
            };
            this.onPageLoaded(page, merge$$1);
        })
            .catch(error => this.error.emit(error));
    }
    /**
     * @param {?=} merge
     * @return {?}
     */
    loadRecent(merge$$1 = false) {
        this.apiService.peopleApi.getPerson('-me-')
            .then((person) => {
            const /** @type {?} */ username = person.entry.id;
            const /** @type {?} */ query = {
                query: {
                    query: '*',
                    language: 'afts'
                },
                filterQueries: [
                    { query: `cm:modified:[NOW/DAY-30DAYS TO NOW/DAY+1DAY]` },
                    { query: `cm:modifier:${username} OR cm:creator:${username}` },
                    { query: `TYPE:"content" AND -TYPE:"app:filelink" AND -TYPE:"fm:post"` }
                ],
                include: ['path', 'properties', 'allowableOperations'],
                sort: [{
                        type: 'FIELD',
                        field: 'cm:modified',
                        ascending: false
                    }],
                paging: {
                    maxItems: this.maxItems,
                    skipCount: this.skipCount
                }
            };
            return this.apiService.searchApi.search(query);
        })
            .then((page) => this.onPageLoaded(page, merge$$1))
            .catch(error => this.error.emit(error));
    }
    /**
     * @param {?} page
     * @param {?=} merge
     * @return {?}
     */
    onPageLoaded(page, merge$$1 = false) {
        if (page) {
            this.data.loadPage(page, merge$$1);
            this.loading = false;
            this.onDataReady(page);
        }
    }
    /**
     * Creates a set of predefined columns.
     * @param {?=} preset
     * @return {?}
     */
    setupDefaultColumns(preset = 'default') {
        if (this.data) {
            const /** @type {?} */ columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onPreviewFile(node) {
        if (node) {
            this.preview.emit(new NodeEntityEvent(node));
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        const /** @type {?} */ domEvent = new CustomEvent('node-click', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        const /** @type {?} */ event = new NodeEntityEvent(node);
        this.nodeClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.SINGLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeDblClick(node) {
        const /** @type {?} */ domEvent = new CustomEvent('node-dblclick', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        const /** @type {?} */ event = new NodeEntityEvent(node);
        this.nodeDblClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.DOUBLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNodeSelect(event) {
        this.selection = event.selection.map(entry => entry.node);
        const /** @type {?} */ domEvent = new CustomEvent('node-select', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNodeUnselect(event) {
        this.selection = event.selection.map(entry => entry.node);
        const /** @type {?} */ domEvent = new CustomEvent('node-unselect', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowContextMenu(event) {
        if (this.contextMenuActions) {
            let /** @type {?} */ args = event.value;
            let /** @type {?} */ node = ((args.row)).node;
            if (node) {
                args.actions = this.getContextActions(node) || [];
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        if (this.contentActions) {
            let /** @type {?} */ args = event.value;
            let /** @type {?} */ node = ((args.row)).node;
            if (node) {
                args.actions = this.getNodeActions(node) || [];
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        if (this.contentActions) {
            let /** @type {?} */ args = event.value;
            let /** @type {?} */ node = ((args.row)).node;
            let /** @type {?} */ action = ((args.action));
            this.executeContentAction(node, action);
        }
    }
    /**
     * @return {?}
     */
    enforceSingleClickNavigationForMobile() {
        if (this.isMobile()) {
            this.navigationMode = DocumentListComponent.SINGLE_CLICK_NAVIGATION;
        }
    }
    /**
     * @return {?}
     */
    getDefaultSorting() {
        let /** @type {?} */ defaultSorting;
        if (this.sorting) {
            const [key, direction] = this.sorting;
            defaultSorting = new DataSorting(key, direction);
        }
        return defaultSorting;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    canNavigateFolder(node) {
        if (this.isCustomSource(this.currentFolderId)) {
            return false;
        }
        if (node && node.entry && node.entry.isFolder) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} folderId
     * @return {?}
     */
    isCustomSource(folderId) {
        const /** @type {?} */ sources = ['-trashcan-', '-sharedlinks-', '-sites-', '-mysites-', '-favorites-', '-recent-'];
        if (sources.indexOf(folderId) > -1) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} permission
     * @return {?}
     */
    hasCurrentNodePermission(permission) {
        let /** @type {?} */ hasPermission = false;
        if (this.currentNodeAllowableOperations.length > 0) {
            let /** @type {?} */ permFound = this.currentNodeAllowableOperations.find(element => element === permission);
            hasPermission = permFound ? true : false;
        }
        return hasPermission;
    }
    /**
     * @return {?}
     */
    hasCreatePermission() {
        return this.hasCurrentNodePermission(this.CREATE_PERMISSION);
    }
    /**
     * @return {?}
     */
    loadLayoutPresets() {
        const /** @type {?} */ externalSettings = this.appConfig.get('document-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, presetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = presetsDefaultModel;
        }
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    getLayoutPreset(name = 'default') {
        return (this.layoutPresets[name] || this.layoutPresets['default']).map(col => new ObjectDataColumn(col));
    }
    /**
     * @param {?} page
     * @return {?}
     */
    onDataReady(page) {
        this.ready.emit(page);
        if (page && page.list && page.list.pagination) {
            this.pagination.next(page.list.pagination);
        }
        else {
            this.pagination.next(null);
        }
    }
    /**
     * @param {?} params
     * @return {?}
     */
    updatePagination(params) {
        const /** @type {?} */ needsReload = this.maxItems !== params.maxItems || this.skipCount !== params.skipCount;
        this.maxItems = params.maxItems;
        this.skipCount = params.skipCount;
        if (needsReload) {
            this.reload(this.enableInfiniteScrolling);
        }
    }
    /**
     * @return {?}
     */
    get supportedPageSizes() {
        return this.appConfig.get('document-list.supportedPageSizes', [5, 10, 15, 25]);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.contextActionHandlerSubscription) {
            this.contextActionHandlerSubscription.unsubscribe();
            this.contextActionHandlerSubscription = null;
        }
    }
}
DocumentListComponent.SINGLE_CLICK_NAVIGATION = 'click';
DocumentListComponent.DOUBLE_CLICK_NAVIGATION = 'dblclick';
DocumentListComponent.DEFAULT_PAGE_SIZE = 20;
DocumentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-document-list',
                styles: [`

    `],
                template: `
      <adf-datatable
          [selectionMode]="selectionMode"
          [data]="data"
          [actions]="contentActions"
          [actionsPosition]="contentActionsPosition"
          [multiselect]="multiselect"
          [allowDropFiles]="allowDropFiles"
          [contextMenu]="contextMenuActions"
          [rowStyle]="rowStyle"
          [rowStyleClass]="rowStyleClass"
          [loading]="loading"
          [noPermission]="noPermission"
          [showHeader]="!isEmpty()"
          (showRowContextMenu)="onShowRowContextMenu($event)"
          (showRowActionsMenu)="onShowRowActionsMenu($event)"
          (executeRowAction)="onExecuteRowAction($event)"
          (rowClick)="onNodeClick($event.value?.node)"
          (rowDblClick)="onNodeDblClick($event.value?.node)"
          (row-select)="onNodeSelect($event.detail)"
          (row-unselect)="onNodeUnselect($event.detail)">

          <div *ngIf="!isEmptyTemplateDefined()">
              <no-content-template>
                  <ng-template>
                      <adf-empty-list>
                          <div class="adf-empty-list_template adf-empty-folder">
                              <div class="adf-empty-folder-this-space-is-empty">{{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}}</div>
                              <div fxHide.lt-md="true" class="adf-empty-folder-drag-drop">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate }}</div>
                              <div fxHide.lt-md="true" class="adf-empty-folder-any-files-here-to-add">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.SUBTITLE' | translate }}</div>
                              <img class="adf-empty-folder-image" [src]="emptyFolderImageUrl">
                          </div>
                          <!-- <div adf-empty-list-header class="adf-empty-list-header"> {{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}} </div> -->
                      </adf-empty-list>
                  </ng-template>
              </no-content-template>
          </div>

          <div *ngIf="!isNoPermissionTemplateDefined()">
              <no-permission-template>
                  <ng-template>
                      <div class="adf-no-permission__template">
                          <mat-icon>ic_error</mat-icon>
                          <p class="adf-no-permission__template--text">{{ 'ADF-DOCUMENT-LIST.NO_PERMISSION' | translate }}</p>
                      </div>
                  </ng-template>
              </no-permission-template>
          </div>

          <div>
              <loading-content-template>
                  <ng-template>
                      <div class="adf-document-list-loading-container">
                          <mat-progress-spinner
                              id="adf-document-list-loading"
                              class="adf-document-list-loading-margin"
                              [color]="'primary'"
                              [mode]="'indeterminate'">
                          </mat-progress-spinner>
                      </div>
                  </ng-template>
              </loading-content-template>
          </div>
      </adf-datatable>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DocumentListComponent.ctorParameters = () => [
    { type: DocumentListService, },
    { type: NgZone, },
    { type: ElementRef, },
    { type: AlfrescoApiService, },
    { type: AppConfigService, },
    { type: UserPreferencesService, },
];
DocumentListComponent.propDecorators = {
    'columnList': [{ type: ContentChild, args: [DataColumnListComponent,] },],
    'permissionsStyle': [{ type: Input },],
    'locationFormat': [{ type: Input },],
    'navigate': [{ type: Input },],
    'navigationMode': [{ type: Input },],
    'thumbnails': [{ type: Input },],
    'selectionMode': [{ type: Input },],
    'multiselect': [{ type: Input },],
    'contentActions': [{ type: Input },],
    'contentActionsPosition': [{ type: Input },],
    'contextMenuActions': [{ type: Input },],
    'emptyFolderImageUrl': [{ type: Input },],
    'allowDropFiles': [{ type: Input },],
    'sorting': [{ type: Input },],
    'rowStyle': [{ type: Input },],
    'rowStyleClass': [{ type: Input },],
    'loading': [{ type: Input },],
    'rowFilter': [{ type: Input },],
    'imageResolver': [{ type: Input },],
    'currentFolderId': [{ type: Input },],
    'folderNode': [{ type: Input },],
    'node': [{ type: Input },],
    'maxItems': [{ type: Input },],
    'skipCount': [{ type: Input },],
    'enableInfiniteScrolling': [{ type: Input },],
    'nodeClick': [{ type: Output },],
    'nodeDblClick': [{ type: Output },],
    'folderChange': [{ type: Output },],
    'preview': [{ type: Output },],
    'ready': [{ type: Output },],
    'error': [{ type: Output },],
    'dataTable': [{ type: ViewChild, args: [DataTableComponent,] },],
    'onShowContextMenu': [{ type: HostListener, args: ['contextmenu', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class ContentActionListComponent {
    /**
     * @param {?} documentList
     */
    constructor(documentList) {
        this.documentList = documentList;
    }
    /**
     * Registers action handler within the parent document list component.
     * @param {?} action Action model to register.
     * @return {?}
     */
    registerAction(action) {
        if (this.documentList && action) {
            this.documentList.actions.push(action);
            return true;
        }
        return false;
    }
}
ContentActionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-actions',
                template: ''
            },] },
];
/**
 * @nocollapse
 */
ContentActionListComponent.ctorParameters = () => [
    { type: DocumentListComponent, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal service used by ContentNodeSelector component.
 */
class ContentNodeSelectorService {
    /**
     * @param {?} searchService
     */
    constructor(searchService) {
        this.searchService = searchService;
    }
    /**
     * Performs a search for content node selection
     *
     * @param {?} searchTerm    The term to search for
     * @param {?} rootNodeId    The root is to start the search from
     * @param {?=} skipCount     From where to start the loading
     * @param {?=} maxItems      How many items to load
     * @return {?}
     */
    search(searchTerm, rootNodeId, skipCount = 0, maxItems = 25) {
        let /** @type {?} */ defaultSearchNode = {
            query: {
                query: `${searchTerm}* OR name:${searchTerm}*`
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: `${maxItems}`,
                skipCount: `${skipCount}`
            },
            filterQueries: [
                { query: "TYPE:'cm:folder'" },
                { query: 'NOT cm:creator:System' }
            ]
        };
        if (rootNodeId) {
            defaultSearchNode.scope = rootNodeId;
        }
        return this.searchService.search(defaultSearchNode);
    }
}
ContentNodeSelectorService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ContentNodeSelectorService.ctorParameters = () => [
    { type: SearchService, },
];

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

// typeof any so that it we don't have to cast when comparing a result to the error object
var errorObject_1 = { e: {} };


var errorObject = {
	errorObject: errorObject_1
};

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject.errorObject.e = e;
        return errorObject.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
var tryCatch_2 = tryCatch;



var tryCatch_1 = {
	tryCatch: tryCatch_2
};

function isFunction(x) {
    return typeof x === 'function';
}
var isFunction_2 = isFunction;


var isFunction_1 = {
	isFunction: isFunction_2
};

var isArray_1 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });


var isArray = {
	isArray: isArray_1
};

function isObject(x) {
    return x != null && typeof x === 'object';
}
var isObject_2 = isObject;


var isObject_1 = {
	isObject: isObject_2
};

var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends$3(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
var UnsubscriptionError_2 = UnsubscriptionError;


var UnsubscriptionError_1 = {
	UnsubscriptionError: UnsubscriptionError_2
};

/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject.errorObject.e.errors) : [errorObject.errorObject.e]);
            }
        }
        if (isArray.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
var Subscription_2 = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}


var Subscription_1 = {
	Subscription: Subscription_2
};

var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};


var Observer = {
	empty: empty
};

// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof commonjsGlobal !== 'undefined' && commonjsGlobal;
var _root = __window || __global || __self;
var root_1 = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();


var root = {
	root: root_1
};

var rxSubscriber = createCommonjsModule(function (module, exports) {
var Symbol = root.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;

});

var rxSubscriber_1 = rxSubscriber.rxSubscriber;
var rxSubscriber_2 = rxSubscriber.$$rxSubscriber;

var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends$2(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
var Subscriber_2 = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends$2(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));


var Subscriber_1 = {
	Subscriber: Subscriber_2
};

var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends$1(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
var OuterSubscriber_2 = OuterSubscriber;


var OuterSubscriber_1 = {
	OuterSubscriber: OuterSubscriber_2
};

var isArrayLike_1 = (function (x) { return x && typeof x.length === 'number'; });


var isArrayLike = {
	isArrayLike: isArrayLike_1
};

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
var isPromise_2 = isPromise;


var isPromise_1 = {
	isPromise: isPromise_2
};

function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber.rxSubscriber]) {
            return nextOrObserver[rxSubscriber.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
var toSubscriber_2 = toSubscriber;


var toSubscriber_1 = {
	toSubscriber: toSubscriber_2
};

var observable = createCommonjsModule(function (module, exports) {
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;

});

var observable_1 = observable.getSymbolObservable;
var observable_2 = observable.observable;
var observable_3 = observable.$$observable;

/* tslint:disable:no-empty */
function noop() { }
var noop_2 = noop;


var noop_1 = {
	noop: noop_2
};

/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
var pipe_2 = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
var pipeFromArray_1 = pipeFromArray;


var pipe_1 = {
	pipe: pipe_2,
	pipeFromArray: pipeFromArray_1
};

/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable$2 = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable$$1(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable$$1.prototype.lift = function (operator) {
        var observable$$1 = new Observable$$1();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable$$1.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable$$1.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable$$1.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                PromiseCtor = root.root.Rx.config.Promise;
            }
            else if (root.root.Promise) {
                PromiseCtor = root.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable$$1.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable$$1.prototype[observable.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable$$1.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable$$1.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                PromiseCtor = root.root.Rx.config.Promise;
            }
            else if (root.root.Promise) {
                PromiseCtor = root.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable$$1.create = function (subscribe) {
        return new Observable$$1(subscribe);
    };
    return Observable$$1;
}());
var Observable_2 = Observable$2;


var Observable_1 = {
	Observable: Observable_2
};

var iterator = createCommonjsModule(function (module, exports) {
function symbolIteratorPonyfill(root$$2) {
    var Symbol = root$$2.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root$$2.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root$$2.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;

});

var iterator_1 = iterator.symbolIteratorPonyfill;
var iterator_2 = iterator.iterator;
var iterator_3 = iterator.$$iterator;

var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends$4(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
var InnerSubscriber_2 = InnerSubscriber;


var InnerSubscriber_1 = {
	InnerSubscriber: InnerSubscriber_2
};

function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator.iterator] === 'function') {
        var iterator$$1 = result[iterator.iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable.observable] === 'function') {
        var obs = result[observable.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
var subscribeToResult_2 = subscribeToResult;


var subscribeToResult_1 = {
	subscribeToResult: subscribeToResult_2
};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
            if (duration === errorObject.errorObject) {
                this.destination.error(errorObject.errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);
                if (innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$6 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends$6(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state$$1, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
var Action_2 = Action;


var Action_1 = {
	Action: Action_2
};

var __extends$5 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends$5(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state$$1, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state$$1;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state$$1, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state$$1, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state$$1, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state$$1);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
var AsyncAction_2 = AsyncAction;


var AsyncAction_1 = {
	AsyncAction: AsyncAction_2
};

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state$$1) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state$$1, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
var Scheduler_2 = Scheduler;


var Scheduler_1 = {
	Scheduler: Scheduler_2
};

var __extends$7 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var AsyncScheduler = (function (_super) {
    __extends$7(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
var AsyncScheduler_2 = AsyncScheduler;


var AsyncScheduler_1 = {
	AsyncScheduler: AsyncScheduler_2
};

/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
var async_1 = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


var async = {
	async: async_1
};

function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
var isNumeric_2 = isNumeric;



var isNumeric_1 = {
	isNumeric: isNumeric_2
};

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
var isScheduler_2 = isScheduler;


var isScheduler_1 = {
	isScheduler: isScheduler_2
};

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
var isDate_2 = isDate;


var isDate_1 = {
	isDate: isDate_2
};

var __extends$8 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends$8(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state$$1) {
        var index = state$$1.index, period = state$$1.period, subscriber = state$$1.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state$$1.index = index + 1;
        action.schedule(state$$1, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));

var __extends$9 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = (function (_super) {
    __extends$9(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        _super.call(this, destination);
        this.buffer = [];
        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$10 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = (function (_super) {
    __extends$10(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.buffer = [];
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSkipCountSubscriber = (function (_super) {
    __extends$10(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$11 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferTimeSubscriber = (function (_super) {
    __extends$11(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        _super.call(this, destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        var context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context = contexts[i];
            var buffer = context.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context = contexts.shift();
            destination.next(context.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state$$1) {
    var subscriber = state$$1.subscriber;
    var prevContext = state$$1.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state$$1.context = subscriber.openContext();
        state$$1.context.closeAction = this.schedule(state$$1, state$$1.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state$$1) {
    var bufferCreationInterval = state$$1.bufferCreationInterval, bufferTimeSpan = state$$1.bufferTimeSpan, subscriber = state$$1.subscriber, scheduler = state$$1.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state$$1, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

var __extends$12 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferToggleSubscriber = (function (_super) {
    __extends$12(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(subscribeToResult_1.subscribeToResult(this, openings));
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            this.destination.next(context.buffer);
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$13 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = (function (_super) {
    __extends$13(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject.errorObject) {
            this.error(errorObject.errorObject.e);
        }
        else {
            closingSubscription = new Subscription_1.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$14 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = (function (_super) {
    __extends$14(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$17 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends$17(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state$$1) {
        var done = state$$1.done, value = state$$1.value, subscriber = state$$1.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state$$1.done = true;
        this.schedule(state$$1);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
var ScalarObservable_2 = ScalarObservable;


var ScalarObservable_1 = {
	ScalarObservable: ScalarObservable_2
};

var __extends$18 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends$18(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
var EmptyObservable_2 = EmptyObservable;


var EmptyObservable_1 = {
	EmptyObservable: EmptyObservable_2
};

var __extends$16 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends$16(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state$$1) {
        var array = state$$1.array, index = state$$1.index, count = state$$1.count, subscriber = state$$1.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state$$1.index = index + 1;
        this.schedule(state$$1);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
var ArrayObservable_2 = ArrayObservable;


var ArrayObservable_1 = {
	ArrayObservable: ArrayObservable_2
};

var __extends$15 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var none = {};
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends$15(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$20 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends$20(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
var PromiseObservable_2 = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}


var PromiseObservable_1 = {
	PromiseObservable: PromiseObservable_2
};

var __extends$21 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends$21(IteratorObservable, _super);
    function IteratorObservable(iterator$$2, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator$$2 == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator$$2);
    }
    IteratorObservable.create = function (iterator$$2, scheduler) {
        return new IteratorObservable(iterator$$2, scheduler);
    };
    IteratorObservable.dispatch = function (state$$1) {
        var index = state$$1.index, hasError = state$$1.hasError, iterator$$2 = state$$1.iterator, subscriber = state$$1.subscriber;
        if (hasError) {
            subscriber.error(state$$1.error);
            return;
        }
        var result = iterator$$2.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state$$1.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator$$2.return === 'function') {
                iterator$$2.return();
            }
            return;
        }
        this.schedule(state$$1);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator$$2 = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator$$2, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator$$2.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator$$2.return === 'function') {
                        iterator$$2.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
var IteratorObservable_2 = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator.iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator.iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}


var IteratorObservable_1 = {
	IteratorObservable: IteratorObservable_2
};

var __extends$22 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends$22(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state$$1) {
        var arrayLike = state$$1.arrayLike, index = state$$1.index, length = state$$1.length, subscriber = state$$1.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state$$1.index = index + 1;
        this.schedule(state$$1);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
var ArrayLikeObservable_2 = ArrayLikeObservable;


var ArrayLikeObservable_1 = {
	ArrayLikeObservable: ArrayLikeObservable_2
};

/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
var Notification_2 = Notification;


var Notification_1 = {
	Notification: Notification_2
};

var __extends$23 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn$1(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var observeOn_2 = observeOn$1;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
var ObserveOnOperator_1 = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends$23(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
var ObserveOnSubscriber_1 = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
var ObserveOnMessage_1 = ObserveOnMessage;


var observeOn_1 = {
	observeOn: observeOn_2,
	ObserveOnOperator: ObserveOnOperator_1,
	ObserveOnSubscriber: ObserveOnSubscriber_1,
	ObserveOnMessage: ObserveOnMessage_1
};

var __extends$19 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};











/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends$19(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable.observable]().subscribe(subscriber);
        }
        else {
            return ish[observable.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));

var __extends$24 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = (function (_super) {
    __extends$24(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$25 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CountSubscriber = (function (_super) {
    __extends$25(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$26 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceSubscriber = (function (_super) {
    __extends$26(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
        this.durationSubscription = null;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult_1.subscribeToResult(this, duration);
        if (!subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$27 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime$1(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var debounceTime_2 = debounceTime$1;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends$27(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext$1(subscriber) {
    subscriber.debouncedNext();
}


var debounceTime_1 = {
	debounceTime: debounceTime_2
};

var __extends$28 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DefaultIfEmptySubscriber = (function (_super) {
    __extends$28(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        _super.call(this, destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));

var __extends$29 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends$29(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state$$1) {
        var source = state$$1.source;
        var queue = source.queue;
        var scheduler = state$$1.scheduler;
        var destination = state$$1.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state$$1, delay_1);
        }
        else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

var __extends$30 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelayWhenSubscriber = (function (_super) {
    __extends$30(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        _super.call(this, destination);
        this.delayDurationSelector = delayDurationSelector;
        this.completed = false;
        this.delayNotifierSubscriptions = [];
        this.values = [];
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        var value = null;
        if (subscriptionIdx !== -1) {
            value = this.values[subscriptionIdx];
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            this.values.splice(subscriptionIdx, 1);
        }
        return value;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            this.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
        this.values.push(value);
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelayObservable = (function (_super) {
    __extends$30(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        _super.call(this);
        this.source = source;
        this.subscriptionDelay = subscriptionDelay;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelaySubscriber = (function (_super) {
    __extends$30(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        _super.call(this);
        this.parent = parent;
        this.source = source;
        this.sourceSubscribed = false;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));

var __extends$31 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DeMaterializeSubscriber = (function (_super) {
    __extends$31(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));

function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return (function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }());
}
var minimalSetImpl_1 = minimalSetImpl;
var Set = root.root.Set || minimalSetImpl();


var _Set = {
	minimalSetImpl: minimalSetImpl_1,
	Set: Set
};

var __extends$32 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = (function (_super) {
    __extends$32(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new _Set.Set();
        if (flushes) {
            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$33 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends$33(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject.errorObject) {
                return this.destination.error(errorObject.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject.errorObject) {
                return this.destination.error(errorObject.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

var __extends$35 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = (function (_super) {
    __extends$35(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error));
var ArgumentOutOfRangeError_2 = ArgumentOutOfRangeError;


var ArgumentOutOfRangeError_1 = {
	ArgumentOutOfRangeError: ArgumentOutOfRangeError_2
};

var __extends$34 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ElementAtSubscriber = (function (_super) {
    __extends$34(ElementAtSubscriber, _super);
    function ElementAtSubscriber(destination, index, defaultValue) {
        _super.call(this, destination);
        this.index = index;
        this.defaultValue = defaultValue;
    }
    ElementAtSubscriber.prototype._next = function (x) {
        if (this.index-- === 0) {
            this.destination.next(x);
            this.destination.complete();
        }
    };
    ElementAtSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index >= 0) {
            if (typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
            }
            else {
                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
            }
        }
        destination.complete();
    };
    return ElementAtSubscriber;
}(Subscriber_1.Subscriber));

var __extends$36 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var EverySubscriber = (function (_super) {
    __extends$36(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
        this.index = 0;
        this.thisArg = thisArg || this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));

var __extends$37 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstSubscriber = (function (_super) {
    __extends$37(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        _super.call(this, destination);
        this.hasCompleted = false;
        this.hasSubscription = false;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$38 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = (function (_super) {
    __extends$38(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$39 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = (function (_super) {
    __extends$39(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        _super.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch_1.tryCatch(this.project)(value, index);
            if (result === errorObject.errorObject) {
                destination.error(errorObject.errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state$$1 = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state$$1));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$40 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends$40(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

var __extends$41 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends$41(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));

var __extends$42 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FindValueSubscriber = (function (_super) {
    __extends$42(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
        this.index = 0;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));

var __extends$44 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = (function (_super) {
    __extends$44(EmptyError, _super);
    function EmptyError() {
        var err = _super.call(this, 'no elements in sequence');
        this.name = err.name = 'EmptyError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return EmptyError;
}(Error));
var EmptyError_2 = EmptyError;


var EmptyError_1 = {
	EmptyError: EmptyError_2
};

var __extends$43 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FirstSubscriber = (function (_super) {
    __extends$43(FirstSubscriber, _super);
    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.index = 0;
        this.hasCompleted = false;
        this._emitted = false;
    }
    FirstSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._emit = function (value, index) {
        if (this.resultSelector) {
            this._tryResultSelector(value, index);
            return;
        }
        this._emitFinal(value);
    };
    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this._emitFinal(result);
    };
    FirstSubscriber.prototype._emitFinal = function (value) {
        var destination = this.destination;
        if (!this._emitted) {
            this._emitted = true;
            destination.next(value);
            destination.complete();
            this.hasCompleted = true;
        }
    };
    FirstSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
            destination.next(this.defaultValue);
            destination.complete();
        }
        else if (!this.hasCompleted) {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return FirstSubscriber;
}(Subscriber_1.Subscriber));

var __extends$47 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends$47(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
var ObjectUnsubscribedError_2 = ObjectUnsubscribedError;


var ObjectUnsubscribedError_1 = {
	ObjectUnsubscribedError: ObjectUnsubscribedError_2
};

var __extends$48 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends$48(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
var SubjectSubscription_2 = SubjectSubscription;


var SubjectSubscription_1 = {
	SubjectSubscription: SubjectSubscription_2
};

var __extends$46 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends$46(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
var SubjectSubscriber_1 = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject$2 = (function (_super) {
    __extends$46(Subject$$1, _super);
    function Subject$$1() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject$$1.prototype[rxSubscriber.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject$$1.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject$$1.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject$$1.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject$$1.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject$$1.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject$$1.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject$$1.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject$$1.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject$$1.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject$$1;
}(Observable_1.Observable));
var Subject_2 = Subject$2;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends$46(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject$2));
var AnonymousSubject_1 = AnonymousSubject;


var Subject_1 = {
	SubjectSubscriber: SubjectSubscriber_1,
	Subject: Subject_2,
	AnonymousSubject: AnonymousSubject_1
};

var MapPolyfill = (function () {
    function MapPolyfill() {
        this.size = 0;
        this._values = [];
        this._keys = [];
    }
    MapPolyfill.prototype.get = function (key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
    };
    MapPolyfill.prototype.set = function (key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.size++;
        }
        else {
            this._values[i] = value;
        }
        return this;
    };
    MapPolyfill.prototype.delete = function (key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
    };
    MapPolyfill.prototype.clear = function () {
        this._keys.length = 0;
        this._values.length = 0;
        this.size = 0;
    };
    MapPolyfill.prototype.forEach = function (cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
            cb.call(thisArg, this._values[i], this._keys[i]);
        }
    };
    return MapPolyfill;
}());
var MapPolyfill_2 = MapPolyfill;


var MapPolyfill_1 = {
	MapPolyfill: MapPolyfill_2
};

var Map = root.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();


var _Map = {
	Map: Map
};

var FastMap = (function () {
    function FastMap() {
        this.values = {};
    }
    FastMap.prototype.delete = function (key) {
        this.values[key] = null;
        return true;
    };
    FastMap.prototype.set = function (key, value) {
        this.values[key] = value;
        return this;
    };
    FastMap.prototype.get = function (key) {
        return this.values[key];
    };
    FastMap.prototype.forEach = function (cb, thisArg) {
        var values = this.values;
        for (var key in values) {
            if (values.hasOwnProperty(key) && values[key] !== null) {
                cb.call(thisArg, values[key], key);
            }
        }
    };
    FastMap.prototype.clear = function () {
        this.values = {};
    };
    return FastMap;
}());
var FastMap_2 = FastMap;


var FastMap_1 = {
	FastMap: FastMap_2
};

var __extends$45 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = (function (_super) {
    __extends$45(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
        this.groups = null;
        this.attemptedToUnsubscribe = false;
        this.count = 0;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new _Map.Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = (function (_super) {
    __extends$45(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        _super.call(this, group);
        this.key = key;
        this.group = group;
        this.parent = parent;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = (function (_super) {
    __extends$45(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        _super.call(this);
        this.key = key;
        this.groupSubject = groupSubject;
        this.refCountSubscription = refCountSubscription;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = (function (_super) {
    __extends$45(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        _super.call(this);
        this.parent = parent;
        parent.count++;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

var __extends$49 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = (function (_super) {
    __extends$49(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));

var __extends$50 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IsEmptySubscriber = (function (_super) {
    __extends$50(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        _super.call(this, destination);
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));

var __extends$51 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var LastSubscriber = (function (_super) {
    __extends$51(LastSubscriber, _super);
    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.hasValue = false;
        this.index = 0;
        if (typeof defaultValue !== 'undefined') {
            this.lastValue = defaultValue;
            this.hasValue = true;
        }
    }
    LastSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.lastValue = result;
        this.hasValue = true;
    };
    LastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.hasValue) {
            destination.next(this.lastValue);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return LastSubscriber;
}(Subscriber_1.Subscriber));

var __extends$52 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends$52(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

var __extends$53 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = (function (_super) {
    __extends$53(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));

var __extends$54 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MaterializeSubscriber = (function (_super) {
    __extends$54(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));

var __extends$55 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends$55(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

var __extends$56 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = (function (_super) {
    __extends$56(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));

var __extends$57 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapToSubscriber = (function (_super) {
    __extends$57(MergeMapToSubscriber, _super);
    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapToSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            this.active++;
            this._innerSub(ish, destination, resultSelector, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapToSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    MergeMapToSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$58 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeScanSubscriber = (function (_super) {
    __extends$58(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this.acc = acc;
        this.concurrent = concurrent;
        this.hasValue = false;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject.errorObject) {
                destination.error(errorObject.errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$60 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

function refCount$1() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator$1(source));
    };
}
var refCount_2 = refCount$1;
var RefCountOperator$1 = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber$1(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber$1 = (function (_super) {
    __extends$60(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));


var refCount_1 = {
	refCount: refCount_2
};

var __extends$59 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = (function (_super) {
    __extends$59(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
var ConnectableSubscriber = (function (_super) {
    __extends$59(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountSubscriber = (function (_super) {
    __extends$59(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$61 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var OnErrorResumeNextSubscriber = (function (_super) {
    __extends$61(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        _super.call(this, destination);
        this.destination = destination;
        this.nextSources = nextSources;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult_1.subscribeToResult(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$62 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends$62(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));

var __extends$63 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = (function (_super) {
    __extends$63(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));

var __extends$64 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * @class AsyncSubject<T>
 */
var AsyncSubject = (function (_super) {
    __extends$64(AsyncSubject, _super);
    function AsyncSubject() {
        _super.apply(this, arguments);
        this.value = null;
        this.hasNext = false;
        this.hasCompleted = false;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));

var __extends$66 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends$66(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state$$1, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state$$1, delay);
        }
        this.delay = delay;
        this.state = state$$1;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state$$1, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state$$1, delay) :
            this._execute(state$$1, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
var QueueAction_2 = QueueAction;


var QueueAction_1 = {
	QueueAction: QueueAction_2
};

var __extends$67 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var QueueScheduler = (function (_super) {
    __extends$67(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
var QueueScheduler_2 = QueueScheduler;


var QueueScheduler_1 = {
	QueueScheduler: QueueScheduler_2
};

/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
var queue_1 = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);


var queue = {
	queue: queue_1
};

var __extends$65 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends$65(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

var __extends$68 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = (function (_super) {
    __extends$68(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        _super.call(this, destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$69 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatSubscriber = (function (_super) {
    __extends$69(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));

var __extends$70 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatWhenSubscriber = (function (_super) {
    __extends$70(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
        this.sourceIsBeingSubscribedTo = true;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            else if (this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.notifications = null;
        this.retries = null;
        this.retriesSubscription = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this.notifications = notifications;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject.errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$71 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = (function (_super) {
    __extends$71(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));

var __extends$72 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = (function (_super) {
    __extends$72(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject.errorObject) {
                    return _super.prototype.error.call(this, errorObject.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$73 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = (function (_super) {
    __extends$73(SampleSubscriber, _super);
    function SampleSubscriber() {
        _super.apply(this, arguments);
        this.hasValue = false;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$74 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleTimeSubscriber = (function (_super) {
    __extends$74(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        _super.call(this, destination);
        this.period = period;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state$$1) {
    var subscriber = state$$1.subscriber, period = state$$1.period;
    subscriber.notifyNext();
    this.schedule(state$$1, period);
}

var __extends$75 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SequenceEqualSubscriber = (function (_super) {
    __extends$75(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        _super.call(this, destination);
        this.compareTo = compareTo;
        this.comparor = comparor;
        this._a = [];
        this._b = [];
        this._oneComplete = false;
        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch_1.tryCatch(comparor)(a, b);
                if (areEqual === errorObject.errorObject) {
                    this.destination.error(errorObject.errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends$75(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        _super.call(this, destination);
        this.parent = parent;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));

var __extends$76 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SingleSubscriber = (function (_super) {
    __extends$76(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));

var __extends$77 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends$77(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));

var __extends$78 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipLastSubscriber = (function (_super) {
    __extends$78(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        _super.call(this, destination);
        this._skipCount = _skipCount;
        this._count = 0;
        this._ring = new Array(_skipCount);
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));

var __extends$79 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends$79(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$80 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = (function (_super) {
    __extends$80(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));

var __extends$81 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends$81(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$82 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = (function (_super) {
    __extends$82(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$83 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends$83(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));

var __extends$84 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends$84(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$85 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = (function (_super) {
    __extends$85(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.index = 0;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));

var __extends$86 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends$86(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));

var throttle_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
 * to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasTrailingValue = false;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this._trailing) {
                this._hasTrailingValue = true;
                this._trailingValue = value;
            }
        }
        else {
            var duration = this.tryDurationSelector(value);
            if (duration) {
                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
            }
            if (this._leading) {
                this.destination.next(value);
                if (this._trailing) {
                    this._hasTrailingValue = true;
                    this._trailingValue = value;
                }
            }
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype._unsubscribe = function () {
        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
        this._trailingValue = null;
        this._hasTrailingValue = false;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype._sendTrailing = function () {
        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
        if (throttled && _trailing && _hasTrailingValue) {
            destination.next(_trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._sendTrailing();
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._sendTrailing();
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

});

var throttle_2 = throttle_1.defaultThrottleConfig;
var throttle_3 = throttle_1.throttle;

var __extends$87 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = (function (_super) {
    __extends$87(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$2, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext$2(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

var __extends$88 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeIntervalSubscriber = (function (_super) {
    __extends$88(TimeIntervalSubscriber, _super);
    function TimeIntervalSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.lastTime = 0;
        this.lastTime = scheduler.now();
    }
    TimeIntervalSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        var span = now - this.lastTime;
        this.lastTime = now;
        this.destination.next(new TimeInterval(value, span));
    };
    return TimeIntervalSubscriber;
}(Subscriber_1.Subscriber));

var __extends$90 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends$90(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));

var __extends$89 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends$89(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));

var __extends$91 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutWithSubscriber = (function (_super) {
    __extends$91(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$92 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends$92(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        _super.call(this, destination);
        this.window = new Subject_1.Subject();
        destination.next(this.window);
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$93 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowCountSubscriber = (function (_super) {
    __extends$93(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [new Subject_1.Subject()];
        this.count = 0;
        destination.next(this.windows[0]);
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));

var __extends$94 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var CountedSubject = (function (_super) {
    __extends$94(CountedSubject, _super);
    function CountedSubject() {
        _super.apply(this, arguments);
        this._numberOfNextedValues = 0;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = (function (_super) {
    __extends$94(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        var window = this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state$$1) {
    var subscriber = state$$1.subscriber, windowTimeSpan = state$$1.windowTimeSpan, window = state$$1.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state$$1.window = subscriber.openWindow();
    this.schedule(state$$1, windowTimeSpan);
}
function dispatchWindowCreation(state$$1) {
    var windowTimeSpan = state$$1.windowTimeSpan, subscriber = state$$1.subscriber, scheduler = state$$1.scheduler, windowCreationInterval = state$$1.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state$$1, windowCreationInterval);
}
function dispatchWindowClose(state$$1) {
    var subscriber = state$$1.subscriber, window = state$$1.window, context = state$$1.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

var __extends$95 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowToggleSubscriber = (function (_super) {
    __extends$95(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.error(err);
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.complete();
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.unsubscribe();
                context.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject.errorObject) {
                return this.error(errorObject.errorObject.e);
            }
            else {
                var window_1 = new Subject_1.Subject();
                var subscription = new Subscription_1.Subscription();
                var context = { window: window_1, subscription: subscription };
                this.contexts.push(context);
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$96 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber$1 = (function (_super) {
    __extends$96(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.closingSelector = closingSelector;
        this.openWindow();
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject.errorObject) {
            var err = errorObject.errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$97 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = (function (_super) {
    __extends$97(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

var __extends$98 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = (function (_super) {
    __extends$98(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) { values = Object.create(null); }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = (typeof project === 'function') ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$2 = iterators[i];
            if (iterator$$2.stillUnsubscribed) {
                this.add(iterator$$2.subscribe(iterator$$2, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator$$2 = iterators[i];
            if (typeof iterator$$2.hasValue === 'function' && !iterator$$2.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$2 = iterators[i];
            var result = iterator$$2.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator$$2.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
var StaticIterator = (function () {
    function StaticIterator(iterator$$2) {
        this.iterator = iterator$$2;
        this.nextResult = iterator$$2.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = (function (_super) {
    __extends$98(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));

var debounceTime = debounceTime_1.debounceTime;

var throttle = throttle_1.throttle;

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentNodeSelectorComponent {
    /**
     * @param {?} contentNodeSelectorService
     * @param {?} contentService
     * @param {?} apiService
     * @param {?} preferences
     * @param {?=} data
     * @param {?=} containingDialog
     */
    constructor(contentNodeSelectorService, contentService, apiService, preferences, data, containingDialog) {
        this.contentNodeSelectorService = contentNodeSelectorService;
        this.contentService = contentService;
        this.apiService = apiService;
        this.preferences = preferences;
        this.containingDialog = containingDialog;
        this.nodes = null;
        this.searchTerm = '';
        this.showingSearchResults = false;
        this.loadingSearchResults = false;
        this.inDialog = false;
        this.chosenNode = null;
        this.folderIdToShow = null;
        this.skipCount = 0;
        this.infiniteScroll = false;
        this.currentFolderId = null;
        this.dropdownHideMyFiles = false;
        this.dropdownSiteList = null;
        this.rowFilter = null;
        this.imageResolver = null;
        this.select = new EventEmitter();
        this.debounceSearch = 200;
        this.searchInput = new FormControl();
        if (data) {
            this.title = data.title;
            this.actionName = data.actionName;
            this.select = data.select;
            this.currentFolderId = data.currentFolderId;
            this.dropdownHideMyFiles = data.dropdownHideMyFiles;
            this.dropdownSiteList = data.dropdownSiteList;
            this.rowFilter = data.rowFilter;
            this.imageResolver = data.imageResolver;
        }
        this.buttonActionName = this.actionName ? `NODE_SELECTOR.${this.actionName.toUpperCase()}` : 'NODE_SELECTOR.CHOOSE';
        if (this.containingDialog) {
            this.inDialog = true;
        }
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((searchValue) => {
            this.search(searchValue);
        });
        this.pageSize = this.preferences.paginationSize;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.folderIdToShow = this.currentFolderId;
        this.paginationStrategy = PaginationStrategy.Infinite;
    }
    /**
     * Updates the site attribute and starts a new search
     *
     * @param {?} chosenSite Sitemodel to search within
     * @return {?}
     */
    siteChanged(chosenSite) {
        this.siteId = chosenSite.guid;
        this.updateResults();
    }
    /**
     * Updates the searchTerm attribute and starts a new search
     *
     * @param {?} searchTerm string value to search against
     * @return {?}
     */
    search(searchTerm) {
        this.searchTerm = searchTerm;
        this.updateResults();
    }
    /**
     * Returns whether breadcrumb has to be shown or not
     * @return {?}
     */
    needBreadcrumbs() {
        const /** @type {?} */ whenInFolderNavigation = !this.showingSearchResults, /** @type {?} */ whenInSelectingSearchResult = this.showingSearchResults && this.chosenNode;
        return whenInFolderNavigation || whenInSelectingSearchResult;
    }
    /**
     * Returns the actually selected|entered folder node or null in case of searching for the breadcrumb
     * @return {?}
     */
    get breadcrumbFolderNode() {
        if (this.showingSearchResults && this.chosenNode) {
            return this.chosenNode;
        }
        else {
            return this.documentList.folderNode;
        }
    }
    /**
     * Clear the search input
     * @return {?}
     */
    clear() {
        this.searchTerm = '';
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.showingSearchResults = false;
        this.folderIdToShow = this.currentFolderId;
    }
    /**
     * Update the result list depending on the criterias
     * @return {?}
     */
    updateResults() {
        if (this.searchTerm.length === 0) {
            this.folderIdToShow = this.siteId || this.currentFolderId;
        }
        else {
            this.startNewSearch();
        }
    }
    /**
     * Load the first page of a new search result
     * @return {?}
     */
    startNewSearch() {
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.folderIdToShow = null;
        this.querySearch();
    }
    /**
     * Loads the next batch of search results
     *
     * @param {?} event Pagination object
     * @return {?}
     */
    getNextPageOfSearch(event) {
        this.infiniteScroll = true;
        this.skipCount = event.skipCount;
        this.querySearch();
    }
    /**
     * Perform the call to searchService with the proper parameters
     * @return {?}
     */
    querySearch() {
        this.loadingSearchResults = true;
        this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.skipCount, this.pageSize)
            .subscribe(this.showSearchResults.bind(this));
    }
    /**
     * Show the results of the search
     *
     * @param {?} results Search results
     * @return {?}
     */
    showSearchResults(results) {
        this.showingSearchResults = true;
        this.loadingSearchResults = false;
        // Documentlist hack, since data displaying for preloaded nodes is a little bit messy there
        if (!this.nodes) {
            this.nodes = results;
        }
        else {
            this.documentList.data.loadPage(results, true);
        }
        this.pagination = results.list.pagination;
        this.highlight();
    }
    /**
     * Hightlight the actual searchterm in the next frame
     * @return {?}
     */
    highlight() {
        setTimeout(() => {
            this.highlighter.highlight(this.searchTerm);
        }, 0);
    }
    /**
     * Invoked when user selects a node
     *
     * @param {?} event CustomEvent for node-select
     * @return {?}
     */
    onNodeSelect(event) {
        this.attemptNodeSelection(event.detail.node.entry);
    }
    /**
     * Sets showingSearchResults state to be able to differentiate between search results or folder results
     * @return {?}
     */
    onFolderChange() {
        this.skipCount = 0;
        this.infiniteScroll = false;
        this.showingSearchResults = false;
    }
    /**
     * Attempts to set the currently loaded node
     * @param {?} nodePage
     * @return {?}
     */
    onFolderLoaded(nodePage) {
        this.attemptNodeSelection(this.documentList.folderNode);
        this.pagination = nodePage.list.pagination;
    }
    /**
     * Selects node as chosen if it has the right permission, clears the selection otherwise
     *
     * @param {?} entry
     * @return {?}
     */
    attemptNodeSelection(entry) {
        if (this.contentService.hasPermission(entry, 'create')) {
            this.chosenNode = entry;
        }
        else {
            this.resetChosenNode();
        }
    }
    /**
     * Clears the chosen node
     * @return {?}
     */
    resetChosenNode() {
        this.chosenNode = null;
    }
    /**
     * Emit event with the chosen node
     * @return {?}
     */
    choose() {
        const /** @type {?} */ entry = this.chosenNode;
        if (entry && entry.guid) {
            const /** @type {?} */ options = {
                include: ['path', 'properties', 'allowableOperations']
            };
            this.apiService.nodesApi.getNode(entry.guid, options)
                .then(chosenSiteNode => {
                this.select.next([chosenSiteNode.entry]);
            });
        }
        else {
            this.select.next([this.chosenNode]);
        }
    }
    /**
     * Close the dialog
     * @return {?}
     */
    close() {
        this.containingDialog.close();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onNodeDoubleClick(e) {
        const /** @type {?} */ node = e.detail.node.entry;
        if (node && node.guid) {
            const /** @type {?} */ options = {
                maxItems: this.pageSize,
                skipCount: this.skipCount,
                include: ['path', 'properties', 'allowableOperations']
            };
            this.apiService.nodesApi.getNode(node.guid, options)
                .then(documentLibrary => {
                this.documentList.performCustomSourceNavigation(documentLibrary);
            });
        }
    }
}
ContentNodeSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-node-selector',
                styles: [`

    `],
                template: `
      <header matDialogTitle
              class="adf-content-node-selector-title"
              data-automation-id="content-node-selector-title">{{title}}
      </header>

      <section matDialogContent
               class="adf-content-node-selector-content"
               (node-select)="onNodeSelect($event)">

          <mat-form-field floatPlaceholder="never" class="adf-content-node-selector-content-input">
              <input matInput
                     id="searchInput"
                     [formControl]="searchInput"
                     type="text"
                     placeholder="Search"
                     [value]="searchTerm"
                     data-automation-id="content-node-selector-search-input">

              <mat-icon *ngIf="searchTerm.length > 0"
                        matSuffix (click)="clear()"
                        class="adf-content-node-selector-content-input-icon"
                        data-automation-id="content-node-selector-search-clear">clear
              </mat-icon>

              <mat-icon *ngIf="searchTerm.length === 0"
                        matSuffix
                        class="adf-content-node-selector-content-input-icon"
                        data-automation-id="content-node-selector-search-icon">search
              </mat-icon>

          </mat-form-field>

          <adf-sites-dropdown
              (change)="siteChanged($event)"
              [placeholder]="'NODE_SELECTOR.SELECT_LOCATION'"
              [hideMyFiles]="dropdownHideMyFiles"
              [siteList]="dropdownSiteList"
              data-automation-id="content-node-selector-sites-combo"></adf-sites-dropdown>

          <adf-toolbar>
              <adf-toolbar-title>
                  <adf-dropdown-breadcrumb *ngIf="needBreadcrumbs()"
                                           class="adf-content-node-selector-content-breadcrumb"
                                           (navigate)="clear()"
                                           [target]="documentList"
                                           [folderNode]="breadcrumbFolderNode"
                                           data-automation-id="content-node-selector-content-breadcrumb">
                  </adf-dropdown-breadcrumb>
              </adf-toolbar-title>
          </adf-toolbar>

          <div class="adf-content-node-selector-content-list" data-automation-id="content-node-selector-content-list">
              <adf-document-list
                  #documentList
                  adf-highlight
                  adf-highlight-selector=".cell-value adf-datatable-cell .adf-datatable-cell-value"
                  [node]="nodes"
                  [maxItems]="pageSize"
                  [skipCount]="skipCount"
                  [enableInfiniteScrolling]="infiniteScroll"
                  [rowFilter]="rowFilter"
                  [imageResolver]="imageResolver"
                  [currentFolderId]="folderIdToShow"
                  selectionMode="single"
                  [contextMenuActions]="false"
                  [contentActions]="false"
                  [allowDropFiles]="false"
                  (folderChange)="onFolderChange()"
                  (ready)="onFolderLoaded($event)"
                  (node-dblclick)="onNodeDoubleClick($event)"
                  data-automation-id="content-node-selector-document-list">
                  <empty-folder-content>
                      <ng-template>
                          <div>{{ 'NODE_SELECTOR.NO_RESULTS' | translate }}</div>
                      </ng-template>
                  </empty-folder-content>
              </adf-document-list>

              <adf-infinite-pagination
                  [pagination]="pagination"
                  [pageSize]="pageSize"
                  [loading]="loadingSearchResults"
                  (loadMore)="getNextPageOfSearch($event)"
                  data-automation-id="content-node-selector-search-pagination">
                  {{ 'ADF-DOCUMENT-LIST.LAYOUT.LOAD_MORE' | translate }}
              </adf-infinite-pagination>
          </div>

      </section>

      <footer matDialogActions class="adf-content-node-selector-actions">

          <button *ngIf="inDialog"
                  mat-button
                  class="adf-content-node-selector-actions-cancel"
                  (click)="close()"
                  data-automation-id="content-node-selector-actions-cancel">{{ 'NODE_SELECTOR.CANCEL' | translate }}
          </button>

          <button mat-button
                  [disabled]="!chosenNode"
                  class="adf-content-node-selector-actions-choose"
                  (click)="choose()"
                  data-automation-id="content-node-selector-actions-choose">{{ buttonActionName | translate }}
          </button>

      </footer>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
ContentNodeSelectorComponent.ctorParameters = () => [
    { type: ContentNodeSelectorService, },
    { type: ContentService, },
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] },] },
    { type: MatDialogRef, decorators: [{ type: Optional },] },
];
ContentNodeSelectorComponent.propDecorators = {
    'title': [{ type: Input },],
    'actionName': [{ type: Input },],
    'currentFolderId': [{ type: Input },],
    'dropdownHideMyFiles': [{ type: Input },],
    'dropdownSiteList': [{ type: Input },],
    'rowFilter': [{ type: Input },],
    'imageResolver': [{ type: Input },],
    'pageSize': [{ type: Input },],
    'select': [{ type: Output },],
    'documentList': [{ type: ViewChild, args: [DocumentListComponent,] },],
    'highlighter': [{ type: ViewChild, args: [HighlightDirective,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeActionsService {
    /**
     * @param {?} dialog
     * @param {?=} documentListService
     * @param {?=} contentService
     */
    constructor(dialog, documentListService, contentService) {
        this.dialog = dialog;
        this.documentListService = documentListService;
        this.contentService = contentService;
    }
    /**
     * Copy content node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    copyContent(contentEntry, permission) {
        return this.doFileOperation('copy', 'content', contentEntry, permission);
    }
    /**
     * Copy folder node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    copyFolder(contentEntry, permission) {
        return this.doFileOperation('copy', 'folder', contentEntry, permission);
    }
    /**
     * Move content node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    moveContent(contentEntry, permission) {
        return this.doFileOperation('move', 'content', contentEntry, permission);
    }
    /**
     * Move folder node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    moveFolder(contentEntry, permission) {
        return this.doFileOperation('move', 'folder', contentEntry, permission);
    }
    /**
     * General method for performing the given operation (copy|move)
     *
     * @param {?} action the action to perform (copy|move)
     * @param {?} type type of the content (content|folder)
     * @param {?} contentEntry the contentEntry which has to have the action performed on
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    doFileOperation(action, type, contentEntry, permission) {
        const /** @type {?} */ observable = new Subject$1();
        if (this.contentService.hasPermission(contentEntry, permission)) {
            const /** @type {?} */ data = {
                title: `${action} '${contentEntry.name}' to ...`,
                actionName: action,
                currentFolderId: contentEntry.parentId,
                rowFilter: this.rowFilter.bind(this, contentEntry.id),
                imageResolver: this.imageResolver.bind(this),
                select: new EventEmitter()
            };
            this.dialog.open(ContentNodeSelectorComponent, { data, panelClass: 'adf-content-node-selector-dialog', width: '630px' });
            data.select.subscribe((selections) => {
                const /** @type {?} */ selection = selections[0];
                this.documentListService[`${action}Node`].call(this.documentListService, contentEntry.id, selection.id)
                    .subscribe(observable.next.bind(observable, `OPERATION.SUCCES.${type.toUpperCase()}.${action.toUpperCase()}`), observable.error.bind(observable));
                this.dialog.closeAll();
            });
            return observable;
        }
        else {
            observable.error(new Error(JSON.stringify({ error: { statusCode: 403 } })));
            return observable;
        }
    }
    /**
     * @param {?} currentNodeId
     * @param {?} row
     * @return {?}
     */
    rowFilter(currentNodeId, row) {
        const /** @type {?} */ node = row.node.entry;
        if (node.id === currentNodeId || node.isFile) {
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    imageResolver(row, col) {
        const /** @type {?} */ entry = row.node.entry;
        if (!this.contentService.hasPermission(entry, 'create')) {
            return this.documentListService.getMimeTypeIcon('disable/folder');
        }
        return null;
    }
}
NodeActionsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NodeActionsService.ctorParameters = () => [
    { type: MatDialog, },
    { type: DocumentListService, },
    { type: ContentService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentActionsService {
    /**
     * @param {?} nodeActionsService
     * @param {?=} documentListService
     * @param {?=} contentService
     */
    constructor(nodeActionsService, documentListService, contentService) {
        this.nodeActionsService = nodeActionsService;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.permissionEvent = new Subject$1();
        this.error = new Subject$1();
        this.success = new Subject$1();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getHandler(key) {
        if (key) {
            let /** @type {?} */ lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    }
    /**
     * @param {?} key
     * @param {?} handler
     * @return {?}
     */
    setHandler(key, handler) {
        if (key) {
            let /** @type {?} */ lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    canExecuteAction(obj) {
        return this.documentListService && obj && obj.entry.isFile === true;
    }
    /**
     * @return {?}
     */
    setupActionHandlers() {
        this.handlers['download'] = this.download.bind(this);
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    download(node) {
        if (this.canExecuteAction(node) && this.contentService) {
            let /** @type {?} */ link = document.createElement('a');
            document.body.appendChild(link);
            link.setAttribute('download', node.entry.name);
            link.href = this.contentService.getContentUrl(node);
            link.click();
            document.body.removeChild(link);
            return Observable$1.of(true);
        }
        return Observable$1.of(false);
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    copyNode(node, target, permission) {
        const /** @type {?} */ actionObservable = this.nodeActionsService.copyContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'copy', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    moveNode(node, target, permission) {
        const /** @type {?} */ actionObservable = this.nodeActionsService.moveContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'move', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((fileOperationMessage) => {
            if (target && typeof target.reload === 'function') {
                target.reload();
            }
            this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    deleteNode(node, target, permission) {
        let /** @type {?} */ handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasPermission(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe(() => {
                    if (target && typeof target.reload === 'function') {
                        target.reload();
                    }
                    this.success.next(node.entry.id);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({ type: 'content', action: 'delete', permission: permission }));
                return Observable$1.throw(new Error('No permission to delete'));
            }
        }
    }
}
DocumentActionsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
DocumentActionsService.ctorParameters = () => [
    { type: NodeActionsService, },
    { type: DocumentListService, },
    { type: ContentService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FolderActionsService {
    /**
     * @param {?} nodeActionsService
     * @param {?} documentListService
     * @param {?} contentService
     */
    constructor(nodeActionsService, documentListService, contentService) {
        this.nodeActionsService = nodeActionsService;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.permissionEvent = new Subject$1();
        this.error = new Subject$1();
        this.success = new Subject$1();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getHandler(key) {
        if (key) {
            let /** @type {?} */ lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    }
    /**
     * @param {?} key
     * @param {?} handler
     * @return {?}
     */
    setHandler(key, handler) {
        if (key) {
            let /** @type {?} */ lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    canExecuteAction(obj) {
        return this.documentListService && obj && obj.entry.isFolder === true;
    }
    /**
     * @return {?}
     */
    setupActionHandlers() {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
    }
    /**
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    copyNode(obj, target, permission) {
        const /** @type {?} */ actionObservable = this.nodeActionsService.copyFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'copy', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    moveNode(obj, target, permission) {
        const /** @type {?} */ actionObservable = this.nodeActionsService.moveFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'move', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((fileOperationMessage) => {
            if (target && typeof target.reload === 'function') {
                target.reload();
            }
            this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    }
    /**
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    deleteNode(obj, target, permission) {
        let /** @type {?} */ handlerObservable;
        if (this.canExecuteAction(obj)) {
            if (this.contentService.hasPermission(obj.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(obj.entry.id);
                handlerObservable.subscribe(() => {
                    if (target && typeof target.reload === 'function') {
                        target.reload();
                    }
                    this.success.next(obj.entry.id);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({ type: 'folder', action: 'delete', permission: permission }));
                return Observable$1.throw(new Error('No permission to delete'));
            }
        }
    }
}
FolderActionsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
FolderActionsService.ctorParameters = () => [
    { type: NodeActionsService, },
    { type: DocumentListService, },
    { type: ContentService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class ContentActionComponent {
    /**
     * @param {?} list
     * @param {?} documentActions
     * @param {?} folderActions
     */
    constructor(list, documentActions, folderActions) {
        this.list = list;
        this.documentActions = documentActions;
        this.folderActions = folderActions;
        this.title = 'Action';
        this.disabled = false;
        this.execute = new EventEmitter();
        this.permissionEvent = new EventEmitter();
        this.error = new EventEmitter();
        this.success = new EventEmitter();
        this.model = new ContentActionModel();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.model = new ContentActionModel({
            title: this.title,
            icon: this.icon,
            permission: this.permission,
            disableWithNoPermission: this.disableWithNoPermission,
            target: this.target,
            disabled: this.disabled
        });
        if (this.handler) {
            this.model.handler = this.getSystemHandler(this.target, this.handler);
        }
        if (this.execute) {
            this.model.execute = (value) => {
                this.execute.emit({ value });
            };
        }
        this.register();
    }
    /**
     * @return {?}
     */
    register() {
        if (this.list) {
            return this.list.registerAction(this.model);
        }
        return false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // update localizable properties
        this.model.title = this.title;
    }
    /**
     * @param {?} target
     * @param {?} name
     * @return {?}
     */
    getSystemHandler(target, name) {
        if (target) {
            let /** @type {?} */ ltarget = target.toLowerCase();
            if (ltarget === 'document') {
                if (this.documentActions) {
                    this.documentActions.permissionEvent.subscribe((permision) => {
                        this.permissionEvent.emit(permision);
                    });
                    this.documentActions.error.subscribe((errors) => {
                        this.error.emit(errors);
                    });
                    this.documentActions.success.subscribe((message) => {
                        this.success.emit(message);
                    });
                    return this.documentActions.getHandler(name);
                }
                return null;
            }
            if (ltarget === 'folder') {
                if (this.folderActions) {
                    this.folderActions.permissionEvent.subscribe((permision) => {
                        this.permissionEvent.emit(permision);
                    });
                    this.folderActions.error.subscribe((errors) => {
                        this.error.emit(errors);
                    });
                    this.folderActions.success.subscribe((message) => {
                        this.success.emit(message);
                    });
                    return this.folderActions.getHandler(name);
                }
                return null;
            }
        }
        return null;
    }
}
ContentActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-action',
                template: '',
                providers: [
                    DocumentActionsService,
                    FolderActionsService
                ]
            },] },
];
/**
 * @nocollapse
 */
ContentActionComponent.ctorParameters = () => [
    { type: ContentActionListComponent, },
    { type: DocumentActionsService, },
    { type: FolderActionsService, },
];
ContentActionComponent.propDecorators = {
    'title': [{ type: Input },],
    'icon': [{ type: Input },],
    'handler': [{ type: Input },],
    'target': [{ type: Input },],
    'permission': [{ type: Input },],
    'disableWithNoPermission': [{ type: Input },],
    'disabled': [{ type: Input },],
    'execute': [{ type: Output },],
    'permissionEvent': [{ type: Output },],
    'error': [{ type: Output },],
    'success': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentColumnListComponent {
    /**
     * @param {?} documentList
     * @param {?} logService
     */
    constructor(documentList, logService) {
        this.documentList = documentList;
        this.logService = logService;
        this.logService.log('ContentColumnListComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnListComponent instead.');
    }
    /**
     * Registers column model within the parent document list component.
     * @param {?} column Column definition model to register.
     * @return {?}
     */
    registerColumn(column) {
        if (this.documentList && column) {
            let /** @type {?} */ columns = this.documentList.data.getColumns();
            columns.push(column);
            return true;
        }
        return false;
    }
}
ContentColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-columns',
                template: ''
            },] },
];
/**
 * @nocollapse
 */
ContentColumnListComponent.ctorParameters = () => [
    { type: DocumentListComponent, },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentColumnComponent {
    /**
     * @param {?} list
     * @param {?} logService
     */
    constructor(list, logService) {
        this.list = list;
        this.logService = logService;
        this.type = 'text';
        this.sortable = false;
        this.title = '';
        this.logService.log('ContentColumnComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnComponent instead.');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.register();
    }
    /**
     * @return {?}
     */
    register() {
        if (this.list) {
            return this.list.registerColumn(this);
        }
        return false;
    }
}
ContentColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-column',
                template: ''
            },] },
];
/**
 * @nocollapse
 */
ContentColumnComponent.ctorParameters = () => [
    { type: ContentColumnListComponent, },
    { type: LogService, },
];
ContentColumnComponent.propDecorators = {
    'key': [{ type: Input },],
    'type': [{ type: Input },],
    'format': [{ type: Input },],
    'sortable': [{ type: Input },],
    'title': [{ type: Input },],
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
    'srTitle': [{ type: Input, args: ['sr-title',] },],
    'cssClass': [{ type: Input, args: ['class',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmptyFolderContentDirective {
    /**
     * @param {?} documentList
     */
    constructor(documentList) {
        this.documentList = documentList;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.documentList.emptyFolderTemplate = this.template;
        this.documentList.dataTable.noContentTemplate = this.template;
    }
}
EmptyFolderContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'empty-folder-content'
            },] },
];
/**
 * @nocollapse
 */
EmptyFolderContentDirective.ctorParameters = () => [
    { type: DocumentListComponent, },
];
EmptyFolderContentDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoPermissionContentDirective {
    /**
     * @param {?} documentList
     */
    constructor(documentList) {
        this.documentList = documentList;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.documentList.noPermissionTemplate = this.template;
        this.documentList.dataTable.noPermissionTemplate = this.template;
    }
}
NoPermissionContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-permission-content'
            },] },
];
/**
 * @nocollapse
 */
NoPermissionContentDirective.ctorParameters = () => [
    { type: DocumentListComponent, },
];
NoPermissionContentDirective.propDecorators = {
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentListModule {
}
DocumentListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ToolbarModule,
                    CommonModule,
                    DataTableModule,
                    FlexLayoutModule,
                    MaterialModule,
                    UploadModule,
                    TranslateModule,
                    PaginationModule
                ],
                declarations: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ],
                providers: [
                    DocumentListService,
                    FolderActionsService,
                    DocumentActionsService,
                    NodeActionsService
                ],
                exports: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ]
            },] },
];
/**
 * @nocollapse
 */
DocumentListModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SearchTriggerDirective),
    multi: true
};
class SearchTriggerDirective {
    /**
     * @param {?} element
     * @param {?} ngZone
     * @param {?} changeDetectorRef
     * @param {?} document
     */
    constructor(element, ngZone, changeDetectorRef, document) {
        this.element = element;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this._panelOpen = false;
        this.escapeEventStream = new Subject$1();
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.escapeEventStream) {
            this.escapeEventStream.unsubscribe();
            this.escapeEventStream = null;
        }
        if (this.closingActionsSubscription) {
            this.closingActionsSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen && this.searchPanel.showPanel;
    }
    /**
     * @return {?}
     */
    openPanel() {
        this.searchPanel.isOpen = this._panelOpen = true;
        this.closingActionsSubscription = this.subscribeToClosingActions();
    }
    /**
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this.closingActionsSubscription.unsubscribe();
            this._panelOpen = false;
            this.searchPanel.resetResults();
            this.searchPanel.hidePanel();
            this.changeDetectorRef.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    get panelClosingActions() {
        return merge$2(this.escapeEventStream, this.outsideClickStream);
    }
    /**
     * @return {?}
     */
    get outsideClickStream() {
        if (!this.document) {
            return Observable$1.of(null);
        }
        return merge$2(fromEvent$1(this.document, 'click'), fromEvent$1(this.document, 'touchend')).filter((event) => {
            const /** @type {?} */ clickTarget = (event.target);
            return this._panelOpen &&
                clickTarget !== this.element.nativeElement;
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        Promise.resolve(null).then(() => this.setTriggerValue(value));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        const /** @type {?} */ keyCode = event.keyCode;
        if (keyCode === ESCAPE && this.panelOpen) {
            this.escapeEventStream.next();
            event.stopPropagation();
        }
        else if (keyCode === ENTER) {
            this.escapeEventStream.next();
            event.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleInput(event) {
        if (document.activeElement === event.target) {
            let /** @type {?} */ inputValue = ((event.target)).value;
            this.onChange(inputValue);
            if (inputValue) {
                this.searchPanel.keyPressedStream.next(inputValue);
                this.openPanel();
            }
            else {
                this.searchPanel.resetResults();
                this.closePanel();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isPanelOptionClicked(event) {
        let /** @type {?} */ isPanelOption = false;
        if (event) {
            let /** @type {?} */ clickTarget = (event.target);
            isPanelOption = !this.isNoResultOption(event) &&
                !!this.searchPanel.panel &&
                !!this.searchPanel.panel.nativeElement.contains(clickTarget);
        }
        return isPanelOption;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isNoResultOption(event) {
        return this.searchPanel.results.list ? this.searchPanel.results.list.entries.length === 0 : true;
    }
    /**
     * @return {?}
     */
    subscribeToClosingActions() {
        const /** @type {?} */ firstStable = this.ngZone.onStable.asObservable();
        const /** @type {?} */ optionChanges = this.searchPanel.keyPressedStream.asObservable();
        return merge$2(firstStable, optionChanges)
            .switchMap(() => {
            this.searchPanel.setVisibility();
            return this.panelClosingActions;
        })
            .subscribe(event => this.setValueAndClose(event));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTriggerValue(value) {
        const /** @type {?} */ toDisplay = this.searchPanel && this.searchPanel.displayWith ?
            this.searchPanel.displayWith(value) : value;
        const /** @type {?} */ inputValue = toDisplay != null ? toDisplay : '';
        this.element.nativeElement.value = inputValue;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        if (this.isPanelOptionClicked(event)) {
            this.setTriggerValue(event.target.textContent.trim());
            this.onChange(event.target.textContent.trim());
            this.element.nativeElement.focus();
        }
        this.closePanel();
    }
}
SearchTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `input[searchAutocomplete], textarea[searchAutocomplete]`,
                host: {
                    'role': 'combobox',
                    'autocomplete': 'off',
                    'aria-autocomplete': 'list',
                    '[attr.aria-expanded]': 'panelOpen.toString()',
                    '[attr.aria-owns]': 'autocomplete?.id',
                    '(blur)': 'onTouched()',
                    '(input)': 'handleInput($event)',
                    '(keydown)': 'handleKeydown($event)'
                },
                providers: [SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR]
            },] },
];
/**
 * @nocollapse
 */
SearchTriggerDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
];
SearchTriggerDirective.propDecorators = {
    'searchPanel': [{ type: Input, args: ['searchAutocomplete',] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SearchComponent {
    /**
     * @param {?} searchService
     * @param {?} changeDetectorRef
     * @param {?} _elementRef
     */
    constructor(searchService, changeDetectorRef, _elementRef) {
        this.searchService = searchService;
        this.changeDetectorRef = changeDetectorRef;
        this._elementRef = _elementRef;
        this.displayWith = null;
        this.maxResults = 20;
        this.skipResults = 0;
        this.searchTerm = '';
        this.resultLoaded = new EventEmitter();
        this.error = new EventEmitter();
        this.showPanel = false;
        this._isOpen = false;
        this.keyPressedStream = new Subject$1();
        this._classList = {};
        this.keyPressedStream.asObservable()
            .debounceTime(200)
            .subscribe((searchedWord) => {
            this.loadSearchResults(searchedWord);
        });
    }
    /**
     * @param {?} classList
     * @return {?}
     */
    set classList(classList) {
        if (classList && classList.length) {
            classList.split(' ').forEach(className => this._classList[className.trim()] = true);
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen && this.showPanel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setVisibility();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.resetResults();
        if (changes.searchTerm && changes.searchTerm.currentValue) {
            this.loadSearchResults(changes.searchTerm.currentValue);
        }
        else if (changes.queryBody && changes.queryBody.currentValue) {
            this.loadSearchResults();
        }
        else {
            this.loadSearchResults(this.searchTerm);
        }
    }
    /**
     * @return {?}
     */
    resetResults() {
        this.cleanResults();
        this.setVisibility();
    }
    /**
     * @return {?}
     */
    reload() {
        this.loadSearchResults(this.searchTerm);
    }
    /**
     * @return {?}
     */
    cleanResults() {
        if (this.results) {
            this.results = {};
        }
    }
    /**
     * @param {?} searchOpts
     * @return {?}
     */
    hasValidSearchQuery(searchOpts) {
        return searchOpts && searchOpts.query && searchOpts.query.query;
    }
    /**
     * @param {?=} searchTerm
     * @return {?}
     */
    loadSearchResults(searchTerm) {
        let /** @type {?} */ searchOpts = this.getQueryBody(searchTerm);
        if (this.hasValidSearchQuery(searchOpts)) {
            this.searchService
                .search(searchOpts)
                .subscribe(results => {
                this.results = /** @type {?} */ (results);
                this.resultLoaded.emit(this.results);
                this.isOpen = true;
                this.setVisibility();
            }, error => {
                if (error.status !== 400) {
                    this.results = null;
                    this.error.emit(error);
                }
            });
        }
        else {
            this.cleanResults();
        }
    }
    /**
     * @param {?} searchTerm
     * @return {?}
     */
    getQueryBody(searchTerm) {
        if (this.queryBody) {
            if (!this.queryBody.query.query && searchTerm) {
                this.queryBody.query.query = searchTerm;
            }
            return this.queryBody;
        }
        else {
            return this.generateDefaultSearchNode(searchTerm);
        }
    }
    /**
     * @param {?} searchTerm
     * @return {?}
     */
    generateDefaultSearchNode(searchTerm) {
        let /** @type {?} */ defaultQueryBody = {
            query: {
                query: searchTerm ? `${searchTerm}* OR name:${searchTerm}*` : searchTerm
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: this.maxResults.toString(),
                skipCount: this.skipResults.toString()
            },
            filterQueries: [
                { query: "TYPE:'cm:folder' OR TYPE:'cm:content'" },
                { query: 'NOT cm:creator:System' }
            ]
        };
        return defaultQueryBody;
    }
    /**
     * @return {?}
     */
    hidePanel() {
        if (this.isOpen) {
            this._classList['adf-search-show'] = false;
            this._classList['adf-search-hide'] = true;
            this.isOpen = false;
            this.changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    setVisibility() {
        this.showPanel = !!this.results && !!this.results.list;
        this._classList['adf-search-show'] = this.showPanel;
        this._classList['adf-search-hide'] = !this.showPanel;
        this.changeDetectorRef.markForCheck();
    }
}
SearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search',
                template: `
      <div role="listbox" id="adf-search-results-content" [ngClass]="_classList" #panel>
          <ng-template
              [ngTemplateOutlet]="template"
              [ngTemplateOutletContext]="{ $implicit: results }">
          </ng-template>
      </div>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'searchAutocomplete',
                host: {
                    'class': 'adf-search'
                }
            },] },
];
/**
 * @nocollapse
 */
SearchComponent.ctorParameters = () => [
    { type: SearchService, },
    { type: ChangeDetectorRef, },
    { type: ElementRef, },
];
SearchComponent.propDecorators = {
    'panel': [{ type: ViewChild, args: ['panel',] },],
    'template': [{ type: ContentChild, args: [TemplateRef,] },],
    'displayWith': [{ type: Input },],
    'maxResults': [{ type: Input },],
    'skipResults': [{ type: Input },],
    'searchTerm': [{ type: Input },],
    'queryBody': [{ type: Input },],
    'classList': [{ type: Input, args: ['class',] },],
    'resultLoaded': [{ type: Output },],
    'error': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SearchControlComponent {
    /**
     * @param {?} authService
     * @param {?} thumbnailService
     */
    constructor(authService, thumbnailService) {
        this.authService = authService;
        this.thumbnailService = thumbnailService;
        this.expandable = true;
        this.highlight = false;
        this.inputType = 'text';
        this.autocomplete = false;
        this.liveSearchEnabled = true;
        this.liveSearchMaxResults = 5;
        this.submit = new EventEmitter();
        this.searchChange = new EventEmitter();
        this.optionClicked = new EventEmitter();
        this.searchTerm = '';
        this.toggleSearch = new Subject$1();
        this.focusSubject = new Subject$1();
        this.toggleSearch.asObservable().debounceTime(100).subscribe(() => {
            if (this.expandable) {
                this.subscriptAnimationState = this.subscriptAnimationState === 'inactive' ? 'active' : 'inactive';
                if (this.subscriptAnimationState === 'inactive') {
                    this.searchTerm = '';
                    this.searchAutocomplete.resetResults();
                    if (document.activeElement.id === this.searchInput.nativeElement.id) {
                        this.searchInput.nativeElement.blur();
                    }
                }
            }
        });
    }
    /**
     * @param {?} animationDoneEvent
     * @return {?}
     */
    applySearchFocus(animationDoneEvent) {
        if (animationDoneEvent.toState === 'active') {
            this.searchInput.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptAnimationState = this.expandable ? 'inactive' : 'no-animation';
        this.setupFocusEventHandlers();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.focusSubject) {
            this.focusSubject.unsubscribe();
            this.focusSubject = null;
        }
        if (this.toggleSearch) {
            this.toggleSearch.unsubscribe();
            this.toggleSearch = null;
        }
    }
    /**
     * @return {?}
     */
    isLoggedIn() {
        return this.authService.isEcmLoggedIn();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    searchSubmit(event) {
        this.submit.emit(event);
        this.toggleSearchBar();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    inputChange(event) {
        this.searchChange.emit(event);
    }
    /**
     * @return {?}
     */
    getAutoComplete() {
        return this.autocomplete ? 'on' : 'off';
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getMimeTypeIcon(node) {
        let /** @type {?} */ mimeType;
        if (node.entry.content && node.entry.content.mimeType) {
            mimeType = node.entry.content.mimeType;
        }
        if (node.entry.isFolder) {
            mimeType = 'folder';
        }
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * @return {?}
     */
    isSearchBarActive() {
        return this.subscriptAnimationState === 'active' && this.liveSearchEnabled;
    }
    /**
     * @return {?}
     */
    toggleSearchBar() {
        if (this.toggleSearch) {
            this.toggleSearch.next();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    elementClicked(item) {
        if (item.entry) {
            this.optionClicked.next(item);
            this.toggleSearchBar();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFocus($event) {
        this.focusSubject.next($event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onBlur($event) {
        this.focusSubject.next($event);
    }
    /**
     * @return {?}
     */
    activateToolbar() {
        if (!this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
    }
    /**
     * @return {?}
     */
    selectFirstResult() {
        if (this.listResultElement && this.listResultElement.length > 0) {
            let /** @type {?} */ firstElement = (this.listResultElement.first);
            firstElement._getHostElement().focus();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRowArrowDown($event) {
        let /** @type {?} */ nextElement = this.getNextElementSibling(/** @type {?} */ ($event.target));
        if (nextElement) {
            nextElement.focus();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRowArrowUp($event) {
        let /** @type {?} */ previousElement = this.getPreviousElementSibling(/** @type {?} */ ($event.target));
        if (previousElement) {
            previousElement.focus();
        }
        else {
            this.searchInput.nativeElement.focus();
            this.focusSubject.next(new FocusEvent('focus'));
        }
    }
    /**
     * @return {?}
     */
    setupFocusEventHandlers() {
        let /** @type {?} */ focusEvents = this.focusSubject.asObservable()
            .debounceTime(50);
        focusEvents.filter(($event) => {
            return this.isSearchBarActive() && ($event.type === 'blur' || $event.type === 'focusout');
        }).subscribe(() => {
            this.toggleSearchBar();
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNextElementSibling(node) {
        return node.nextElementSibling;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getPreviousElementSibling(node) {
        return node.previousElementSibling;
    }
}
SearchControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-control',
                template: `
      <div class="adf-search-container">
          <div *ngIf="isLoggedIn()" [@transitionMessages]="subscriptAnimationState" (@transitionMessages.done)="applySearchFocus($event)">
              <a mat-icon-button
                  *ngIf="expandable"
                  id="adf-search-button"
                  class="adf-search-button"
                  (click)="toggleSearchBar($event)"
                  (keyup.enter)="toggleSearchBar($event)">
                  <mat-icon aria-label="search button">search</mat-icon>
              </a>
              <mat-form-field class="adf-input-form-field-divider">
                  <input matInput #searchInput
                      [type]="inputType"
                      [autocomplete]="getAutoComplete()"
                      id="adf-control-input"
                      [(ngModel)]="searchTerm"
                      (focus)="activateToolbar($event)"
                      (blur)="onBlur($event)"
                      (keyup.escape)="toggleSearchBar()"
                      (keyup.arrowdown)="selectFirstResult()"
                      (ngModelChange)="inputChange($event)"
                      [searchAutocomplete]="auto"
                      (keyup.enter)="searchSubmit($event)">
              </mat-form-field>
          </div>
      </div>

      <adf-search #auto="searchAutocomplete"
                  class="adf-search-result-autocomplete"
                  [queryBody]="customQueryBody"
                  [maxResults]="liveSearchMaxResults">
          <ng-template let-data>
              <mat-list *ngIf="isSearchBarActive()" id="autocomplete-search-result-list">
                  <mat-list-item
                      *ngFor="let item of data?.list?.entries; let idx = index"
                      id="result_option_{{idx}}"
                      [tabindex]="0"
                      (focus)="onFocus($event)"
                      (blur)="onBlur($event)"
                      (keyup.arrowdown)="onRowArrowDown($event)"
                      (keyup.arrowup)="onRowArrowUp($event)"
                      class="adf-search-autocomplete-item"
                      (click)="elementClicked(item)"
                      (keyup.enter)="elementClicked(item)">
                      <mat-icon mat-list-icon>
                          <img [src]="getMimeTypeIcon(item)" />
                      </mat-icon>
                      <h4 mat-line id="result_name_{{idx}}"
                          *ngIf="highlight; else elseBlock"
                          class="adf-search-fixed-text"
                          [innerHtml]="item.entry.name | highlight: searchTerm">
                          {{ item?.entry.name }}
                      </h4>
                      <ng-template #elseBlock>
                          <h4 class="adf-search-fixed-text" mat-line id="result_name_{{idx}}" [innerHtml]="item.entry.name"></h4>
                      </ng-template>
                      <p mat-line class="adf-search-fixed-text"> {{item?.entry.createdByUser.displayName}} </p>
                  </mat-list-item>
                  <mat-list-item
                      id="search_no_result"
                      data-automation-id="search_no_result_found"
                      *ngIf="data?.list?.entries.length === 0">
                      <p mat-line class="adf-search-fixed-text">{{ 'SEARCH.RESULTS.NONE' | translate:{searchTerm: searchTerm} }}</p>
                  </mat-list-item>
              </mat-list>
          </ng-template>
      </adf-search>
    `,
                styles: [`

    `],
                animations: [
                    trigger('transitionMessages', [
                        state('active', style({ transform: 'translateX(0%)', 'margin-left': '13px' })),
                        state('inactive', style({ transform: 'translateX(81%)' })),
                        state('no-animation', style({ transform: 'translateX(0%)', width: '100%' })),
                        transition('inactive => active', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')),
                        transition('active => inactive', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                    ])
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-control' }
            },] },
];
/**
 * @nocollapse
 */
SearchControlComponent.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: ThumbnailService, },
];
SearchControlComponent.propDecorators = {
    'expandable': [{ type: Input },],
    'highlight': [{ type: Input },],
    'inputType': [{ type: Input },],
    'autocomplete': [{ type: Input },],
    'liveSearchEnabled': [{ type: Input },],
    'liveSearchMaxResults': [{ type: Input },],
    'customQueryBody': [{ type: Input },],
    'submit': [{ type: Output },],
    'searchChange': [{ type: Output },],
    'optionClicked': [{ type: Output },],
    'searchAutocomplete': [{ type: ViewChild, args: [SearchComponent,] },],
    'searchInput': [{ type: ViewChild, args: ['searchInput',] },],
    'listResultElement': [{ type: ViewChildren, args: [MatListItem,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ALFRESCO_SEARCH_DIRECTIVES = [
    SearchComponent,
    SearchControlComponent,
    SearchTriggerDirective
];
const ALFRESCO_SEARCH_PROVIDERS = [
    SearchService
];
class SearchModule {
}
SearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    PipeModule,
                    TranslateModule
                ],
                declarations: [
                    ...ALFRESCO_SEARCH_DIRECTIVES
                ],
                providers: [
                    ...ALFRESCO_SEARCH_PROVIDERS
                ],
                exports: [
                    ...ALFRESCO_SEARCH_DIRECTIVES
                ]
            },] },
];
/**
 * @nocollapse
 */
SearchModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DropdownSitesComponent {
    /**
     * @param {?} sitesService
     */
    constructor(sitesService) {
        this.sitesService = sitesService;
        this.hideMyFiles = false;
        this.siteList = null;
        this.placeholder = 'DROPDOWN.PLACEHOLDER_LABEL';
        this.change = new EventEmitter();
        this.MY_FILES_VALUE = 'default';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.siteList) {
            this.setDefaultSiteList();
        }
    }
    /**
     * @return {?}
     */
    selectedSite() {
        let /** @type {?} */ siteFound;
        if (this.siteSelected === this.MY_FILES_VALUE) {
            siteFound = new SiteModel();
        }
        else {
            siteFound = this.siteList.find(site => site.guid === this.siteSelected);
        }
        this.change.emit(siteFound);
    }
    /**
     * @return {?}
     */
    setDefaultSiteList() {
        this.siteList = [];
        this.sitesService.getSites().subscribe((result) => {
            this.siteList = result;
        }, (error) => { });
    }
}
DropdownSitesComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sites-dropdown',
                styles: [`

    `],
                template: `
      <div id="site-dropdown-container" class="adf-site-dropdown-container">
          <mat-form-field>
              <mat-select
                  class="adf-site-dropdown-list-element"
                  id="site-dropdown"
                  placeholder="{{placeholder | translate}}"
                  floatPlaceholder="never"
                  data-automation-id="site-my-files-select"
                  [(ngModel)]="siteSelected"
                  (ngModelChange)="selectedSite()">
                  <mat-option *ngIf="!hideMyFiles" data-automation-id="site-my-files-option" id="default_site_option" [value]="MY_FILES_VALUE">{{'DROPDOWN.MY_FILES_OPTION' | translate}}</mat-option>
                  <mat-option *ngFor="let site of siteList" [value]="site.guid">
                      {{ site.title | translate }}
                  </mat-option>
              </mat-select>
          </mat-form-field>
      </div>
    `
            },] },
];
/**
 * @nocollapse
 */
DropdownSitesComponent.ctorParameters = () => [
    { type: SitesService, },
];
DropdownSitesComponent.propDecorators = {
    'hideMyFiles': [{ type: Input },],
    'siteList': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'change': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SitesDropdownModule {
}
SitesDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                exports: [
                    DropdownSitesComponent
                ],
                declarations: [
                    DropdownSitesComponent
                ],
                providers: []
            },] },
];
/**
 * @nocollapse
 */
SitesDropdownModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BreadcrumbComponent {
    constructor() {
        this.folderNode = null;
        this.root = null;
        this.rootId = null;
        this.route = [];
        this.navigate = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get hasRoot() {
        return !!this.root;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.folderNode) {
            const /** @type {?} */ node = changes.folderNode.currentValue;
            this.route = this.parseRoute(node);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    parseRoute(node) {
        if (node && node.path) {
            const /** @type {?} */ route = ((node.path.elements || []).slice());
            route.push(/** @type {?} */ ({
                id: node.id,
                name: node.name
            }));
            const /** @type {?} */ rootPos = this.getElementPosition(route, this.rootId);
            if (rootPos > 0) {
                route.splice(0, rootPos);
            }
            if (rootPos === -1 && this.rootId) {
                route[0].id = this.rootId;
            }
            if (this.root) {
                route[0].name = this.root;
            }
            return route;
        }
        return [];
    }
    /**
     * @param {?} route
     * @param {?} nodeId
     * @return {?}
     */
    getElementPosition(route, nodeId) {
        let /** @type {?} */ result = -1;
        if (route && route.length > 0 && nodeId) {
            result = route.findIndex(el => el.id === nodeId);
        }
        return result;
    }
    /**
     * @param {?} route
     * @param {?=} event
     * @return {?}
     */
    onRoutePathClick(route, event) {
        if (event) {
            event.preventDefault();
        }
        if (route) {
            this.navigate.emit(route);
            if (this.target) {
                this.target.loadFolderByNodeId(route.id);
            }
        }
    }
}
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-breadcrumb',
                template: `
      <div *ngIf="folderNode" data-automation-id="breadcrumb" class="adf-breadcrumb-container">
          <li *ngFor="let item of route; let last = last"
              [class.active]="last"
              [ngSwitch]="last"
              title="{{ item.name | translate }}"
              class="adf-breadcrumb-item">

              <a *ngSwitchDefault href="#" [attr.data-automation-id]="'breadcrumb_' + item.name"
                 class="adf-breadcrumb-item-anchor"
                 (click)="onRoutePathClick(item, $event)">
                  {{ item.name | translate }}
              </a>

              <div *ngSwitchCase="true" class="adf-breadcrumb-item-current">
                  {{ item.name | translate }}
              </div>

              <mat-icon class="adf-breadcrumb-item-chevron" *ngIf="!last">
                  chevron_right
              </mat-icon>
          </li>
      </div>
      <div *ngIf="!folderNode && hasRoot">
          <li class="adf-breadcrumb-item">
              <div class="adf-breadcrumb-item-current">
                  {{ root | translate }}
              </div>
          </li>
      </div>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-breadcrumb'
                }
            },] },
];
/**
 * @nocollapse
 */
BreadcrumbComponent.ctorParameters = () => [];
BreadcrumbComponent.propDecorators = {
    'folderNode': [{ type: Input },],
    'root': [{ type: Input },],
    'rootId': [{ type: Input },],
    'target': [{ type: Input },],
    'navigate': [{ type: Output },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DropdownBreadcrumbComponent extends BreadcrumbComponent {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        this.recalculateNodes();
    }
    /**
     * Calculate the current and previous nodes from the route array
     * @return {?}
     */
    recalculateNodes() {
        this.currentNode = this.route[this.route.length - 1];
        this.previousNodes = this.route.slice(0, this.route.length - 1).reverse();
    }
    /**
     * Opens the selectbox overlay
     * @return {?}
     */
    open() {
        if (this.selectbox) {
            this.selectbox.open();
        }
    }
    /**
     * Return if route has more than one element (means: we are not in the root directory)
     * @return {?}
     */
    hasPreviousNodes() {
        return this.previousNodes.length > 0;
    }
}
DropdownBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-breadcrumb',
                template: `
      <ng-container *ngIf="route.length > 0">

          <button
              tabindex="0"
              class="adf-dropdown-breadcumb-trigger"
              (click)="open()"
              data-automation-id="dropdown-breadcrumb-trigger">
              <mat-icon [class.isRoot]="!hasPreviousNodes()">folder</mat-icon>
          </button>
          <mat-icon class="adf-dropddown-breadcrumb-item-chevron">chevron_right</mat-icon>

          <mat-select
              *ngIf="hasPreviousNodes()"
              class="adf-dropdown-breadcrumb-path"
              tabindex="0"
              data-automation-id="dropdown-breadcrumb-path" >

              <mat-option
                  *ngFor="let node of previousNodes;"
                  (click)="onRoutePathClick(node, $event)"
                  class="adf-dropdown-breadcrumb-path-option"
                  tabindex="0"
                  data-automation-class="dropdown-breadcrumb-path-option">
                  {{ node.name }}
              </mat-option>
          </mat-select>

          <span
              class="adf-current-folder"
              [class.isRoot]="!hasPreviousNodes()"
              data-automation-id="current-folder">{{ currentNode.name }}</span>
      </ng-container>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-dropdown-breadcrumb'
                }
            },] },
];
/**
 * @nocollapse
 */
DropdownBreadcrumbComponent.ctorParameters = () => [];
DropdownBreadcrumbComponent.propDecorators = {
    'selectbox': [{ type: ViewChild, args: [MatSelect,] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BreadcrumbModule {
}
BreadcrumbModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                exports: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ],
                declarations: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
BreadcrumbModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VersionUploadComponent {
}
VersionUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-upload',
                template: `
      <adf-upload-button
          data-automation-id="adf-new-version-file-upload"
          class="adf-new-version-file-upload"
          staticTitle="Upload new version"
          [rootFolderId]="node.parentId"
          tooltip="Restriction: upload file with the same name to create a new version of it"
          [versioning]="true">
      </adf-upload-button>
    `,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-version-upload'
                }
            },] },
];
/**
 * @nocollapse
 */
VersionUploadComponent.ctorParameters = () => [];
VersionUploadComponent.propDecorators = {
    'node': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VersionManagerComponent {
}
VersionManagerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-manager',
                template: `
      <div class="adf-new-version-uploader-container" fxLayout="row" fxLayoutAlign="end center">
          <adf-version-upload [node]="node"></adf-version-upload>
      </div>
      <div class="adf-version-list-container">
          <adf-version-list [id]="node.id"></adf-version-list>
      </div>
    `,
                styles: [`
      .adf-button.upload-new-version {
        -webkit-box-shadow: none;
                box-shadow: none; }

      .adf-new-version-uploader-container {
        border-bottom: 1px solid #d8d8d8;
        padding: 16px 0; }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
VersionManagerComponent.ctorParameters = () => [];
VersionManagerComponent.propDecorators = {
    'node': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VersionListComponent {
    /**
     * @param {?} alfrescoApi
     */
    constructor(alfrescoApi) {
        this.alfrescoApi = alfrescoApi;
        this.versions = [];
        this.isLoading = true;
        this.versionsApi = this.alfrescoApi.versionsApi;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.loadVersionHistory();
    }
    /**
     * @param {?} versionId
     * @return {?}
     */
    restore(versionId) {
        this.versionsApi
            .revertVersion(this.id, versionId, { majorVersion: true, comment: '' })
            .then(this.loadVersionHistory.bind(this));
    }
    /**
     * @return {?}
     */
    loadVersionHistory() {
        this.isLoading = true;
        this.versionsApi.listVersionHistory(this.id).then((data) => {
            this.versions = data.list.entries;
            this.isLoading = false;
        });
    }
}
VersionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-list',
                template: `
      <mat-list class="adf-version-list" *ngIf="!isLoading; else loading_template">
          <mat-list-item *ngFor="let version of versions">
              <mat-icon mat-list-icon>insert_drive_file</mat-icon>
              <h4 mat-line class="adf-version-list-item-name">{{version.entry.name}}</h4>
              <p mat-line>
                  <span class="adf-version-list-item-version">{{version.entry.id}}</span> -
                  <span class="adf-version-list-item-date">{{version.entry.modifiedAt | date}}</span>
              </p>
              <p mat-line class="adf-version-list-item-comment">{{version.entry.versionComment}}</p>

              <mat-menu #versionMenu="matMenu" yPosition="below" xPosition="before">
                  <button mat-menu-item (click)="restore(version.entry.id)"> Restore </button>
              </mat-menu>

              <button mat-icon-button [matMenuTriggerFor]="versionMenu">
                  <mat-icon>more_vert</mat-icon>
              </button>
          </mat-list-item>
      </mat-list>

      <ng-template #loading_template>
          <mat-progress-bar data-automation-id="version-history-loading-bar" mode="indeterminate" color="accent"></mat-progress-bar>
      </ng-template>
    `,
                styles: [`
      .adf-version-list .mat-list-item {
        border-bottom: 1px solid #d8d8d8; }

      .adf-version-list-item-version {
        font-weight: bold; }

      .adf-version-list-item-date {
        opacity: 0.6; }

      .adf-version-list-item-comment {
        opacity: 0.5; }
    `],
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-version-list'
                }
            },] },
];
/**
 * @nocollapse
 */
VersionListComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
];
VersionListComponent.propDecorators = {
    'id': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VersionManagerModule {
}
VersionManagerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    UploadModule
                ],
                exports: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ],
                declarations: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ],
                providers: []
            },] },
];
/**
 * @nocollapse
 */
VersionManagerModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentNodeSelectorModule {
}
ContentNodeSelectorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    DirectiveModule,
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ToolbarModule,
                    DocumentListModule,
                    PaginationModule
                ],
                exports: [
                    ContentNodeSelectorComponent
                ],
                entryComponents: [
                    ContentNodeSelectorComponent
                ],
                declarations: [
                    ContentNodeSelectorComponent
                ],
                providers: [
                    ContentNodeSelectorService
                ]
            },] },
];
/**
 * @nocollapse
 */
ContentNodeSelectorModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DownloadZipDialogComponent {
    /**
     * @param {?} apiService
     * @param {?} dialogRef
     * @param {?} data
     * @param {?} logService
     */
    constructor(apiService, dialogRef, data, logService) {
        this.apiService = apiService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.logService = logService;
        this.cancelled = false;
    }
    /**
     * @return {?}
     */
    get downloadsApi() {
        return this.apiService.getInstance().core.downloadsApi;
    }
    /**
     * @return {?}
     */
    get nodesApi() {
        return this.apiService.getInstance().core.nodesApi;
    }
    /**
     * @return {?}
     */
    get contentApi() {
        return this.apiService.getInstance().content;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.data && this.data.nodeIds && this.data.nodeIds.length > 0) {
            // change timeout to have a delay for demo purposes
            setTimeout(() => {
                if (!this.cancelled) {
                    this.downloadZip(this.data.nodeIds);
                }
                else {
                    this.logService.log('Cancelled');
                }
            }, 0);
        }
    }
    /**
     * @return {?}
     */
    cancelDownload() {
        this.cancelled = true;
        this.dialogRef.close(false);
    }
    /**
     * @param {?} nodeIds
     * @return {?}
     */
    downloadZip(nodeIds) {
        if (nodeIds && nodeIds.length > 0) {
            const /** @type {?} */ promise = this.downloadsApi.createDownload({ nodeIds });
            promise.on('progress', progress => this.logService.log('Progress', progress));
            promise.on('error', error => this.logService.error('Error', error));
            promise.on('abort', data => this.logService.log('Abort', data));
            promise.on('success', (data) => {
                if (data && data.entry && data.entry.id) {
                    const /** @type {?} */ url = this.contentApi.getContentUrl(data.entry.id, true);
                    // the call is needed only to get the name of the package
                    this.nodesApi.getNode(data.entry.id).then((downloadNode) => {
                        this.logService.log(downloadNode);
                        const /** @type {?} */ fileName = downloadNode.entry.name;
                        this.waitAndDownload(data.entry.id, url, fileName);
                    });
                }
            });
        }
    }
    /**
     * @param {?} downloadId
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    waitAndDownload(downloadId, url, fileName) {
        if (this.cancelled) {
            return;
        }
        this.downloadsApi.getDownload(downloadId).then((d) => {
            if (d.entry) {
                if (d.entry.status === 'DONE') {
                    this.download(url, fileName);
                }
                else {
                    setTimeout(() => {
                        this.waitAndDownload(downloadId, url, fileName);
                    }, 1000);
                }
            }
        });
    }
    /**
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    download(url, fileName) {
        if (url && fileName) {
            const /** @type {?} */ link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        this.dialogRef.close(true);
    }
}
DownloadZipDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-download-zip-dialog',
                template: `
      <h1 matDialogTitle>{{ 'CORE.DIALOG.DOWNLOAD_ZIP.TITLE' | translate }}</h1>
      <div mat-dialog-content>
          <mat-progress-bar color="primary" mode="indeterminate"></mat-progress-bar>
      </div>
      <div mat-dialog-actions>
          <span class="spacer"></span>
          <button mat-button color="primary" (click)="cancelDownload()">
              {{ 'CORE.DIALOG.DOWNLOAD_ZIP.ACTIONS.CANCEL' | translate }}
          </button>
      </div>
    `,
                styles: [`
      .spacer {
        -webkit-box-flex: 1;
            -ms-flex: 1 1 auto;
                flex: 1 1 auto; }

      .adf-download-zip-dialog .mat-dialog-actions .mat-button-wrapper {
        text-transform: uppercase; }
    `],
                host: { 'class': 'adf-download-zip-dialog' },
                encapsulation: ViewEncapsulation.None
            },] },
];
/**
 * @nocollapse
 */
DownloadZipDialogComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: MatDialogRef, },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] },] },
    { type: LogService, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const I18N_ERRORS_PATH = 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS';
/**
 * @param {?} __0
 * @return {?}
 */
function forbidSpecialCharacters({ value }) {
    const /** @type {?} */ specialCharacters = /([\*\"\<\>\\\/\?\:\|])/;
    const /** @type {?} */ isValid = !specialCharacters.test(value);
    return (isValid) ? null : {
        message: `${I18N_ERRORS_PATH}.SPECIAL_CHARACTERS`
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidEndingDot({ value }) {
    const /** @type {?} */ isValid = ((value || '').trim().split('').pop() !== '.');
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ENDING_DOT`
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidOnlySpaces({ value }) {
    const /** @type {?} */ isValid = !!((value || '')).trim();
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ONLY_SPACES`
    };
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FolderDialogComponent {
    /**
     * @param {?} formBuilder
     * @param {?} dialog
     * @param {?} nodesApi
     * @param {?} translation
     * @param {?} notification
     * @param {?} data
     */
    constructor(formBuilder, dialog, nodesApi, translation, notification, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.nodesApi = nodesApi;
        this.translation = translation;
        this.notification = notification;
        this.data = data;
        this.folder = null;
    }
    /**
     * @return {?}
     */
    get editing() {
        return !!this.data.folder;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const { folder } = this.data;
        let /** @type {?} */ name = '';
        let /** @type {?} */ description = '';
        if (folder) {
            const { properties } = folder;
            name = folder.name || '';
            description = properties ? properties['cm:description'] : '';
        }
        const /** @type {?} */ validators = {
            name: [
                Validators.required,
                forbidSpecialCharacters,
                forbidEndingDot,
                forbidOnlySpaces
            ]
        };
        this.form = this.formBuilder.group({
            name: [name, validators.name],
            description: [description]
        });
    }
    /**
     * @return {?}
     */
    get name() {
        let { name } = this.form.value;
        return (name || '').trim();
    }
    /**
     * @return {?}
     */
    get description() {
        let { description } = this.form.value;
        return (description || '').trim();
    }
    /**
     * @return {?}
     */
    get properties() {
        const { name: title, description } = this;
        return {
            'cm:title': title,
            'cm:description': description
        };
    }
    /**
     * @return {?}
     */
    create() {
        const { name, properties, nodesApi, data: { parentNodeId } } = this;
        return nodesApi.createFolder(parentNodeId, { name, properties });
    }
    /**
     * @return {?}
     */
    edit() {
        const { name, properties, nodesApi, data: { folder: { id: nodeId } } } = this;
        return nodesApi.updateNode(nodeId, { name, properties });
    }
    /**
     * @return {?}
     */
    submit() {
        const { form, dialog, editing } = this;
        if (!form.valid) {
            return;
        }
        (editing ? this.edit() : this.create())
            .subscribe((folder) => dialog.close(folder), (error) => this.handleError(error));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        let /** @type {?} */ i18nMessageString = 'CORE.MESSAGES.ERRORS.GENERIC';
        try {
            const { error: { statusCode } } = JSON.parse(error.message);
            if (statusCode === 409) {
                i18nMessageString = 'CORE.MESSAGES.ERRORS.EXISTENT_FOLDER';
            }
        }
        catch (err) { }
        this.translation.get(i18nMessageString).subscribe(message => {
            this.notification.openSnackMessage(message, 3000);
        });
        return error;
    }
}
FolderDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-folder-dialog',
                styles: [`
      .adf-fill-remaining-space {
        -webkit-box-flex: 1;
            -ms-flex: 1 1 auto;
                flex: 1 1 auto; }

      .adf-full-width {
        width: 100%; }
    `],
                template: `
      <h2 mat-dialog-title>
          {{
          (editing
          ? 'CORE.FOLDER_DIALOG.EDIT_FOLDER_TITLE'
          : 'CORE.FOLDER_DIALOG.CREATE_FOLDER_TITLE'
          ) | translate
          }}
      </h2>

      <mat-dialog-content>
          <form [formGroup]="form" (submit)="submit()">
              <mat-input-container class="adf-full-width">
                  <input
                      placeholder="{{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.LABEL' | translate }}"
                      matInput
                      required
                      [formControl]="form.controls['name']"
                  />

                  <mat-hint *ngIf="form.controls['name'].dirty">
                      <span *ngIf="form.controls['name'].errors?.required">
                          {{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS.REQUIRED' | translate }}
                      </span>

                      <span *ngIf="!form.controls['name'].errors?.required && form.controls['name'].errors?.message">
                          {{ form.controls['name'].errors?.message | translate }}
                      </span>
                  </mat-hint>
              </mat-input-container>

              <br />
              <br />

              <mat-input-container class="adf-full-width">
                  <textarea
                      matInput
                      placeholder="{{ 'CORE.FOLDER_DIALOG.FOLDER_DESCRIPTION.LABEL' | translate }}"
                      rows="4"
                      [formControl]="form.controls['description']"></textarea>
              </mat-input-container>
          </form>
      </mat-dialog-content>

      <mat-dialog-actions class="adf-dialog-buttons">
          <span class="adf-fill-remaining-space"></span>

          <button
              mat-button
              mat-dialog-close>
              {{ 'CORE.FOLDER_DIALOG.CANCEL_BUTTON.LABEL' | translate }}
          </button>

          <button class="adf-dialog-action-button"
                  mat-button
                  (click)="submit()"
                  [disabled]="!form.valid">
              {{
              (editing
              ? 'CORE.FOLDER_DIALOG.UPDATE_BUTTON.LABEL'
              : 'CORE.FOLDER_DIALOG.CREATE_BUTTON.LABEL'
              ) | translate
              }}
          </button>
      </mat-dialog-actions>
    `
            },] },
];
/**
 * @nocollapse
 */
FolderDialogComponent.ctorParameters = () => [
    { type: FormBuilder, },
    { type: MatDialogRef, },
    { type: NodesApiService, },
    { type: TranslationService, },
    { type: NotificationService, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] },] },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DialogModule {
}
DialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent
                ],
                providers: [
                    NodesApiService,
                    NotificationService,
                    TranslationService
                ],
                exports: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent
                ],
                entryComponents: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
DialogModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_FOLDER_PARENT_ID = '-my-';
class FolderCreateDirective {
    /**
     * @param {?} dialogRef
     * @param {?} content
     */
    constructor(dialogRef, content) {
        this.dialogRef = dialogRef;
        this.content = content;
        this.parentNodeId = DEFAULT_FOLDER_PARENT_ID;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        this.openDialog();
    }
    /**
     * @return {?}
     */
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderCreateDirective;
        const { parentNodeId } = this;
        return {
            data: { parentNodeId },
            width: `${width}px`
        };
    }
    /**
     * @return {?}
     */
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        const /** @type {?} */ dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.afterClosed().subscribe((node) => {
            if (node) {
                content.folderCreate.next(node);
            }
        });
    }
}
FolderCreateDirective.DIALOG_WIDTH = 400;
FolderCreateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-create-folder]'
            },] },
];
/**
 * @nocollapse
 */
FolderCreateDirective.ctorParameters = () => [
    { type: MatDialog, },
    { type: ContentService, },
];
FolderCreateDirective.propDecorators = {
    'parentNodeId': [{ type: Input, args: ['adf-create-folder',] },],
    'onClick': [{ type: HostListener, args: ['click', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FolderEditDirective {
    /**
     * @param {?} dialogRef
     * @param {?} elementRef
     * @param {?} content
     */
    constructor(dialogRef, elementRef, content) {
        this.dialogRef = dialogRef;
        this.elementRef = elementRef;
        this.content = content;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        if (this.folder) {
            this.openDialog();
        }
    }
    /**
     * @return {?}
     */
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderEditDirective;
        const { folder } = this;
        return {
            data: { folder },
            width: `${width}px`
        };
    }
    /**
     * @return {?}
     */
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        const /** @type {?} */ dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.afterClosed().subscribe((node) => {
            if (node) {
                content.folderEdit.next(node);
            }
        });
    }
}
FolderEditDirective.DIALOG_WIDTH = 400;
FolderEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-edit-folder]'
            },] },
];
/**
 * @nocollapse
 */
FolderEditDirective.ctorParameters = () => [
    { type: MatDialog, },
    { type: ElementRef, },
    { type: ContentService, },
];
FolderEditDirective.propDecorators = {
    'folder': [{ type: Input, args: ['adf-edit-folder',] },],
    'onClick': [{ type: HostListener, args: ['click', ['$event'],] },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FolderDirectiveModule {
}
FolderDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    FolderCreateDirective,
                    FolderEditDirective
                ],
                exports: [
                    FolderCreateDirective,
                    FolderEditDirective
                ]
            },] },
];
/**
 * @nocollapse
 */
FolderDirectiveModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentMetadataService {
    /**
     * @param {?} fileSizePipe
     */
    constructor(fileSizePipe) {
        this.fileSizePipe = fileSizePipe;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getBasicProperties(node) {
        return [
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.NAME',
                value: node.name,
                key: 'name',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.TITLE',
                value: node.properties['cm:title'],
                key: 'properties.cm:title',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.CREATOR',
                value: node.createdByUser.displayName,
                key: 'createdByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.CREATED_DATE',
                value: node.createdAt,
                key: 'createdAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.SIZE',
                value: node.content.sizeInBytes,
                key: 'content.sizeInBytes',
                pipes: [{ pipe: this.fileSizePipe }],
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIER',
                value: node.modifiedByUser.displayName,
                key: 'modifiedByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIED_DATE',
                value: node.modifiedAt,
                key: 'modifiedAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MIMETYPE',
                value: node.content.mimeTypeName,
                key: 'content.mimeTypeName',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.AUTHOR',
                value: node.properties['cm:author'],
                key: 'properties.cm:author',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.DESCRIPTION',
                value: node.properties['cm:description'],
                key: 'properties.cm:description',
                multiline: true,
                editable: true
            })
        ];
    }
}
ContentMetadataService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ContentMetadataService.ctorParameters = () => [
    { type: FileSizePipe, },
];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentMetadataComponent {
    /**
     * @param {?} contentMetadataService
     * @param {?} cardViewUpdateService
     * @param {?} nodesApi
     */
    constructor(contentMetadataService, cardViewUpdateService, nodesApi) {
        this.contentMetadataService = contentMetadataService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.nodesApi = nodesApi;
        this.editable = false;
        this.maxPropertiesToShow = Infinity;
        this.properties = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.cardViewUpdateService.itemUpdated$
            .switchMap(this.saveNode.bind(this))
            .subscribe(node => this.node = node, error => this.handleError(error));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.recalculateProperties();
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    saveNode({ changed: nodeBody }) {
        return this.nodesApi.updateNode(this.node.id, nodeBody);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /*tslint:disable-next-line*/
        console.log(error);
    }
    /**
     * @return {?}
     */
    recalculateProperties() {
        let /** @type {?} */ basicProperties = this.contentMetadataService.getBasicProperties(this.node);
        if (this.maxPropertiesToShow) {
            basicProperties = basicProperties.slice(0, this.maxPropertiesToShow);
        }
        this.properties = [...basicProperties];
    }
}
ContentMetadataComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata',
                template: `
      <div class="adf-metadata-properties">
          <adf-card-view [properties]="properties" [editable]="editable"></adf-card-view>
      </div>
    `,
                styles: [`

    `],
                host: { 'class': 'adf-content-metadata' },
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                providers: [CardViewUpdateService],
                viewProviders: [ContentMetadataService, FileSizePipe]
            },] },
];
/**
 * @nocollapse
 */
ContentMetadataComponent.ctorParameters = () => [
    { type: ContentMetadataService, },
    { type: CardViewUpdateService, },
    { type: NodesApiService, },
];
ContentMetadataComponent.propDecorators = {
    'node': [{ type: Input },],
    'editable': [{ type: Input },],
    'maxPropertiesToShow': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PROPERTY_COUNTER_WHILE_COLLAPSED = 5;
class ContentMetadataCardComponent {
    constructor() {
        this.editable = false;
        this.expanded = false;
    }
    /**
     * @return {?}
     */
    toggleEdit() {
        this.editable = !this.editable;
    }
    /**
     * @return {?}
     */
    toggleExpanded() {
        this.expanded = !this.expanded;
    }
    /**
     * @return {?}
     */
    get maxPropertiesToShow() {
        return this.expanded ? Infinity : PROPERTY_COUNTER_WHILE_COLLAPSED;
    }
}
ContentMetadataCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata-card',
                template: `
      <mat-card *ngIf="node">
          <mat-card-content>
              <adf-content-metadata [node]="node" [editable]="editable" [maxPropertiesToShow]="maxPropertiesToShow"></adf-content-metadata>
          </mat-card-content>
          <mat-card-footer class="adf-viewer-default-sidebar-card-footer" fxLayout="row" fxLayoutAlign="space-between stretch">
              <div>
                  <button mat-icon-button>
                      <mat-icon>star_border</mat-icon>
                  </button>
                  <button mat-icon-button (click)="toggleEdit()">
                      <mat-icon>mode_edit</mat-icon>
                  </button>
              </div>
              <button mat-button (click)="toggleExpanded()">
                  <ng-container *ngIf="!expanded">
                      <span>{{ 'ADF_VIEWER.SIDEBAR.METADATA.MORE_INFORMATION' | translate }}</span>
                      <mat-icon>keyboard_arrow_down</mat-icon>
                  </ng-container>
                  <ng-container *ngIf="expanded">
                      <span>{{ 'ADF_VIEWER.SIDEBAR.METADATA.LESS_INFORMATION' | translate }}</span>
                      <mat-icon>keyboard_arrow_up</mat-icon>
                  </ng-container>
              </button>
          </mat-card-footer>
      </mat-card>
    `,
                styles: [`

    `],
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-viewer-default-sidebar' }
            },] },
];
/**
 * @nocollapse
 */
ContentMetadataCardComponent.ctorParameters = () => [];
ContentMetadataCardComponent.propDecorators = {
    'node': [{ type: Input },],
};

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentMetadataModule {
}
ContentMetadataModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FlexLayoutModule,
                    CardViewModule
                ],
                exports: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ],
                declarations: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
ContentMetadataModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentModule {
}
ContentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    SocialModule,
                    TagModule,
                    CommonModule,
                    WebScriptModule,
                    FormsModule,
                    ReactiveFormsModule,
                    SearchModule,
                    BrowserAnimationsModule,
                    DocumentListModule,
                    UploadModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    VersionManagerModule,
                    ContentNodeSelectorModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: {
                            name: 'adf-content-services',
                            source: 'assets/adf-content-services'
                        }
                    }
                ],
                exports: [
                    CoreModule,
                    SocialModule,
                    TagModule,
                    WebScriptModule,
                    DocumentListModule,
                    UploadModule,
                    SearchModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    VersionManagerModule,
                    ContentNodeSelectorModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule,
                    MaterialModule
                ]
            },] },
];
/**
 * @nocollapse
 */
ContentModule.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodePaging {
}
class NodePagingList {
}
class NodeMinimalEntry {
}
class Pagination {
}
class NodeMinimal {
    constructor() {
        this.properties = {};
    }
}
class UserInfo {
}
class ContentInfo {
}
class PathInfoEntity {
}
class PathElementEntity {
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionStyleModel {
    /**
     * @param {?} css
     * @param {?} permission
     * @param {?=} isFile
     * @param {?=} isFolder
     */
    constructor(css, permission, isFile = true, isFolder = true) {
        this.isFolder = true;
        this.isFile = true;
        this.css = css;
        this.permission = permission;
        this.isFile = isFile;
        this.isFolder = isFolder;
    }
}

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ContentModule, SocialModule, TagModule, WebScriptModule, DocumentListModule, UploadModule, ALFRESCO_SEARCH_DIRECTIVES, ALFRESCO_SEARCH_PROVIDERS, SearchModule, SitesDropdownModule, BreadcrumbModule, VersionManagerModule, ContentNodeSelectorModule, DialogModule, FolderDirectiveModule, ContentMetadataModule, RatingComponent, LikeComponent, RatingService, TagActionsComponent, TagListComponent, TagNodeListComponent, TagService, WebscriptComponent, PaginationStrategy, DocumentListComponent, NodeEntityEvent, NodeEntryEvent, ContentColumnComponent, ContentColumnListComponent, ContentActionComponent, ContentActionListComponent, EmptyFolderContentDirective, NoPermissionContentDirective, ShareDataTableAdapter, ShareDataRow, FolderActionsService, DocumentActionsService, DocumentListService, NodeActionsService, ContentActionModel, DocumentActionModel, FolderActionModel, NodePaging, NodePagingList, NodeMinimalEntry, Pagination, NodeMinimal, UserInfo, ContentInfo, PathInfoEntity, PathElementEntity, PermissionModel, PermissionStyleModel, UploadButtonComponent, FileUploadingDialogComponent, UploadDragAreaComponent, FileUploadingListComponent, FileUploadingListRowComponent, FileDraggableDirective, SearchComponent, SearchControlComponent, SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR, SearchTriggerDirective, DropdownSitesComponent, BreadcrumbComponent, DropdownBreadcrumbComponent, VersionListComponent, VersionManagerComponent, VersionUploadComponent, ContentNodeSelectorComponent, ContentNodeSelectorService, DownloadZipDialogComponent, FolderDialogComponent, FolderCreateDirective, FolderEditDirective, ContentMetadataComponent, ContentMetadataService, BreadcrumbComponent as ɵbg, DropdownBreadcrumbComponent as ɵbh, ContentMetadataCardComponent as ɵbq, ContentMetadataComponent as ɵbo, ContentMetadataService as ɵbp, ContentNodeSelectorComponent as ɵbl, ContentNodeSelectorService as ɵbm, DownloadZipDialogComponent as ɵbr, FolderDialogComponent as ɵbs, ContentActionListComponent as ɵbc, ContentActionComponent as ɵy, ContentColumnListComponent as ɵx, ContentColumnComponent as ɵw, DocumentListComponent as ɵu, EmptyFolderContentDirective as ɵbd, NoPermissionContentDirective as ɵbe, DocumentActionsService as ɵz, DocumentListService as ɵv, FolderActionsService as ɵbb, NodeActionsService as ɵba, FolderCreateDirective as ɵbt, FolderEditDirective as ɵbu, MaterialModule as ɵb, modules as ɵa, SearchControlComponent as ɵl, SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR as ɵm, SearchTriggerDirective as ɵn, SearchComponent as ɵk, DropdownSitesComponent as ɵbf, LikeComponent as ɵe, RatingComponent as ɵc, RatingService as ɵd, TagService as ɵg, TagActionsComponent as ɵf, TagListComponent as ɵh, TagNodeListComponent as ɵi, FileUploadingDialogComponent as ɵr, FileUploadingListRowComponent as ɵt, FileUploadingListComponent as ɵs, UploadButtonComponent as ɵq, UploadDragAreaComponent as ɵp, FileDraggableDirective as ɵo, VersionListComponent as ɵbk, VersionManagerComponent as ɵbj, VersionUploadComponent as ɵbi, WebscriptComponent as ɵj };
//# sourceMappingURL=adf-content-services.js.map
